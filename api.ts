/* tslint:disable */
/* eslint-disable */
/**
 * Onfido Public API v3.6
 * The Onfido Public API (v3.6)
 *
 * The version of the OpenAPI document: v3.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

import { FileTransfer } from './file-transfer';
import { AxiosHeaders } from 'axios';

globalAxios.interceptors.response.use(async (response) => {
    if (response.headers instanceof AxiosHeaders && response.headers['content-type']) {
        if ( ! response.headers['content-type'].toString().includes('application/json') ) {
            const contentDisposition = response.headers['content-disposition'];
            var filename = "";

            if (contentDisposition && contentDisposition != "") {
                const matcher = contentDisposition.match(/filename=['\"]?([^'\"\s]+)['\"]?/);

                if (matcher != null) {
                  filename = matcher[1].replace(/.*[/\\\\]/g, "");
                }
            }

            response.data = new FileTransfer(response.data, filename);
        }
    }

    return response;
  });


export interface Address {
    /**
     * The flat number of this address
     */
    'flat_number'?: string;
    /**
     * The building number of this address
     */
    'building_number'?: string;
    /**
     * The building name of this address
     */
    'building_name'?: string;
    /**
     * The street of the applicant\'s address
     */
    'street'?: string;
    /**
     * The sub-street of the applicant\'s address
     */
    'sub_street'?: string;
    /**
     * The town of the applicant\'s address
     */
    'town'?: string;
    /**
     * The postcode or ZIP of the applicant\'s address
     */
    'postcode': string;
    /**
     * The 3 character ISO country code of this address. For example, GBR is the country code for the United Kingdom
     */
    'country': CountryCodes;
    /**
     * The address state. US states must use the USPS abbreviation (see also ISO 3166-2:US), for example AK, CA, or TX.
     */
    'state'?: string;
    /**
     * Line 1 of the applicant\'s address
     */
    'line1'?: string | null;
    /**
     * Line 2 of the applicant\'s address
     */
    'line2'?: string | null;
    /**
     * Line 3 of the applicant\'s address
     */
    'line3'?: string | null;
}


export interface AddressBuilder {
    /**
     * The flat number of this address
     */
    'flat_number'?: string;
    /**
     * The building number of this address
     */
    'building_number'?: string;
    /**
     * The building name of this address
     */
    'building_name'?: string;
    /**
     * The street of the applicant\'s address
     */
    'street'?: string;
    /**
     * The sub-street of the applicant\'s address
     */
    'sub_street'?: string;
    /**
     * The town of the applicant\'s address
     */
    'town'?: string;
    /**
     * The postcode or ZIP of the applicant\'s address
     */
    'postcode': string;
    /**
     * The 3 character ISO country code of this address. For example, GBR is the country code for the United Kingdom
     */
    'country': CountryCodes;
    /**
     * The address state. US states must use the USPS abbreviation (see also ISO 3166-2:US), for example AK, CA, or TX.
     */
    'state'?: string;
    /**
     * Line 1 of the applicant\'s address
     */
    'line1'?: string | null;
    /**
     * Line 2 of the applicant\'s address
     */
    'line2'?: string | null;
    /**
     * Line 3 of the applicant\'s address
     */
    'line3'?: string | null;
}


export interface AddressShared {
    /**
     * The flat number of this address
     */
    'flat_number'?: string;
    /**
     * The building number of this address
     */
    'building_number'?: string;
    /**
     * The building name of this address
     */
    'building_name'?: string;
    /**
     * The street of the applicant\'s address
     */
    'street'?: string;
    /**
     * The sub-street of the applicant\'s address
     */
    'sub_street'?: string;
    /**
     * The town of the applicant\'s address
     */
    'town'?: string;
    /**
     * The postcode or ZIP of the applicant\'s address
     */
    'postcode': string;
    /**
     * The 3 character ISO country code of this address. For example, GBR is the country code for the United Kingdom
     */
    'country': CountryCodes;
    /**
     * The address state. US states must use the USPS abbreviation (see also ISO 3166-2:US), for example AK, CA, or TX.
     */
    'state'?: string;
    /**
     * Line 1 of the applicant\'s address
     */
    'line1'?: string | null;
    /**
     * Line 2 of the applicant\'s address
     */
    'line2'?: string | null;
    /**
     * Line 3 of the applicant\'s address
     */
    'line3'?: string | null;
}


export interface AddressesList {
    'addresses'?: Array<Address>;
}
export interface Applicant {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     */
    'dob'?: string;
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     */
    'phone_number'?: string;
    /**
     * The applicant\'s first name
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     */
    'last_name'?: string;
    /**
     * The unique identifier for the applicant.
     */
    'id': string;
    /**
     * The date and time when this applicant was created.
     */
    'created_at'?: string;
    /**
     * The date and time when this applicant is scheduled to be deleted.
     */
    'delete_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    'sandbox'?: boolean;
    'address'?: Address;
    'location'?: Location;
}
export interface ApplicantBuilder {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     */
    'dob'?: string;
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     */
    'phone_number'?: string;
    /**
     * The applicant\'s consents
     */
    'consents'?: Array<ApplicantConsentBuilder>;
    'address'?: AddressBuilder;
    'location'?: LocationBuilder;
    /**
     * The applicant\'s first name
     */
    'first_name': string;
    /**
     * The applicant\'s surname
     */
    'last_name': string;
}
export interface ApplicantConsent {
    'name': ApplicantConsentName;
    'granted': boolean;
    /**
     * The date and time when this applicant consent was granted, if not granted the value is nil.
     */
    'granted_at': string | null;
}


export interface ApplicantConsentBuilder {
    'name': ApplicantConsentName;
    'granted': boolean;
}



export const ApplicantConsentName = {
    PrivacyNoticesRead: 'privacy_notices_read',
    SsnVerification: 'ssn_verification',
    PhoneNumberVerification: 'phone_number_verification',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ApplicantConsentName = typeof ApplicantConsentName[keyof typeof ApplicantConsentName];


export interface ApplicantCreate {
    /**
     * The applicant\'s first name
     */
    'first_name': string;
    /**
     * The applicant\'s surname
     */
    'last_name': string;
}
export interface ApplicantRequest {
    /**
     * The applicant\'s consents
     */
    'consents'?: Array<ApplicantConsentBuilder>;
    'address'?: AddressBuilder;
    'location'?: LocationBuilder;
}
export interface ApplicantResponse {
    /**
     * The applicant\'s first name
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     */
    'last_name'?: string;
    /**
     * The unique identifier for the applicant.
     */
    'id': string;
    /**
     * The date and time when this applicant was created.
     */
    'created_at'?: string;
    /**
     * The date and time when this applicant is scheduled to be deleted.
     */
    'delete_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    'sandbox'?: boolean;
    'address'?: Address;
    'location'?: Location;
}
export interface ApplicantShared {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     */
    'dob'?: string;
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     */
    'phone_number'?: string;
}
export interface ApplicantUpdate {
    /**
     * The applicant\'s first name
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     */
    'last_name'?: string;
}
export interface ApplicantUpdater {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     */
    'dob'?: string;
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     */
    'phone_number'?: string;
    /**
     * The applicant\'s consents
     */
    'consents'?: Array<ApplicantConsentBuilder>;
    'address'?: AddressBuilder;
    'location'?: LocationBuilder;
    /**
     * The applicant\'s first name
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     */
    'last_name'?: string;
}
export interface ApplicantsList {
    'applicants': Array<Applicant>;
}
export interface Check {
    /**
     * An array of webhook ids describing which webhooks to trigger for this check.
     */
    'webhook_ids'?: Array<string>;
    /**
     * The ID of the applicant to do the check on.
     */
    'applicant_id': string;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false. 
     */
    'applicant_provides_data'?: boolean;
    /**
     * Array of tags being assigned to this check.
     */
    'tags'?: Array<string>;
    /**
     * For checks where `applicant_provides_data` is `true`, redirect to this URI when the applicant has submitted their data.
     */
    'redirect_uri'?: string;
    'privacy_notices_read_consent_given'?: boolean;
    /**
     * The unique identifier for the check.
     */
    'id': string;
    /**
     * The date and time when this check was created.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    'status'?: CheckStatus;
    /**
     * The overall result of the check, based on the results of the constituent reports.
     */
    'result'?: CheckResultEnum;
    /**
     * A link to the applicant form, if `applicant_provides_data` is `true`.
     */
    'form_uri'?: string;
    /**
     * A link to the corresponding results page on the Onfido dashboard.
     */
    'results_uri'?: string;
    /**
     * An array of report ids.
     */
    'report_ids'?: Array<string>;
    /**
     * Indicates whether the object was created in the sandbox or not.
     */
    'sandbox'?: boolean;
    'paused'?: boolean;
    'version'?: string;
}

export const CheckResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckResultEnum = typeof CheckResultEnum[keyof typeof CheckResultEnum];

export interface CheckBuilder {
    /**
     * An array of webhook ids describing which webhooks to trigger for this check.
     */
    'webhook_ids'?: Array<string>;
    /**
     * The ID of the applicant to do the check on.
     */
    'applicant_id': string;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false.
     */
    'applicant_provides_data'?: boolean;
    /**
     * Array of tags being assigned to this check.
     */
    'tags'?: Array<string>;
    /**
     * For checks where `applicant_provides_data` is `true`, redirect to this URI when the applicant has submitted their data.
     */
    'redirect_uri'?: string;
    'privacy_notices_read_consent_given'?: boolean;
    /**
     * An array of report names (strings).
     */
    'report_names': Array<ReportName>;
    /**
     * Optional. An array of document ids, for use with Document reports only. If omitted, the Document report will use the most recently uploaded document by default.
     */
    'document_ids'?: Array<string>;
    /**
     * Defaults to `true`. If set to `false`, you will only receive a response when all reports in your check have completed. 
     */
    'asynchronous'?: boolean;
    /**
     * For checks where `applicant_provides_data` is `true`, applicant form will not be automatically sent if `suppress_form_emails` is set to `true`. You can manually send the form at any time after the check has been created, using the link found in the form_uri attribute of the check object. Write-only. Defaults to false. 
     */
    'suppress_form_emails'?: boolean;
    /**
     * Triggers responses for particular sub-results for sandbox Document reports.
     */
    'sub_result'?: string;
    /**
     * Array of names of particular reports to return consider as their results. This is a feature available in sandbox testing
     */
    'consider'?: Array<ReportName>;
    'us_driving_licence'?: UsDrivingLicenceBuilder;
    /**
     * @deprecated
     */
    'report_configuration'?: ReportConfiguration;
}
export interface CheckRequest {
    /**
     * An array of report names (strings).
     */
    'report_names': Array<ReportName>;
    /**
     * Optional. An array of document ids, for use with Document reports only. If omitted, the Document report will use the most recently uploaded document by default.
     */
    'document_ids'?: Array<string>;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false.
     */
    'applicant_provides_data'?: boolean;
    /**
     * Defaults to `true`. If set to `false`, you will only receive a response when all reports in your check have completed. 
     */
    'asynchronous'?: boolean;
    /**
     * For checks where `applicant_provides_data` is `true`, applicant form will not be automatically sent if `suppress_form_emails` is set to `true`. You can manually send the form at any time after the check has been created, using the link found in the form_uri attribute of the check object. Write-only. Defaults to false. 
     */
    'suppress_form_emails'?: boolean;
    /**
     * Triggers responses for particular sub-results for sandbox Document reports.
     */
    'sub_result'?: string;
    /**
     * Array of names of particular reports to return consider as their results. This is a feature available in sandbox testing
     */
    'consider'?: Array<ReportName>;
    'us_driving_licence'?: UsDrivingLicenceBuilder;
    /**
     * @deprecated
     */
    'report_configuration'?: ReportConfiguration;
}
export interface CheckResponse {
    /**
     * The unique identifier for the check.
     */
    'id': string;
    /**
     * The date and time when this check was created.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    'status'?: CheckStatus;
    /**
     * The overall result of the check, based on the results of the constituent reports.
     */
    'result'?: CheckResponseResultEnum;
    /**
     * A link to the applicant form, if `applicant_provides_data` is `true`.
     */
    'form_uri'?: string;
    /**
     * A link to the corresponding results page on the Onfido dashboard.
     */
    'results_uri'?: string;
    /**
     * An array of report ids.
     */
    'report_ids'?: Array<string>;
    /**
     * Indicates whether the object was created in the sandbox or not.
     */
    'sandbox'?: boolean;
    'paused'?: boolean;
    'version'?: string;
}

export const CheckResponseResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckResponseResultEnum = typeof CheckResponseResultEnum[keyof typeof CheckResponseResultEnum];

export interface CheckShared {
    /**
     * An array of webhook ids describing which webhooks to trigger for this check.
     */
    'webhook_ids'?: Array<string>;
    /**
     * The ID of the applicant to do the check on.
     */
    'applicant_id': string;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false. 
     */
    'applicant_provides_data'?: boolean;
    /**
     * Array of tags being assigned to this check.
     */
    'tags'?: Array<string>;
    /**
     * For checks where `applicant_provides_data` is `true`, redirect to this URI when the applicant has submitted their data.
     */
    'redirect_uri'?: string;
    'privacy_notices_read_consent_given'?: boolean;
}
/**
 * The current state of the check in the checking process.
 */

export const CheckStatus = {
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckStatus = typeof CheckStatus[keyof typeof CheckStatus];


export interface ChecksList {
    'checks': Array<Check>;
}
export interface CompleteTaskBuilder {
    'data': CompleteTaskDataBuilder;
}
/**
 * @type CompleteTaskDataBuilder
 * The Task completion payload.
 */
export type CompleteTaskDataBuilder = Array<object> | object;


export const CountryCodes = {
    Abw: 'ABW',
    Afg: 'AFG',
    Ago: 'AGO',
    Aia: 'AIA',
    Ala: 'ALA',
    Alb: 'ALB',
    And: 'AND',
    Are: 'ARE',
    Arg: 'ARG',
    Arm: 'ARM',
    Asm: 'ASM',
    Ata: 'ATA',
    Atf: 'ATF',
    Atg: 'ATG',
    Aus: 'AUS',
    Aut: 'AUT',
    Aze: 'AZE',
    Bdi: 'BDI',
    Bel: 'BEL',
    Ben: 'BEN',
    Bes: 'BES',
    Bfa: 'BFA',
    Bgd: 'BGD',
    Bgr: 'BGR',
    Bhr: 'BHR',
    Bhs: 'BHS',
    Bih: 'BIH',
    Blm: 'BLM',
    Blr: 'BLR',
    Blz: 'BLZ',
    Bmu: 'BMU',
    Bol: 'BOL',
    Bra: 'BRA',
    Brb: 'BRB',
    Brn: 'BRN',
    Btn: 'BTN',
    Bvt: 'BVT',
    Bwa: 'BWA',
    Caf: 'CAF',
    Can: 'CAN',
    Cck: 'CCK',
    Che: 'CHE',
    Chl: 'CHL',
    Chn: 'CHN',
    Civ: 'CIV',
    Cmr: 'CMR',
    Cod: 'COD',
    Cog: 'COG',
    Cok: 'COK',
    Col: 'COL',
    Com: 'COM',
    Cpv: 'CPV',
    Cri: 'CRI',
    Cub: 'CUB',
    Cuw: 'CUW',
    Cxr: 'CXR',
    Cym: 'CYM',
    Cyp: 'CYP',
    Cze: 'CZE',
    Deu: 'DEU',
    Dji: 'DJI',
    Dma: 'DMA',
    Dnk: 'DNK',
    Dom: 'DOM',
    Dza: 'DZA',
    Ecu: 'ECU',
    Egy: 'EGY',
    Eri: 'ERI',
    Esh: 'ESH',
    Esp: 'ESP',
    Est: 'EST',
    Eth: 'ETH',
    Fin: 'FIN',
    Fji: 'FJI',
    Flk: 'FLK',
    Fra: 'FRA',
    Fro: 'FRO',
    Fsm: 'FSM',
    Gab: 'GAB',
    Gbr: 'GBR',
    Geo: 'GEO',
    Ggy: 'GGY',
    Gha: 'GHA',
    Gib: 'GIB',
    Gin: 'GIN',
    Glp: 'GLP',
    Gmb: 'GMB',
    Gnb: 'GNB',
    Gnq: 'GNQ',
    Grc: 'GRC',
    Grd: 'GRD',
    Grl: 'GRL',
    Gtm: 'GTM',
    Guf: 'GUF',
    Gum: 'GUM',
    Guy: 'GUY',
    Hkg: 'HKG',
    Hmd: 'HMD',
    Hnd: 'HND',
    Hrv: 'HRV',
    Hti: 'HTI',
    Hun: 'HUN',
    Idn: 'IDN',
    Imn: 'IMN',
    Ind: 'IND',
    Iot: 'IOT',
    Irl: 'IRL',
    Irn: 'IRN',
    Irq: 'IRQ',
    Isl: 'ISL',
    Isr: 'ISR',
    Ita: 'ITA',
    Jam: 'JAM',
    Jey: 'JEY',
    Jor: 'JOR',
    Jpn: 'JPN',
    Kaz: 'KAZ',
    Ken: 'KEN',
    Kgz: 'KGZ',
    Khm: 'KHM',
    Kir: 'KIR',
    Kna: 'KNA',
    Kor: 'KOR',
    Kwt: 'KWT',
    Lao: 'LAO',
    Lbn: 'LBN',
    Lbr: 'LBR',
    Lby: 'LBY',
    Lca: 'LCA',
    Lie: 'LIE',
    Lka: 'LKA',
    Lso: 'LSO',
    Ltu: 'LTU',
    Lux: 'LUX',
    Lva: 'LVA',
    Mac: 'MAC',
    Maf: 'MAF',
    Mar: 'MAR',
    Mco: 'MCO',
    Mda: 'MDA',
    Mdg: 'MDG',
    Mdv: 'MDV',
    Mex: 'MEX',
    Mhl: 'MHL',
    Mkd: 'MKD',
    Mli: 'MLI',
    Mlt: 'MLT',
    Mmr: 'MMR',
    Mne: 'MNE',
    Mng: 'MNG',
    Mnp: 'MNP',
    Moz: 'MOZ',
    Mrt: 'MRT',
    Msr: 'MSR',
    Mtq: 'MTQ',
    Mus: 'MUS',
    Mwi: 'MWI',
    Mys: 'MYS',
    Myt: 'MYT',
    Nam: 'NAM',
    Ncl: 'NCL',
    Ner: 'NER',
    Nfk: 'NFK',
    Nga: 'NGA',
    Nic: 'NIC',
    Niu: 'NIU',
    Nld: 'NLD',
    Nor: 'NOR',
    Npl: 'NPL',
    Nru: 'NRU',
    Nzl: 'NZL',
    Omn: 'OMN',
    Pak: 'PAK',
    Pan: 'PAN',
    Pcn: 'PCN',
    Per: 'PER',
    Phl: 'PHL',
    Plw: 'PLW',
    Png: 'PNG',
    Pol: 'POL',
    Pri: 'PRI',
    Prk: 'PRK',
    Prt: 'PRT',
    Pry: 'PRY',
    Pse: 'PSE',
    Pyf: 'PYF',
    Qat: 'QAT',
    Reu: 'REU',
    Rks: 'RKS',
    Rou: 'ROU',
    Rus: 'RUS',
    Rwa: 'RWA',
    Sau: 'SAU',
    Sdn: 'SDN',
    Sen: 'SEN',
    Sgp: 'SGP',
    Sgs: 'SGS',
    Shn: 'SHN',
    Sjm: 'SJM',
    Slb: 'SLB',
    Sle: 'SLE',
    Slv: 'SLV',
    Smr: 'SMR',
    Som: 'SOM',
    Spm: 'SPM',
    Srb: 'SRB',
    Ssd: 'SSD',
    Stp: 'STP',
    Sur: 'SUR',
    Svk: 'SVK',
    Svn: 'SVN',
    Swe: 'SWE',
    Swz: 'SWZ',
    Sxm: 'SXM',
    Syc: 'SYC',
    Syr: 'SYR',
    Tca: 'TCA',
    Tcd: 'TCD',
    Tgo: 'TGO',
    Tha: 'THA',
    Tjk: 'TJK',
    Tkl: 'TKL',
    Tkm: 'TKM',
    Tls: 'TLS',
    Ton: 'TON',
    Tto: 'TTO',
    Tun: 'TUN',
    Tur: 'TUR',
    Tuv: 'TUV',
    Twn: 'TWN',
    Tza: 'TZA',
    Uga: 'UGA',
    Ukr: 'UKR',
    Umi: 'UMI',
    Ury: 'URY',
    Usa: 'USA',
    Uzb: 'UZB',
    Vat: 'VAT',
    Vct: 'VCT',
    Ven: 'VEN',
    Vgb: 'VGB',
    Vir: 'VIR',
    Vnm: 'VNM',
    Vut: 'VUT',
    Wlf: 'WLF',
    Wsm: 'WSM',
    Yem: 'YEM',
    Zaf: 'ZAF',
    Zmb: 'ZMB',
    Zwe: 'ZWE',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CountryCodes = typeof CountryCodes[keyof typeof CountryCodes];


export interface DeviceIntelligenceBreakdown {
    'device'?: DeviceIntelligenceBreakdownDevice;
    /**
     * @deprecated
     */
    'properties'?: DeviceIntelligenceBreakdownProperties;
}
/**
 * Asserts whether the device used to upload the media is trustworthy, i.e. it is a real, physical device.
 */
export interface DeviceIntelligenceBreakdownDevice {
    'breakdown'?: DeviceIntelligenceBreakdownDeviceBreakdown;
}
export interface DeviceIntelligenceBreakdownDeviceBreakdown {
    'application_authenticity'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'device_integrity'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'device_reputation'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
export interface DeviceIntelligenceBreakdownProperties {
    'device'?: DeviceIntelligenceBreakdownPropertiesDevice;
    'ip'?: DeviceIntelligenceBreakdownPropertiesIp;
    'geolocation'?: DeviceIntelligenceBreakdownPropertiesGeolocation;
}
export interface DeviceIntelligenceBreakdownPropertiesDevice {
    /**
     * The SDK version that was used.
     */
    'sdk_version'?: string;
    /**
     * The SDK used to upload the media.
     */
    'sdk_source'?: DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum;
    /**
     * The token used to authenticate the request.
     */
    'authentication_type'?: DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum;
    /**
     * The model as set by the phone manufacturer (for Android and iOS) or the browser manufacturer (for Web). The model can be presented in name or number form depending on each manufacturer implementation.
     */
    'raw_model'?: string;
    /**
     * The operating system of the device. The value came from manufacturer implementation (for Android and iOS) or browser\'s user agent (for Web).
     */
    'os'?: string;
    /**
     * The browser name reported by the browser\'s user agent.
     */
    'browser'?: string;
    /**
     * Whether the device is an emulator.
     */
    'emulator'?: boolean;
    /**
     * Whether the device is providing false randomized device and network information.
     */
    'randomized_device'?: boolean;
    /**
     * Whether device is using stolen security tokens to send the network information.
     */
    'fake_network_request'?: boolean;
    /**
     * Whether there is highly suspicious traffic related to the IP address. The risk depends on the overall ratio of clear checks on a given IP.
     */
    'ip_reputation'?: DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum;
    /**
     * The number of times the device was used to create a report for a new applicant. A value greater than 1 indicates potential device reuse.
     */
    'device_fingerprint_reuse'?: number;
    /**
     * Whether the document or biometric media were uploaded from a single device.
     */
    'single_device_used'?: boolean | null;
    /**
     * Whether the document media were live captured from the device camera.
     */
    'document_capture'?: DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum;
    /**
     * Whether the biometric media were live captured from the device camera.
     */
    'biometric_capture'?: DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum;
}

export const DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = {
    AndroidSdk: 'onfido-android-sdk',
    IosSdk: 'onfido-ios-sdk',
    WebSdk: 'onfido-web-sdk',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = {
    SdkToken: 'sdk_token',
    MobileToken: 'mobile_token',
    ApiToken: 'api_token',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = {
    NotEnoughData: 'NOT_ENOUGH_DATA',
    HighRisk: 'HIGH_RISK',
    LowRisk: 'LOW_RISK',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum];

export interface DeviceIntelligenceBreakdownPropertiesGeolocation {
    /**
     * City location of the IP address.
     */
    'city'?: string;
    /**
     * Region location of the IP address.
     */
    'region'?: string;
    /**
     * Country location of the IP address in a three letter format.
     */
    'country'?: CountryCodes;
}


export interface DeviceIntelligenceBreakdownPropertiesIp {
    /**
     * The IP address that uploaded the media.
     */
    'address'?: string;
}
export interface DeviceIntelligenceProperties {
    'device'?: DeviceIntelligenceBreakdownPropertiesDevice;
    'ip'?: DeviceIntelligenceBreakdownPropertiesIp;
    'geolocation'?: DeviceIntelligenceBreakdownPropertiesGeolocation;
}
export interface DeviceIntelligenceReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: DeviceIntelligenceBreakdown;
    'properties'?: DeviceIntelligenceProperties;
}


export interface Document {
    /**
     * The file type of the uploaded file
     */
    'file_type'?: string;
    /**
     * The type of document
     */
    'type'?: DocumentTypes;
    /**
     * The side of the document, if applicable. The possible values are front and back
     */
    'side'?: DocumentSideEnum;
    /**
     * The issuing country of the document, a 3-letter ISO code.
     */
    'issuing_country'?: CountryCodes;
    /**
     * The ID of the applicant whose document is being uploaded.
     */
    'applicant_id'?: string;
    /**
     * The unique identifier for the document
     */
    'id': string;
    /**
     * The date and time at which the document was uploaded
     */
    'created_at'?: string;
    /**
     * The uri of this resource
     */
    'href'?: string;
    /**
     * The uri that can be used to download the document
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     */
    'file_size'?: number;
}

export const DocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentSideEnum = typeof DocumentSideEnum[keyof typeof DocumentSideEnum];

export interface DocumentBreakdown {
    'data_comparison'?: DocumentBreakdownDataComparison;
    'data_validation'?: DocumentBreakdownDataValidation;
    'image_integrity'?: DocumentBreakdownImageIntegrity;
    'visual_authenticity'?: DocumentBreakdownVisualAuthenticity;
    'data_consistency'?: DocumentBreakdownDataConsistency;
    'police_record'?: DocumentBreakdownPoliceRecord;
    'compromised_document'?: DocumentBreakdownCompromisedDocument;
    'age_validation'?: DocumentBreakdownAgeValidation;
    'issuing_authority'?: DocumentBreakdownIssuingAuthority;
}
/**
 * Asserts whether the age calculated from the document\'s date of birth data point is greater than or equal to the minimum accepted age.
 */
export interface DocumentBreakdownAgeValidation {
    'result'?: string;
    'breakdown'?: DocumentBreakdownAgeValidationBreakdown;
}
export interface DocumentBreakdownAgeValidationBreakdown {
    'minimum_accepted_age'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the image of the document has been found in our internal database or if it was used in a suspicious way.
 */
export interface DocumentBreakdownCompromisedDocument {
    'result'?: string;
    'breakdown'?: DocumentBreakdownCompromisedDocumentBreakdown;
}
export interface DocumentBreakdownCompromisedDocumentBreakdown {
    'document_database'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'repeat_attempts'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether data on the document is consistent with data provided when creating an applicant through the API.
 */
export interface DocumentBreakdownDataComparison {
    'result'?: string;
    'breakdown'?: DocumentBreakdownDataComparisonBreakdown;
}
export interface DocumentBreakdownDataComparisonBreakdown {
    'issuing_country'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'gender'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'date_of_expiry'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_type'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_numbers'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
export interface DocumentBreakdownDataComparisonBreakdownIssuingCountry {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether data represented in multiple places on the document is consistent.
 */
export interface DocumentBreakdownDataConsistency {
    'result'?: string;
    'breakdown'?: DocumentBreakdownDataConsistencyBreakdown;
}
export interface DocumentBreakdownDataConsistencyBreakdown {
    'date_of_expiry'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_numbers'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'issuing_country'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_type'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'gender'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'nationality'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'multiple_data_sources_present'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether algorithmically validatable elements are correct.
 */
export interface DocumentBreakdownDataValidation {
    'result'?: string;
    'breakdown'?: DocumentBreakdownDataValidationBreakdown;
}
export interface DocumentBreakdownDataValidationBreakdown {
    'gender'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_numbers'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_expiration'?: DocumentBreakdownDataValidationBreakdownDocumentExpiration;
    'expiry_date'?: DocumentBreakdownDataValidationBreakdownExpiryDate;
    'mrz'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'barcode'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * If this is flagged, the document has expired.
 */
export interface DocumentBreakdownDataValidationBreakdownDocumentExpiration {
    'result'?: string;
    'properties'?: object;
}
/**
 * If this is flagged, the expiration date has the incorrect format.
 */
export interface DocumentBreakdownDataValidationBreakdownExpiryDate {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts if the document is of sufficient quality to verify.
 */
export interface DocumentBreakdownImageIntegrity {
    'result'?: string;
    'breakdown'?: DocumentBreakdownImageIntegrityBreakdown;
}
export interface DocumentBreakdownImageIntegrityBreakdown {
    'image_quality'?: DocumentBreakdownImageIntegrityBreakdownImageQuality;
    'supported_document'?: DocumentBreakdownImageIntegrityBreakdownSupportedDocument;
    'colour_picture'?: DocumentBreakdownImageIntegrityBreakdownColourPicture;
    'conclusive_document_quality'?: DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality;
}
/**
 * Asserts whether the image was a colour one.
 */
export interface DocumentBreakdownImageIntegrityBreakdownColourPicture {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts if the document was of enough quality to be able to perform a fraud inspection.
 */
export interface DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality {
    'result'?: string;
    'properties'?: DocumentCDQReasons;
}
/**
 * Asserts whether the quality of the image was sufficient for processing.
 */
export interface DocumentBreakdownImageIntegrityBreakdownImageQuality {
    'result'?: string;
    'properties'?: DocumentIQReasons;
}
/**
 * Asserts whether the submitted document is supported.
 */
export interface DocumentBreakdownImageIntegrityBreakdownSupportedDocument {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether data on the document matches the issuing authority data.
 */
export interface DocumentBreakdownIssuingAuthority {
    'result'?: string;
    'breakdown'?: DocumentBreakdownIssuingAuthorityBreakdown;
}
export interface DocumentBreakdownIssuingAuthorityBreakdown {
    'nfc_active_authentication'?: DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication;
    'nfc_passive_authentication'?: DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication;
}
/**
 * Asserts whether the document NFC chip is original or cloned.
 */
export interface DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether the document NFC chip data was tampered.
 */
export interface DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether the document had been identified as lost, stolen or otherwise compromised.
 */
export interface DocumentBreakdownPoliceRecord {
    'result'?: string;
}
/**
 * Asserts whether visual, non-textual, elements are correct given the type of document.
 */
export interface DocumentBreakdownVisualAuthenticity {
    'result'?: string;
    'breakdown'?: DocumentBreakdownVisualAuthenticityBreakdown;
}
export interface DocumentBreakdownVisualAuthenticityBreakdown {
    'fonts'?: DocumentBreakdownVisualAuthenticityBreakdownFonts;
    'picture_face_integrity'?: DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity;
    'template'?: DocumentBreakdownVisualAuthenticityBreakdownTemplate;
    'security_features'?: DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures;
    'original_document_present'?: DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent;
    'digital_tampering'?: DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering;
    'other'?: DocumentBreakdownVisualAuthenticityBreakdownOther;
    'face_detection'?: DocumentBreakdownVisualAuthenticityBreakdownFaceDetection;
}
/**
 * Indication of digital tampering in the image.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering {
    'result'?: string;
    'properties'?: object;
}
/**
 * No face was detected on the document.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownFaceDetection {
    'result'?: string;
    'properties'?: object;
}
/**
 * Fonts in the document don\'t match the expected ones.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownFonts {
    'result'?: string;
    'properties'?: object;
}
/**
 * The document was not present when the photo was taken.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent {
    'result'?: string;
    'properties'?: DocumentODPReasons;
}
/**
 * This sub-breakdown is returned for backward compatibility reasons. Its value will be consider when at least one of the other breakdowns is consider, and clear when all the other breakdowns are clear.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownOther {
    'result'?: string;
    'properties'?: object;
}
/**
 * The pictures of the person identified on the document show signs of tampering or alteration.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity {
    'result'?: string;
    'properties'?: object;
}
/**
 * Security features expected on the document are missing or wrong.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures {
    'result'?: string;
    'properties'?: object;
}
/**
 * The document doesn\'t match the expected template for the document type and country it is from.
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownTemplate {
    'result'?: string;
    'properties'?: object;
}
export interface DocumentCDQReasons {
    /**
     * When data points are obscured to the point that we cannot confirm if the fonts match the expected ones.
     */
    'obscured_data_points'?: string;
    /**
     * When a critical security feature is obscured. This can also refer to when the holder\'s wet signature, necessary for the document to be valid, is not present.
     */
    'obscured_security_features'?: string;
    /**
     * One of 3 reasons (1) OCR Assisted Scans (i.e. when you\'re able to move the mouse and highlight part of text), (2) Severely Washed out Background, (3) Overlapping Text.
     */
    'abnormal_document_features'?: string;
    /**
     * Any digital text or electronic watermarks on the document.
     */
    'watermarks_digital_text_overlay'?: string;
    /**
     * If the corner has been physically cut off. This can be found on some documents that are no longer valid.
     */
    'corner_removed'?: string;
    /**
     * A punched hole is present.
     */
    'punctured_document'?: string;
    /**
     * When the back of a document is needed for processing, but is not available.
     */
    'missing_back'?: string;
    /**
     * When a document has been published digitally, there aren\'t enough security features to review so we cannot perform a full fraud assessment.
     */
    'digital_document'?: string;
}
export interface DocumentIQReasons {
    /**
     * When an image of the document is too dark to be able to see data points.
     */
    'dark_photo'?: string;
    /**
     * When there is light reflecting on the document causing glare to obstruct data points.
     */
    'glare_on_photo'?: string;
    /**
     * When data points are blurred and no reference can be made elsewhere in the document or if the data points are too blurry and \'they could be something else\'.
     */
    'blurred_photo'?: string;
    /**
     * When data points have been covered either by the applicant or by another object such as a sticker.
     */
    'covered_photo'?: string;
    /**
     * Any other reason not listed, such as when holograms are obscuring data points.
     */
    'other_photo_issue'?: string;
    /**
     * When a document is damaged and we are unable to make out data points.
     */
    'damaged_document'?: string;
    /**
     * When the incorrect side of a document has been uploaded, and we have not received the front.
     */
    'incorrect_side'?: string;
    /**
     * When data points are not included in the image due to the document being cut off.
     */
    'cut_off_document'?: string;
    /**
     * If no document has been uploaded or there is a blank image.
     */
    'no_document_in_image'?: string;
    /**
     * When 2 different documents are submitted in the same check.
     */
    'two_documents_uploaded'?: string;
}
export interface DocumentODPReasons {
    /**
     * When the applicant\'s document is on a physical screen or device.
     */
    'photo_of_screen'?: string;
    /**
     * When the applicant has used their mobile phone, tablet, or computer to take a photo within the device.
     */
    'screenshot'?: string;
    /**
     * When the applicant has previously captured an image of the document, printed it out, and has now taken a photo of this print out to upload.
     */
    'document_on_printed_paper'?: string;
    /**
     * When the document has clearly been captured using a scanner and there are visible indicators of this
     */
    'scan'?: string;
}
export interface DocumentProperties {
    'date_of_birth'?: string;
    'date_of_expiry'?: string;
    'personal_number'?: string;
    'document_numbers'?: Array<DocumentPropertiesDocumentNumbersInner>;
    'document_type'?: string;
    'first_name'?: string;
    'middle_name'?: string;
    'last_name'?: string;
    'gender'?: string;
    'issuing_country'?: string;
    'nationality'?: string;
    'issuing_state'?: string;
    'issuing_date'?: string;
    'valid_from'?: string;
    'categorisation'?: string;
    'mrz_line1'?: string;
    'mrz_line2'?: string;
    'mrz_line3'?: string;
    'address'?: string;
    'place_of_birth'?: string;
    'spouse_name'?: string;
    'widow_name'?: string;
    'alias_name'?: string;
    'issuing_authority'?: string;
    'remarks'?: string;
    'civil_state'?: string;
    'expatriation'?: string;
    'father_name'?: string;
    'mother_name'?: string;
    'religion'?: string;
    'type_of_permit'?: string;
    'version_number'?: string;
    'document_subtype'?: string;
    'profession'?: string;
    'security_document_number'?: string;
    'tax_number'?: string;
    'nist_identity_evidence_strength'?: DocumentPropertiesNistIdentityEvidenceStrengthEnum;
    'has_issuance_confirmation'?: DocumentPropertiesHasIssuanceConfirmationEnum;
    'real_id_compliance'?: boolean;
    'security_tier'?: DocumentPropertiesSecurityTierEnum;
    'address_lines'?: DocumentPropertiesAddressLines;
    'barcode'?: Array<DocumentPropertiesBarcodeInner>;
    'nfc'?: DocumentPropertiesNfc;
    'document_classification'?: DocumentPropertiesDocumentClassification;
    'extracted_data'?: DocumentPropertiesExtractedData;
}

export const DocumentPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesNistIdentityEvidenceStrengthEnum = typeof DocumentPropertiesNistIdentityEvidenceStrengthEnum[keyof typeof DocumentPropertiesNistIdentityEvidenceStrengthEnum];
export const DocumentPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesHasIssuanceConfirmationEnum = typeof DocumentPropertiesHasIssuanceConfirmationEnum[keyof typeof DocumentPropertiesHasIssuanceConfirmationEnum];
export const DocumentPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesSecurityTierEnum = typeof DocumentPropertiesSecurityTierEnum[keyof typeof DocumentPropertiesSecurityTierEnum];

export interface DocumentPropertiesAddressLines {
    'street_address'?: string;
    'state'?: string;
    'postal_code'?: string;
    'country'?: string;
    'city'?: string;
    'country_code'?: string;
}
export interface DocumentPropertiesBarcodeInner {
    'first_name'?: string;
    'middle_name'?: string;
    'last_name'?: string;
    'document_type'?: string;
    'date_of_expiry'?: string;
    'date_of_birth'?: string;
    'issuing_date'?: string;
    'address_line_1'?: string;
    'address_line_2'?: string;
    'address_line_3'?: string;
    'address_line_4'?: string;
    'address_line_5'?: string;
    'issuing_state'?: string;
    'class'?: string;
    'gender'?: string;
    'issuing_country'?: string;
    'document_number'?: string;
    'real_id_classification'?: string;
}
export interface DocumentPropertiesDocumentClassification {
    'issuing_country'?: string;
    'document_type'?: string;
    'issuing_state'?: string;
}
export interface DocumentPropertiesDocumentNumbersInner {
    'value'?: string;
    'type'?: string;
}
export interface DocumentPropertiesDrivingLicenceInformationItem {
    'category'?: string;
    'obtainment_date'?: string;
    'expiry_date'?: string;
    'codes'?: string;
}
export interface DocumentPropertiesExtractedData {
    'document_number'?: string;
    'date_of_birth'?: string;
    'date_of_expiry'?: string;
    'first_name'?: string;
    'last_name'?: string;
    'middle_name'?: string;
    'full_name'?: string;
    'spouse_name'?: string;
    'widow_name'?: string;
    'alias_name'?: string;
    'gender'?: string;
    'mrz_line1'?: string;
    'mrz_line2'?: string;
    'mrz_line3'?: string;
    'nationality'?: string;
    'address_line_1'?: string;
    'address_line_2'?: string;
    'address_line_3'?: string;
    'address_line_4'?: string;
    'address_line_5'?: string;
    'issuing_authority'?: string;
}
export interface DocumentPropertiesNfc {
    'document_type'?: string;
    'issuing_country'?: string;
    'full_name'?: string;
    'document_number'?: string;
    'nationality'?: string;
    'date_of_birth'?: string;
    'gender'?: string;
    'date_of_expiry'?: string;
    'personal_number'?: string;
    'place_of_birth'?: string;
    'address'?: string;
    'issuing_date'?: string;
    'issuing_authority'?: string;
}
export interface DocumentPropertiesWithDrivingLicenceInformation {
    'date_of_birth'?: string;
    'date_of_expiry'?: string;
    'personal_number'?: string;
    'document_numbers'?: Array<DocumentPropertiesDocumentNumbersInner>;
    'document_type'?: string;
    'first_name'?: string;
    'middle_name'?: string;
    'last_name'?: string;
    'gender'?: string;
    'issuing_country'?: string;
    'nationality'?: string;
    'issuing_state'?: string;
    'issuing_date'?: string;
    'valid_from'?: string;
    'categorisation'?: string;
    'mrz_line1'?: string;
    'mrz_line2'?: string;
    'mrz_line3'?: string;
    'address'?: string;
    'place_of_birth'?: string;
    'spouse_name'?: string;
    'widow_name'?: string;
    'alias_name'?: string;
    'issuing_authority'?: string;
    'remarks'?: string;
    'civil_state'?: string;
    'expatriation'?: string;
    'father_name'?: string;
    'mother_name'?: string;
    'religion'?: string;
    'type_of_permit'?: string;
    'version_number'?: string;
    'document_subtype'?: string;
    'profession'?: string;
    'security_document_number'?: string;
    'tax_number'?: string;
    'nist_identity_evidence_strength'?: DocumentPropertiesWithDrivingLicenceInformationNistIdentityEvidenceStrengthEnum;
    'has_issuance_confirmation'?: DocumentPropertiesWithDrivingLicenceInformationHasIssuanceConfirmationEnum;
    'real_id_compliance'?: boolean;
    'security_tier'?: DocumentPropertiesWithDrivingLicenceInformationSecurityTierEnum;
    'address_lines'?: DocumentPropertiesAddressLines;
    'barcode'?: Array<DocumentPropertiesBarcodeInner>;
    'nfc'?: DocumentPropertiesNfc;
    'document_classification'?: DocumentPropertiesDocumentClassification;
    'extracted_data'?: DocumentPropertiesExtractedData;
    'driving_licence_information'?: Array<DocumentPropertiesDrivingLicenceInformationItem>;
}

export const DocumentPropertiesWithDrivingLicenceInformationNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesWithDrivingLicenceInformationNistIdentityEvidenceStrengthEnum = typeof DocumentPropertiesWithDrivingLicenceInformationNistIdentityEvidenceStrengthEnum[keyof typeof DocumentPropertiesWithDrivingLicenceInformationNistIdentityEvidenceStrengthEnum];
export const DocumentPropertiesWithDrivingLicenceInformationHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesWithDrivingLicenceInformationHasIssuanceConfirmationEnum = typeof DocumentPropertiesWithDrivingLicenceInformationHasIssuanceConfirmationEnum[keyof typeof DocumentPropertiesWithDrivingLicenceInformationHasIssuanceConfirmationEnum];
export const DocumentPropertiesWithDrivingLicenceInformationSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesWithDrivingLicenceInformationSecurityTierEnum = typeof DocumentPropertiesWithDrivingLicenceInformationSecurityTierEnum[keyof typeof DocumentPropertiesWithDrivingLicenceInformationSecurityTierEnum];

export interface DocumentReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    'breakdown'?: DocumentBreakdown;
    'properties'?: DocumentProperties;
}


export interface DocumentReportShared {
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
}
export interface DocumentResponse {
    /**
     * The unique identifier for the document
     */
    'id': string;
    /**
     * The date and time at which the document was uploaded
     */
    'created_at'?: string;
    /**
     * The uri of this resource
     */
    'href'?: string;
    /**
     * The uri that can be used to download the document
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     */
    'file_size'?: number;
}
export interface DocumentShared {
    /**
     * The file type of the uploaded file
     */
    'file_type'?: string;
    /**
     * The type of document
     */
    'type'?: DocumentTypes;
    /**
     * The side of the document, if applicable. The possible values are front and back
     */
    'side'?: DocumentSharedSideEnum;
    /**
     * The issuing country of the document, a 3-letter ISO code.
     */
    'issuing_country'?: CountryCodes;
    /**
     * The ID of the applicant whose document is being uploaded.
     */
    'applicant_id'?: string;
}

export const DocumentSharedSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentSharedSideEnum = typeof DocumentSharedSideEnum[keyof typeof DocumentSharedSideEnum];


export const DocumentTypes = {
    Passport: 'passport',
    DrivingLicence: 'driving_licence',
    NationalIdentityCard: 'national_identity_card',
    ResidencePermit: 'residence_permit',
    PassportCard: 'passport_card',
    TaxId: 'tax_id',
    Visa: 'visa',
    VoterId: 'voter_id',
    ResidenceStatusDocument: 'residence_status_document',
    PostalIdentityCard: 'postal_identity_card',
    SocialSecurityCard: 'social_security_card',
    WorkPermit: 'work_permit',
    AsylumRegistrationCard: 'asylum_registration_card',
    NationalHealthInsuranceCard: 'national_health_insurance_card',
    MunicipalityIdentityCard: 'municipality_identity_card',
    PrivateOperatorsCard: 'private_operators_card',
    ProofOfCitizenship: 'proof_of_citizenship',
    ServiceIdCard: 'service_id_card',
    ImmigrationStatusDocument: 'immigration_status_document',
    IndigenousCard: 'indigenous_card',
    VehicleRegistrationCard: 'vehicle_registration_card',
    CertificateOfNaturalisation: 'certificate_of_naturalisation',
    ProfessionalQualificationCard: 'professional_qualification_card',
    ConsularId: 'consular_id',
    InternationalDrivingLicence: 'international_driving_licence',
    HomeOfficeLetter: 'home_office_letter',
    BirthCertificate: 'birth_certificate',
    VehicleRegistrationCertificate: 'vehicle_registration_certificate',
    FormForAffixingTheVisa: 'form_for_affixing_the_visa',
    IdentificationNumberDocument: 'identification_number_document',
    AdoptionCertificate: 'adoption_certificate',
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    BankStatement: 'bank_statement',
    BenefitLetters: 'benefit_letters',
    Cbt: 'cbt',
    CertificateOfSponsorship: 'certificate_of_sponsorship',
    CharacterReference: 'character_reference',
    CivilPartnershipCertificate: 'civil_partnership_certificate',
    CouncilTax: 'council_tax',
    CreditCardStatement: 'credit_card_statement',
    DeedPoll: 'deed_poll',
    DivorceAbsoluteDecree: 'divorce_absolute_decree',
    EducationalStatement: 'educational_statement',
    ElectricityBill: 'electricity_bill',
    GasBill: 'gas_bill',
    GovernmentLetter: 'government_letter',
    InternetBill: 'internet_bill',
    MarriageCertificate: 'marriage_certificate',
    MotorcycleInsurance: 'motorcycle_insurance',
    NationalInsuranceCard: 'national_insurance_card',
    NaturalisationCertificate: 'naturalisation_certificate',
    NonUkDrivingLicence: 'non_uk_driving_licence',
    P45P60: 'p45_p60',
    Payslip: 'payslip',
    PhoneBill: 'phone_bill',
    ProfessionalIdentificationCard: 'professional_identification_card',
    RightToWorkShareCodeResult: 'right_to_work_share_code_result',
    StatementFact: 'statement_fact',
    T4StudentUniversityTermDatesEvidence: 't4_student_university_term_dates_evidence',
    UkBiometricResidencePermit: 'uk_biometric_residence_permit',
    UkDrivingLicence: 'uk_driving_licence',
    Unknown: 'unknown',
    UtilityBill: 'utility_bill',
    UtilityBillElectric: 'utility_bill_electric',
    UtilityBillGas: 'utility_bill_gas',
    UtilityBillOther: 'utility_bill_other',
    WaterBill: 'water_bill',
    AddressCertificate: 'address_certificate',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    AccommodationTenancyCertificate: 'accommodation_tenancy_certificate',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentTypes = typeof DocumentTypes[keyof typeof DocumentTypes];


export interface DocumentVideoReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    'breakdown'?: DocumentBreakdown;
    'properties'?: DocumentProperties;
}


export interface DocumentVideoWithAddressInformationReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    'breakdown'?: DocumentBreakdown;
    'properties'?: DocumentProperties;
}


export interface DocumentWithAddressInformationReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    'breakdown'?: DocumentBreakdown;
    'properties'?: DocumentProperties;
}


export interface DocumentWithDriverVerificationReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    'breakdown'?: DocumentBreakdown;
    'properties'?: DocumentWithDriverVerificationReportAllOfProperties;
}


export interface DocumentWithDriverVerificationReportAllOfProperties {
    'date_of_birth'?: string;
    'date_of_expiry'?: string;
    'personal_number'?: string;
    'document_numbers'?: Array<DocumentPropertiesDocumentNumbersInner>;
    'document_type'?: string;
    'first_name'?: string;
    'middle_name'?: string;
    'last_name'?: string;
    'gender'?: string;
    'issuing_country'?: string;
    'nationality'?: string;
    'issuing_state'?: string;
    'issuing_date'?: string;
    'valid_from'?: string;
    'categorisation'?: string;
    'mrz_line1'?: string;
    'mrz_line2'?: string;
    'mrz_line3'?: string;
    'address'?: string;
    'place_of_birth'?: string;
    'spouse_name'?: string;
    'widow_name'?: string;
    'alias_name'?: string;
    'issuing_authority'?: string;
    'remarks'?: string;
    'civil_state'?: string;
    'expatriation'?: string;
    'father_name'?: string;
    'mother_name'?: string;
    'religion'?: string;
    'type_of_permit'?: string;
    'version_number'?: string;
    'document_subtype'?: string;
    'profession'?: string;
    'security_document_number'?: string;
    'tax_number'?: string;
    'nist_identity_evidence_strength'?: DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum;
    'has_issuance_confirmation'?: DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum;
    'real_id_compliance'?: boolean;
    'security_tier'?: DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum;
    'address_lines'?: DocumentPropertiesAddressLines;
    'barcode'?: Array<DocumentPropertiesBarcodeInner>;
    'nfc'?: DocumentPropertiesNfc;
    'document_classification'?: DocumentPropertiesDocumentClassification;
    'extracted_data'?: DocumentPropertiesExtractedData;
    /**
     * True for **non-restricted** driving licences
     */
    'drivers_licence'?: boolean;
    /**
     * True for **limited/restricted** driving license, including learner\'s permits
     */
    'restricted_licence'?: boolean;
    /**
     * Underlying, non-normalised, licence category (e.g. \"Junior operators license\")
     */
    'raw_licence_category'?: string;
    /**
     * Comma-separated vehicle classes that the user is qualified for
     */
    'raw_vehicle_classes'?: string;
    /**
     * True if the user is not qualified to drive a manual transmission
     */
    'manual_transmission_restriction'?: boolean;
    /**
     * Detailed classes/categories information
     */
    'vehicle_class_details'?: Array<DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner>;
    'passenger_vehicle'?: DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle;
}

export const DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = typeof DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum[keyof typeof DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum];
export const DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = typeof DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum[keyof typeof DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum];
export const DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = typeof DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum[keyof typeof DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum];

/**
 * Normalised data for passenger cars
 */
export interface DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle {
    /**
     * Whether they are qualified for a passenger car, such as a B class in the UK
     */
    'is_qualified'?: boolean;
    /**
     * Date the class qualification was obtained
     */
    'obtainment_date'?: string;
    /**
     * Date the class qualification expires, which may be different to doc expiry
     */
    'expiry_date'?: string;
}
export interface DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner {
    /**
     * Vehicle class/category
     */
    'category'?: string;
    /**
     * Special conditions driver must meet
     */
    'codes'?: string;
    /**
     * Category obtainment date
     */
    'obtainment_date'?: string;
    /**
     * Category expiry date
     */
    'expiry_date'?: string;
}
export interface DocumentWithDrivingLicenceInformationReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    'breakdown'?: DocumentBreakdown;
    'properties'?: DocumentPropertiesWithDrivingLicenceInformation;
}


export interface DocumentsList {
    'documents': Array<Document>;
}
export interface Error1 {
    /**
     * The unique identifier of the uploaded document
     */
    'document_id'?: string;
    'error'?: ErrorProperties1;
}
export interface ErrorProperties {
    'type'?: string;
    'message'?: string;
    'fields'?: { [key: string]: any; };
}
export interface ErrorProperties1 {
    'type'?: string;
    'message'?: string;
}
export interface ExtractRequest {
    /**
     * The unique identifier of the uploaded document to run extraction on
     */
    'document_id': string;
}
export interface Extraction {
    /**
     * The unique identifier of the uploaded document.
     */
    'document_id'?: string;
    'document_classification'?: ExtractionDocumentClassification;
    'extracted_data'?: ExtractionExtractedData;
}
export interface ExtractionDocumentClassification {
    /**
     * Document country in 3-letter ISO code.
     */
    'issuing_country'?: CountryCodes;
    /**
     * Type of document.
     */
    'document_type'?: DocumentTypes;
    /**
     * The state that issued the document (if available).
     */
    'issuing_state'?: string;
    /**
     * The document subtype (if available).
     */
    'subtype'?: ExtractionDocumentClassificationSubtypeEnum;
    /**
     * The document issuing version (if available).
     */
    'version'?: string;
}

export const ExtractionDocumentClassificationSubtypeEnum = {
    Spe: 'SPE',
    Ali: 'ali',
    Alien: 'alien',
    Com: 'com',
    Commercial: 'commercial',
    Dom: 'dom',
    Domestic: 'domestic',
    Full: 'full',
    NotFull: 'not_full',
    FullDrivingLicence: 'full driving licence',
    HeavyVehicle: 'heavy_vehicle',
    Learner: 'learner',
    MinorU21OrU18: 'minor (u21 or u18)',
    Mot: 'mot',
    Mul: 'mul',
    Provisional: 'provisional',
    ProvisionalDrivingLicence: 'provisional driving licence',
    Ser: 'ser',
    Spe2: 'spe',
    Special: 'special',
    Standard: 'standard',
    Tem: 'tem',
    U21: 'u21',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ExtractionDocumentClassificationSubtypeEnum = typeof ExtractionDocumentClassificationSubtypeEnum[keyof typeof ExtractionDocumentClassificationSubtypeEnum];

export interface ExtractionExtractedData {
    /**
     * The official document number.
     */
    'document_number'?: string;
    /**
     * First name.
     */
    'first_name'?: string;
    /**
     * Last name.
     */
    'last_name'?: string;
    /**
     * Full name.
     */
    'full_name'?: string;
    /**
     * Spouse name (French documents only).
     */
    'spouse_name'?: string;
    /**
     * Widow name (French documents only).
     */
    'widow_name'?: string;
    /**
     * Alias name (French documents only).
     */
    'alias_name'?: string;
    /**
     * Gender (Valid values are Male and Female).
     */
    'gender'?: ExtractionExtractedDataGenderEnum;
    /**
     * Date of birth in YYYY-MM-DD format.
     */
    'date_of_birth'?: string;
    /**
     * Date of expiry in YYYY-MM-DD format.
     */
    'date_of_expiry'?: string;
    /**
     * Date of expiry in YYYY-MM-DD format.
     */
    'expiry_date'?: string;
    /**
     * Nationality in 3-letter ISO code.
     */
    'nationality'?: string;
    /**
     * Line 1 of the MRZ code.
     */
    'mrz_line_1'?: string;
    /**
     * Line 2 of the MRZ code.
     */
    'mrz_line_2'?: string;
    /**
     * Line 3 of the MRZ code.
     */
    'mrz_line_3'?: string;
    /**
     * Line 1 of the address.
     */
    'address_1'?: string;
    /**
     * Line 2 of the address.
     */
    'address_2'?: string;
    /**
     * Line 3 of the address.
     */
    'address_3'?: string;
    /**
     * Line 4 of the address.
     */
    'address_4'?: string;
    /**
     * Line 5 of the address.
     */
    'address_5'?: string;
    /**
     * Issuing authority.
     */
    'issuing_authority'?: string;
    /**
     * Document country in 3-letter ISO code.
     */
    'issuing_country'?: CountryCodes;
    /**
     * Type of document.
     */
    'document_type'?: DocumentTypes;
    /**
     * Place of birth.
     */
    'place_of_birth'?: string;
    /**
     * The state that issued the document.
     */
    'issuing_state'?: string;
    /**
     * Issuing date in YYYY-MM-DD format.
     */
    'issuing_date'?: string;
    /**
     * The owner\'s unique identification number.
     */
    'personal_number'?: string;
}

export const ExtractionExtractedDataGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ExtractionExtractedDataGenderEnum = typeof ExtractionExtractedDataGenderEnum[keyof typeof ExtractionExtractedDataGenderEnum];

export interface FacialSimilarityMotionBreakdown {
    'face_comparison'?: FacialSimilarityMotionBreakdownFaceComparison;
    'image_integrity'?: FacialSimilarityMotionBreakdownImageIntegrity;
    'visual_authenticity'?: FacialSimilarityMotionBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the face in the document matches the face in the motion capture.
 */
export interface FacialSimilarityMotionBreakdownFaceComparison {
    'result'?: string;
    'breakdown'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdown;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 */
export interface FacialSimilarityMotionBreakdownImageIntegrity {
    'result'?: string;
    'breakdown'?: FacialSimilarityMotionBreakdownImageIntegrityBreakdown;
}
export interface FacialSimilarityMotionBreakdownImageIntegrityBreakdown {
    'face_detected'?: FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected;
    'source_integrity'?: FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts a single face of good enough quality has been found in both the document image and in the motion capture.
 */
export interface FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether the motion capture is trustworthy - e.g. not from a fake webcam.
 */
export interface FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity {
    'result'?: string;
    'properties'?: VideoReasons;
}
/**
 * Asserts whether the person in the motion capture is real (not a spoof) and live.
 */
export interface FacialSimilarityMotionBreakdownVisualAuthenticity {
    'result'?: string;
    'breakdown'?: FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown;
}
export interface FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown {
    'liveness_detected'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected;
    'spoofing_detection'?: FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection;
}
/**
 * Asserts whether the motion capture is not a spoof (such as videos of digital screens).
 */
export interface FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection {
    'result'?: string;
    'properties'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties;
}
export interface FacialSimilarityMotionProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. videos of digital screens, masks or print-outs). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     */
    'score'?: number;
}
export interface FacialSimilarityMotionReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    /**
     * Array of objects with live photo ids that were used in the Onfido engine.
     */
    'live_photos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with live video ids that were used in the Onfido engine.
     */
    'live_videos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with motion capture ids that were used in the Onfido engine.
     */
    'motion_captures'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with id photo ids that were used in the Onfido engine.
     */
    'id_photos'?: Array<FacialSimilarityReportMedia>;
    'breakdown'?: FacialSimilarityMotionBreakdown;
    'properties'?: FacialSimilarityMotionProperties;
}


export interface FacialSimilarityPhotoBreakdown {
    'face_comparison'?: FacialSimilarityPhotoBreakdownFaceComparison;
    'image_integrity'?: FacialSimilarityPhotoBreakdownImageIntegrity;
    'visual_authenticity'?: FacialSimilarityPhotoBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the face in the document matches the face in the live photo.
 */
export interface FacialSimilarityPhotoBreakdownFaceComparison {
    'result'?: string;
    'breakdown'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdown;
}
export interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdown {
    'face_match'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch;
}
/**
 * Contains a score value under the properties bag.
 */
export interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch {
    'result'?: string;
    'properties'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties;
}
export interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties {
    /**
     * A floating point number between 0 and 1 that expresses how similar the two faces are, where 1 is a perfect match.
     */
    'score'?: number;
    /**
     * The UUID for the document containing the extracted face that was used for face matching.
     */
    'document_id'?: string;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrity {
    'result'?: string;
    'breakdown'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdown;
}
export interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdown {
    'face_detected'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected;
    'source_integrity'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts a single face of good enough quality has been found in both the document image and the live photo.
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether the live photo is trustworthy - i.e. not digitally tampered, from a fake webcam, or from other dubious sources.
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity {
    'result'?: string;
    'properties'?: PhotoReasons;
}
/**
 * Asserts whether the person in the live photo is real and not a spoof.
 */
export interface FacialSimilarityPhotoBreakdownVisualAuthenticity {
    'result'?: string;
    'breakdown'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown;
}
export interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown {
    'spoofing_detection'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection;
}
/**
 * Contains a score value under the properties bag.
 */
export interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection {
    'result'?: string;
    'properties'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties;
}
export interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof.
     */
    'score'?: number;
}
export interface FacialSimilarityPhotoFullyAutoBreakdown {
    'face_comparison'?: FacialSimilarityPhotoBreakdownFaceComparison;
    'image_integrity'?: FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity;
    'visual_authenticity'?: FacialSimilarityPhotoBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 */
export interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity {
    'result'?: string;
    'breakdown'?: FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown;
}
export interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown {
    'face_detected'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected;
    'source_integrity'?: FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts whether the live photo is trustworthy - i.e. not digitally tampered, from a fake webcam, or from other dubious sources.
 */
export interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity {
    'result'?: string;
    'properties'?: PhotoAutoReasons;
}
export interface FacialSimilarityPhotoFullyAutoProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. photos of printed photos, or photos of digital screens). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     */
    'score'?: number;
}
export interface FacialSimilarityPhotoFullyAutoReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    /**
     * Array of objects with live photo ids that were used in the Onfido engine.
     */
    'live_photos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with live video ids that were used in the Onfido engine.
     */
    'live_videos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with motion capture ids that were used in the Onfido engine.
     */
    'motion_captures'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with id photo ids that were used in the Onfido engine.
     */
    'id_photos'?: Array<FacialSimilarityReportMedia>;
    'breakdown'?: FacialSimilarityPhotoFullyAutoBreakdown;
    'properties'?: FacialSimilarityPhotoFullyAutoProperties;
}


export interface FacialSimilarityPhotoProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. photos of printed photos, or photos of digital screens). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     */
    'score'?: number;
}
export interface FacialSimilarityPhotoReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    /**
     * Array of objects with live photo ids that were used in the Onfido engine.
     */
    'live_photos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with live video ids that were used in the Onfido engine.
     */
    'live_videos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with motion capture ids that were used in the Onfido engine.
     */
    'motion_captures'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with id photo ids that were used in the Onfido engine.
     */
    'id_photos'?: Array<FacialSimilarityReportMedia>;
    'breakdown'?: FacialSimilarityPhotoBreakdown;
    'properties'?: FacialSimilarityPhotoProperties;
}


export interface FacialSimilarityReportMedia {
    /**
     * ID of uploaded biometric media to use.
     */
    'id': string;
}
export interface FacialSimilarityReportShared {
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    /**
     * Array of objects with live photo ids that were used in the Onfido engine.
     */
    'live_photos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with live video ids that were used in the Onfido engine.
     */
    'live_videos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with motion capture ids that were used in the Onfido engine.
     */
    'motion_captures'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with id photo ids that were used in the Onfido engine.
     */
    'id_photos'?: Array<FacialSimilarityReportMedia>;
}
export interface FacialSimilarityVideoBreakdown {
    'face_comparison'?: FacialSimilarityVideoBreakdownFaceComparison;
    'image_integrity'?: FacialSimilarityVideoBreakdownImageIntegrity;
    'visual_authenticity'?: FacialSimilarityVideoBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the face in the document matches the face in the live video.
 */
export interface FacialSimilarityVideoBreakdownFaceComparison {
    'result'?: string;
    'breakdown'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdown;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 */
export interface FacialSimilarityVideoBreakdownImageIntegrity {
    'result'?: string;
    'breakdown'?: FacialSimilarityVideoBreakdownImageIntegrityBreakdown;
}
export interface FacialSimilarityVideoBreakdownImageIntegrityBreakdown {
    'face_detected'?: FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected;
    'source_integrity'?: FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts a single face of good enough quality has been found in both the document image and the live video.
 */
export interface FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether the live video is trustworthy - e.g. not from a fake webcam.
 */
export interface FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity {
    'result'?: string;
    'properties'?: VideoReasons;
}
/**
 * Asserts whether the person in the live video is real (not a spoof) and live.
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticity {
    'result'?: string;
    'breakdown'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown;
}
export interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown {
    'liveness_detected'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected;
    'spoofing_detection'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection;
}
/**
 * Asserts whether the numbers and head movements were correctly executed.
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts whether the live video is not a spoof (such as videos of digital screens).
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection {
    'result'?: string;
    'properties'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties;
}
export interface FacialSimilarityVideoProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. videos of digital screens, masks or print-outs). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     */
    'score'?: number;
}
export interface FacialSimilarityVideoReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    /**
     * Array of objects with document ids that were used in the Onfido engine.
     */
    'documents'?: Array<ReportDocument>;
    /**
     * Array of objects with live photo ids that were used in the Onfido engine.
     */
    'live_photos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with live video ids that were used in the Onfido engine.
     */
    'live_videos'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with motion capture ids that were used in the Onfido engine.
     */
    'motion_captures'?: Array<FacialSimilarityReportMedia>;
    /**
     * Array of objects with id photo ids that were used in the Onfido engine.
     */
    'id_photos'?: Array<FacialSimilarityReportMedia>;
    'breakdown'?: FacialSimilarityVideoBreakdown;
    'properties'?: FacialSimilarityVideoProperties;
}


export interface IdNumber {
    /**
     * Type of ID number.
     */
    'type'?: IdNumberTypeEnum;
    /**
     * Value of ID number
     */
    'value'?: string;
    /**
     * Two letter code of issuing state (state-issued driving licenses only)
     */
    'state_code'?: string;
}

export const IdNumberTypeEnum = {
    Ssn: 'ssn',
    SocialInsurance: 'social_insurance',
    TaxId: 'tax_id',
    IdentityCard: 'identity_card',
    DrivingLicense: 'driving_license',
    DrivingLicence: 'driving_licence',
    ShareCode: 'share_code',
    VoterId: 'voter_id',
    Passport: 'passport',
    Other: 'other',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type IdNumberTypeEnum = typeof IdNumberTypeEnum[keyof typeof IdNumberTypeEnum];

export interface IdPhoto {
    /**
     * The unique identifier for the photo.
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     */
    'file_size'?: number;
}
export interface IdPhotoResponse {
    /**
     * The unique identifier for the photo.
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     */
    'file_size'?: number;
}
export interface IdPhotosList {
    'id_photos': Array<IdPhoto>;
}
export interface IdentityEnhancedBreakdown {
    'sources'?: IdentityEnhancedBreakdownSources;
    'address'?: IdentityEnhancedBreakdownAddress;
    'date_of_birth'?: IdentityEnhancedBreakdownDateOfBirth;
    'mortality'?: IdentityEnhancedBreakdownMortality;
    'ssn'?: IdrSsnBreakdown;
    'ssn1'?: IdrSsnBreakdown;
}
/**
 * Asserts if the applicant\'s address matches any sources.
 */
export interface IdentityEnhancedBreakdownAddress {
    'result'?: string;
    'breakdown'?: IdentityEnhancedBreakdownAddressBreakdown;
}
export interface IdentityEnhancedBreakdownAddressBreakdown {
    'credit_agencies'?: IdentityEnhancedBreakdownAddressBreakdownCreditAgencies;
    'telephone_database'?: IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase;
    'voting_register'?: IdentityEnhancedBreakdownAddressBreakdownVotingRegister;
}
/**
 * The number of address matches against credit agencies.
 */
export interface IdentityEnhancedBreakdownAddressBreakdownCreditAgencies {
    'result'?: string;
    'properties'?: IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties;
}
export interface IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties {
    'number_of_matches'?: string;
}
/**
 * Address match against telephone database.
 */
export interface IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase {
    'result'?: string;
    'properties'?: object;
}
/**
 * Address match against voting register.
 */
export interface IdentityEnhancedBreakdownAddressBreakdownVotingRegister {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts if the applicant\'s date of birth matches any sources.
 */
export interface IdentityEnhancedBreakdownDateOfBirth {
    'result'?: string;
    'breakdown'?: IdentityEnhancedBreakdownDateOfBirthBreakdown;
}
export interface IdentityEnhancedBreakdownDateOfBirthBreakdown {
    'credit_agencies'?: IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies;
    'voting_register'?: IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister;
}
/**
 * Date of birth match against credit agencies.
 */
export interface IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies {
    'result'?: string;
    'properties'?: object;
}
/**
 * Date of birth match against voting register.
 */
export interface IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister {
    'result'?: string;
    'properties'?: object;
}
/**
 * Asserts if the applicant\'s details match any death records.
 */
export interface IdentityEnhancedBreakdownMortality {
    'result'?: string;
}
/**
 * Asserts if any sources that an applicant\'s details have been verified against have produced a match.
 */
export interface IdentityEnhancedBreakdownSources {
    'result'?: string;
    'breakdown'?: IdentityEnhancedBreakdownSourcesBreakdown;
}
export interface IdentityEnhancedBreakdownSourcesBreakdown {
    'total_sources'?: IdentityEnhancedBreakdownSourcesBreakdownTotalSources;
}
/**
 * The number of sources which produced a match to applicant details.
 */
export interface IdentityEnhancedBreakdownSourcesBreakdownTotalSources {
    'result'?: string;
    'properties'?: IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties;
}
export interface IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties {
    'total_number_of_sources'?: string;
}
export interface IdentityEnhancedProperties {
    /**
     * Returns address number which has been matched.
     */
    'matched_address'?: number;
    /**
     * Returns array of sources which contain matched addresses for the corresponding address number.
     */
    'matched_addresses'?: Array<IdentityEnhancedPropertiesMatchedAddressesInner>;
}
export interface IdentityEnhancedPropertiesMatchedAddressesInner {
    /**
     * The address number.
     */
    'id'?: number;
    /**
     * Sources which contain matched addresses.
     */
    'match_types'?: Array<string>;
}
export interface IdentityEnhancedReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: IdentityEnhancedBreakdown;
    'properties'?: IdentityEnhancedProperties;
}


export interface IdrSsnBreakdown {
    'result'?: string;
    'breakdown'?: IdrSsnBreakdownBreakdown;
}
export interface IdrSsnBreakdownBreakdown {
    'last_4_digits_match'?: IdrSsnBreakdownBreakdownLast4DigitsMatch;
    'full_match'?: IdrSsnBreakdownBreakdownFullMatch;
}
/**
 * Social security number fully matches
 */
export interface IdrSsnBreakdownBreakdownFullMatch {
    'result'?: string;
    'properties'?: object;
}
/**
 * Last 4 digits of social security number match
 */
export interface IdrSsnBreakdownBreakdownLast4DigitsMatch {
    'result'?: string;
    'properties'?: object;
}
export interface IndiaPanReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: IndiaPanReportAllOfBreakdown;
    'properties'?: IndiaPanReportAllOfProperties;
}


export interface IndiaPanReportAllOfBreakdown {
    'device'?: IndiaPanReportAllOfBreakdownDevice;
}
export interface IndiaPanReportAllOfBreakdownDevice {
    'breakdown'?: IndiaPanReportAllOfBreakdownDeviceBreakdown;
}
export interface IndiaPanReportAllOfBreakdownDeviceBreakdown {
    'pan_valid'?: IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid;
    'name_match'?: IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid;
}
export interface IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid {
    'result'?: string;
}
export interface IndiaPanReportAllOfProperties {
    'device'?: IndiaPanReportAllOfPropertiesDevice;
}
export interface IndiaPanReportAllOfPropertiesDevice {
    /**
     * The applicant\'s PAN (10 digit alphanumeric number).
     */
    'pan'?: string;
    /**
     * The applicant\'s full name.
     */
    'full_name'?: string;
}
export interface KnownFacesBreakdown {
    'previously_seen_faces'?: KnownFacesBreakdownPreviouslySeenFaces;
    'image_integrity'?: KnownFacesBreakdownImageIntegrity;
}
/**
 * Asserts whether the uploaded live photo or live video and the content contained within it were of sufficient quality to perform a face comparison.
 */
export interface KnownFacesBreakdownImageIntegrity {
    'result'?: string;
}
/**
 * Asserts whether the applicant\'s most recent facial media (live photo or live video) matches any other live photos or live videos already in your Onfido account database.
 */
export interface KnownFacesBreakdownPreviouslySeenFaces {
    'result'?: string;
}
export interface KnownFacesProperties {
    /**
     * Returns any matching applicant IDs as entries inside a matches array under a properties bag.
     */
    'matches'?: Array<KnownFacesPropertiesMatchesInner>;
}
export interface KnownFacesPropertiesMatchesInner {
    /**
     * The applicant ID of the matched applicant.
     */
    'applicant_id'?: string;
    /**
     * A floating point number between 0 and 1 that expresses how similar the two faces are, where 1 is a perfect match.
     */
    'score'?: number;
    /**
     * The corresponding UUID for the media type.
     */
    'media_id'?: string;
    /**
     * The media type (for example live_photos or live_videos).
     */
    'media_type'?: string;
    /**
     * Indicates if match is suspected based on fuzzy name matching feature. Dependent on feature being active for account, otherwise defaults to true.
     */
    'suspected'?: boolean;
}
export interface KnownFacesReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: KnownFacesBreakdown;
    'properties'?: KnownFacesProperties;
}


export interface LivePhoto {
    /**
     * The unique identifier for the photo.
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     */
    'file_size'?: number;
}
export interface LivePhotoResponse {
    /**
     * The unique identifier for the photo.
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     */
    'file_size'?: number;
}
export interface LivePhotosList {
    'live_photos': Array<LivePhoto>;
}
export interface LiveVideo {
    /**
     * The unique identifier for the video.
     */
    'id'?: string;
    /**
     * The date and time at which the video was uploaded.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    /**
     * The uri that can be used to download the video.
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes.
     */
    'file_size'?: number;
    /**
     * The file type of the uploaded file.
     */
    'file_type'?: string;
    /**
     * Challenge the end user was asked to perform during the video recording.
     */
    'challenge'?: Array<{ [key: string]: any; }>;
}
export interface LiveVideosList {
    'live_videos': Array<LiveVideo>;
}
export interface Location {
    /**
     * The applicant\'s ip address.
     */
    'ip_address'?: string;
    /**
     * The applicant\'s country of residence in 3-letter ISO code.
     */
    'country_of_residence'?: CountryCodes;
}


export interface LocationBuilder {
    /**
     * The applicant\'s ip address.
     */
    'ip_address'?: string;
    /**
     * The applicant\'s country of residence in 3-letter ISO code.
     */
    'country_of_residence'?: CountryCodes;
}


export interface LocationShared {
    /**
     * The applicant\'s ip address.
     */
    'ip_address'?: string;
    /**
     * The applicant\'s country of residence in 3-letter ISO code.
     */
    'country_of_residence'?: CountryCodes;
}


export interface ModelError {
    'error'?: ErrorProperties;
}
export interface MotionCapture {
    /**
     * The unique identifier for the motion capture.
     */
    'id'?: string;
    /**
     * The date and time at which the motion capture was uploaded.
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     */
    'href'?: string;
    /**
     * The uri that can be used to download the motion capture.
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes.
     */
    'file_size'?: number;
    /**
     * The file type of the uploaded file.
     */
    'file_type'?: string;
}
export interface MotionCapturesList {
    'motion_captures': Array<MotionCapture>;
}
export interface Passkey {
    /**
     * Passkey identifier.
     */
    'id': string;
    /**
     * domain that the passkey is registered to, the rpId.
     */
    'application_domain': string;
    /**
     * Current passkey state.
     */
    'state': PasskeyStateEnum;
    /**
     * Timestamp when the passkey was created.
     */
    'created_at': string;
    /**
     * Timestamp when the passkey was last used.
     */
    'last_used_at'?: string;
}

export const PasskeyStateEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PasskeyStateEnum = typeof PasskeyStateEnum[keyof typeof PasskeyStateEnum];

export interface PasskeyUpdater {
    /**
     * Desired passkey state value.
     */
    'state': PasskeyUpdaterStateEnum;
}

export const PasskeyUpdaterStateEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type PasskeyUpdaterStateEnum = typeof PasskeyUpdaterStateEnum[keyof typeof PasskeyUpdaterStateEnum];

export interface PasskeysList {
    'passkeys': Array<Passkey>;
}
export interface PhotoAutoReasons {
    /**
     * Flags when evidence is found that the image was manipulated by Photoshop, or other software.
     */
    'digital_tampering'?: string;
    /**
     * Flags when evidence is found that a fake webcam was used.
     */
    'fake_webcam'?: string;
    /**
     * Flags when evidence is found that the live photo was taken more than 24 hours before live photo upload.
     */
    'time_of_capture'?: string;
    /**
     * Flags when evidence is found that an Android emulator was used.
     */
    'emulator'?: string;
    /**
     * Additional comma separated details such as the exact digital tampering software used, or the name of the fake webcam.
     */
    'reasons'?: string;
}
export interface PhotoReasons {
    /**
     * Flags when evidence is found that the image was manipulated by Photoshop, or other software.
     */
    'digital_tampering'?: string;
    /**
     * Flags when evidence is found that a fake webcam was used.
     */
    'fake_webcam'?: string;
    /**
     * Flags when evidence is found that the live photo was taken more than 24 hours before live photo upload.
     */
    'time_of_capture'?: string;
    /**
     * Flags when evidence is found that an Android emulator was used.
     */
    'emulator'?: string;
    /**
     * Additional comma separated details such as the exact digital tampering software used, or the name of the fake webcam.
     */
    'reasons'?: string;
}
export interface ProofOfAddressBreakdown {
    'data_comparison'?: ProofOfAddressBreakdownDataComparison;
    'document_classification'?: ProofOfAddressBreakdownDocumentClassification;
    'image_integrity'?: ProofOfAddressBreakdownImageIntegrity;
}
/**
 * Asserts whether the first name, last name and address provided by the applicant match those on the PoA document.
 */
export interface ProofOfAddressBreakdownDataComparison {
    'result'?: string;
    'breakdown'?: ProofOfAddressBreakdownDataComparisonBreakdown;
}
export interface ProofOfAddressBreakdownDataComparisonBreakdown {
    'address'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the document is of a valid type as PoA.
 */
export interface ProofOfAddressBreakdownDocumentClassification {
    'result'?: string;
    'breakdown'?: ProofOfAddressBreakdownDocumentClassificationBreakdown;
}
export interface ProofOfAddressBreakdownDocumentClassificationBreakdown {
    'supported_document'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the quality of the uploaded document was sufficient to verify the address.
 */
export interface ProofOfAddressBreakdownImageIntegrity {
    'result'?: string;
    'breakdown'?: ProofOfAddressBreakdownImageIntegrityBreakdown;
}
export interface ProofOfAddressBreakdownImageIntegrityBreakdown {
    'image_quality'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
export interface ProofOfAddressProperties {
    /**
     * This property provides the address on the document.
     */
    'address'?: string;
    /**
     * This property provides the document type according to the set of supported documents.
     */
    'document_type'?: ProofOfAddressPropertiesDocumentTypeEnum;
    /**
     * This property provides the first names on the document, including any initials and middle names.
     */
    'first_names'?: string;
    /**
     * This property provided the last names on the document.
     */
    'last_names'?: string;
    /**
     * This property provides the issue date of the document.
     */
    'issue_date'?: string;
    /**
     * This property provides the document issuer (e.g. HSBC, British Gas).
     */
    'issuer'?: string;
    /**
     * This property provides the summary period start date.
     */
    'summary_period_start'?: string;
    /**
     * This property provides the summary period end date.
     */
    'summary_period_end'?: string;
}

export const ProofOfAddressPropertiesDocumentTypeEnum = {
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    UtilityBill: 'utility_bill',
    CouncilTax: 'council_tax',
    BenefitLetters: 'benefit_letters',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    AccommodationTenancyCertificate: 'accommodation_tenancy_certificate',
    AddressCertificate: 'address_certificate',
    ElectricityBill: 'electricity_bill',
    GasBill: 'gas_bill',
    InternetBill: 'internet_bill',
    PhoneBill: 'phone_bill',
    WaterBill: 'water_bill',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ProofOfAddressPropertiesDocumentTypeEnum = typeof ProofOfAddressPropertiesDocumentTypeEnum[keyof typeof ProofOfAddressPropertiesDocumentTypeEnum];

export interface ProofOfAddressReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: ProofOfAddressBreakdown;
    'properties'?: ProofOfAddressProperties;
}


export interface RepeatAttemptsList {
    /**
     * The unique identifier of the completed Document report.
     */
    'report_id'?: string;
    /**
     * An array of repeat attempt objects. If no repeat attempts were found, the array will be empty. The number of objects returned can increase over time if more matches are received. 
     */
    'repeat_attempts': Array<RepeatAttemptsListRepeatAttemptsInner>;
    /**
     * The total number of attempts using the same document, including the current report under assessment.
     */
    'attempts_count'?: number;
    /**
     * A number between 0 and 1 which indicates the proportion of attempts that have been cleared, including the current report under assessment.
     */
    'attempts_clear_rate'?: number;
    /**
     * The number of unique entries in the repeat_attempts field for which at least one of the fields is a mismatch.
     */
    'unique_mismatches_count'?: number;
}
export interface RepeatAttemptsListRepeatAttemptsInner {
    /**
     * The unique identifier of the matching Document report.
     */
    'report_id'?: string;
    /**
     * The unique identifier of the applicant for the matching Document report.
     */
    'applicant_id'?: string;
    /**
     * Whether the dates of birth are exactly the same or are different.
     */
    'date_of_birth'?: RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum;
    /**
     * Whether the names are exactly the same or are different.
     */
    'names'?: RepeatAttemptsListRepeatAttemptsInnerNamesEnum;
    /**
     * The report result of this attempt.
     */
    'result'?: RepeatAttemptsListRepeatAttemptsInnerResultEnum;
    /**
     * When the matching report was created.
     */
    'created_at'?: string;
    /**
     * When the matching report was completed.
     */
    'completed_at'?: string;
}

export const RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = typeof RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum[keyof typeof RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum];
export const RepeatAttemptsListRepeatAttemptsInnerNamesEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RepeatAttemptsListRepeatAttemptsInnerNamesEnum = typeof RepeatAttemptsListRepeatAttemptsInnerNamesEnum[keyof typeof RepeatAttemptsListRepeatAttemptsInnerNamesEnum];
export const RepeatAttemptsListRepeatAttemptsInnerResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RepeatAttemptsListRepeatAttemptsInnerResultEnum = typeof RepeatAttemptsListRepeatAttemptsInnerResultEnum[keyof typeof RepeatAttemptsListRepeatAttemptsInnerResultEnum];

/**
 * @type Report
 */
export type Report = { name: 'device_intelligence' } & DeviceIntelligenceReport | { name: 'document' } & DocumentReport | { name: 'document_video' } & DocumentVideoReport | { name: 'document_video_with_address_information' } & DocumentVideoWithAddressInformationReport | { name: 'document_with_address_information' } & DocumentWithAddressInformationReport | { name: 'document_with_driver_verification' } & DocumentWithDriverVerificationReport | { name: 'document_with_driving_licence_information' } & DocumentWithDrivingLicenceInformationReport | { name: 'facial_similarity_motion' } & FacialSimilarityMotionReport | { name: 'facial_similarity_photo' } & FacialSimilarityPhotoReport | { name: 'facial_similarity_photo_fully_auto' } & FacialSimilarityPhotoFullyAutoReport | { name: 'facial_similarity_video' } & FacialSimilarityVideoReport | { name: 'identity_enhanced' } & IdentityEnhancedReport | { name: 'india_pan' } & IndiaPanReport | { name: 'known_faces' } & KnownFacesReport | { name: 'proof_of_address' } & ProofOfAddressReport | { name: 'us_driving_licence' } & UsDrivingLicenceReport | { name: 'watchlist_aml' } & WatchlistAmlReport | { name: 'watchlist_enhanced' } & WatchlistEnhancedReport | { name: 'watchlist_peps_only' } & WatchlistPepsOnlyReport | { name: 'watchlist_sanctions_only' } & WatchlistSanctionsOnlyReport | { name: 'watchlist_standard' } & WatchlistStandardReport;

/**
 * Defines configuration options for facial similarity checks used to distinguish between onboarding and reverification scenarios. 
 */
export interface ReportConfiguration {
    'facial_similarity_photo'?: ReportConfigurationFacialSimilarity;
    'facial_similarity_photo_fully_auto'?: ReportConfigurationFacialSimilarity;
    'facial_similarity_video'?: ReportConfigurationFacialSimilarity;
    'facial_similarity_motion'?: ReportConfigurationFacialSimilarity;
}
export interface ReportConfigurationFacialSimilarity {
    /**
     * You should set it to \"reverification\" on a post-onboarding scenario (e.g. ongoing authentication). 
     */
    'use_case'?: ReportConfigurationFacialSimilarityUseCaseEnum;
}

export const ReportConfigurationFacialSimilarityUseCaseEnum = {
    Onboarding: 'onboarding',
    Reverification: 'reverification',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportConfigurationFacialSimilarityUseCaseEnum = typeof ReportConfigurationFacialSimilarityUseCaseEnum[keyof typeof ReportConfigurationFacialSimilarityUseCaseEnum];

export interface ReportDocument {
    /**
     * ID of uploaded document to use.
     */
    'id': string;
}

export const ReportName = {
    Document: 'document',
    DocumentVideo: 'document_video',
    DocumentVideoWithAddressInformation: 'document_video_with_address_information',
    DocumentWithAddressInformation: 'document_with_address_information',
    DocumentWithDrivingLicenceInformation: 'document_with_driving_licence_information',
    DocumentWithDriverVerification: 'document_with_driver_verification',
    FacialSimilarityPhoto: 'facial_similarity_photo',
    FacialSimilarityPhotoFullyAuto: 'facial_similarity_photo_fully_auto',
    FacialSimilarityVideo: 'facial_similarity_video',
    FacialSimilarityMotion: 'facial_similarity_motion',
    KnownFaces: 'known_faces',
    IdentityEnhanced: 'identity_enhanced',
    WatchlistAml: 'watchlist_aml',
    WatchlistEnhanced: 'watchlist_enhanced',
    WatchlistStandard: 'watchlist_standard',
    WatchlistPepsOnly: 'watchlist_peps_only',
    WatchlistSanctionsOnly: 'watchlist_sanctions_only',
    ProofOfAddress: 'proof_of_address',
    UsDrivingLicence: 'us_driving_licence',
    DeviceIntelligence: 'device_intelligence',
    IndiaPan: 'india_pan',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportName = typeof ReportName[keyof typeof ReportName];


/**
 * The result of the report. Read-only.
 */

export const ReportResult = {
    Clear: 'clear',
    Consider: 'consider',
    Unidentified: 'unidentified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportResult = typeof ReportResult[keyof typeof ReportResult];


export interface ReportShared {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
}


/**
 * The current state of the report in the checking process. Read-only.
 */

export const ReportStatus = {
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Cancelled: 'cancelled',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportStatus = typeof ReportStatus[keyof typeof ReportStatus];


/**
 * The sub_result of the report. It gives a more detailed result for document reports only, and will be null otherwise. Read-only.
 */

export const ReportSubResult = {
    Clear: 'clear',
    Rejected: 'rejected',
    Suspected: 'suspected',
    Caution: 'caution',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportSubResult = typeof ReportSubResult[keyof typeof ReportSubResult];


export interface ReportsList {
    'reports': Array<Report>;
}
export interface ResultsFeedback {
    /**
     * The expected result for the check or report.
     */
    'expected_result'?: ResultsFeedbackExpectedResultEnum;
    /**
     * The ID of the check (only if report_id is not provided).
     */
    'check_id'?: string;
    /**
     * The ID of the check (only if check_id is not provided).
     */
    'report_id'?: string;
    /**
     * Any additional information or feedback.
     */
    'feedback_notes'?: string;
}

export const ResultsFeedbackExpectedResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ResultsFeedbackExpectedResultEnum = typeof ResultsFeedbackExpectedResultEnum[keyof typeof ResultsFeedbackExpectedResultEnum];

export interface SdkToken {
    /**
     * The generated SDK token
     */
    'token': string;
}
export interface SdkTokenBuilder {
    /**
     * The unique identifier of the applicant
     */
    'applicant_id': string;
    /**
     * The referrer URL pattern
     */
    'referrer'?: string;
    /**
     * The application ID (iOS or Android)
     */
    'application_id'?: string;
    /**
     * The URL to be used by the Web SDK for the cross device flow.
     */
    'cross_device_url'?: string;
}
export interface SdkTokenRequest {
    /**
     * The unique identifier of the applicant
     */
    'applicant_id': string;
    /**
     * The referrer URL pattern
     */
    'referrer'?: string;
    /**
     * The application ID (iOS or Android)
     */
    'application_id'?: string;
    /**
     * The URL to be used by the Web SDK for the cross device flow.
     */
    'cross_device_url'?: string;
}
export interface SdkTokenResponse {
    /**
     * The generated SDK token
     */
    'token': string;
}
export interface SigningDocument {
    /**
     * The ID of the applicant whose signing document is being uploaded.
     */
    'applicant_id'?: string;
    /**
     * The unique identifier for the signing document
     */
    'id': string;
    /**
     * The date and time at which the signing document was uploaded
     */
    'created_at'?: string;
    /**
     * The uri of this resource
     */
    'href'?: string;
    /**
     * The uri that can be used to download the signing document
     */
    'download_href'?: string;
    /**
     * The file type of the uploaded file
     */
    'file_type'?: string;
    /**
     * The name of the uploaded file
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     */
    'file_size'?: number;
}
export interface SigningDocumentResponse {
    /**
     * The unique identifier for the signing document
     */
    'id': string;
    /**
     * The date and time at which the signing document was uploaded
     */
    'created_at'?: string;
    /**
     * The uri of this resource
     */
    'href'?: string;
    /**
     * The uri that can be used to download the signing document
     */
    'download_href'?: string;
    /**
     * The file type of the uploaded file
     */
    'file_type'?: string;
    /**
     * The name of the uploaded file
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     */
    'file_size'?: number;
}
export interface SigningDocumentShared {
    /**
     * The ID of the applicant whose signing document is being uploaded.
     */
    'applicant_id'?: string;
}
export interface SigningDocumentsList {
    'signing_documents': Array<SigningDocument>;
}
export interface Task {
    /**
     * The identifier for the Task.
     */
    'id'?: string;
    /**
     * The workflow run id the task belongs to.
     */
    'workflow_run_id'?: string;
    /**
     * The identifier for the Task Definition.
     */
    'task_def_id'?: string;
    /**
     * The task definition version.
     */
    'task_def_version'?: string | null;
    /**
     * Input object with the fields used by the Task to execute.
     */
    'input'?: object;
    /**
     * Value field (it can be an Object, List, etc.) with the fields produced by the Task execution.
     */
    'output'?: object | null;
    /**
     * The date and time when the Task was created.
     */
    'created_at'?: string;
    /**
     * The date and time when the Task was last updated.
     */
    'updated_at'?: string;
}
export interface TaskItem {
    /**
     * The identifier for the Task.
     */
    'id'?: string;
    /**
     * The workflow run id the task belongs to.
     */
    'workflow_run_id'?: string;
    /**
     * The identifier for the Task Definition.
     */
    'task_def_id'?: string;
    /**
     * The task definition version.
     */
    'task_def_version'?: string | null;
    /**
     * The date and time when the Task was created.
     */
    'created_at'?: string;
    /**
     * The date and time when the Task was last updated.
     */
    'updated_at'?: string;
}
export interface TimelineFileReference {
    /**
     * The unique identifier for the Timefile File that will be created.
     */
    'workflow_timeline_file_id': string;
    /**
     * Link to access the Timefile File that will be created.
     */
    'href': string;
}
export interface UsDrivingLicenceBreakdown {
    'document'?: UsDrivingLicenceBreakdownDocument;
    'address'?: UsDrivingLicenceBreakdownAddress;
    'personal'?: UsDrivingLicenceBreakdownPersonal;
}
/**
 * Asserts whether the address data provided matches a real driving license in the DMV driver\'s license database.
 */
export interface UsDrivingLicenceBreakdownAddress {
    'result'?: string;
    'breakdown'?: UsDrivingLicenceBreakdownAddressBreakdown;
}
export interface UsDrivingLicenceBreakdownAddressBreakdown {
    'city'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'line_1'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'line_2'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'state_code'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'zip4'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'zip5'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the document data provided matches a real driving license in the DMV driver\'s license database.
 */
export interface UsDrivingLicenceBreakdownDocument {
    'result'?: string;
    'breakdown'?: UsDrivingLicenceBreakdownDocumentBreakdown;
}
export interface UsDrivingLicenceBreakdownDocumentBreakdown {
    'category'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'expiration_date'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'issue_date'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'document_number'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the personal data provided matches a real driving license in the DMV driver\'s license database.
 */
export interface UsDrivingLicenceBreakdownPersonal {
    'result'?: string;
    'breakdown'?: UsDrivingLicenceBreakdownPersonalBreakdown;
}
export interface UsDrivingLicenceBreakdownPersonalBreakdown {
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'name_suffix'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'height'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'weight'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'sex_code'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'eye_color'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'middle_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'first_name_fuzzy'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'middle_name_fuzzy'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'last_name_fuzzy'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    'middle_initial'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
export interface UsDrivingLicenceBuilder {
    /**
     * Driving licence ID number
     */
    'id_number': string;
    /**
     * Two letter code of issuing state (state-issued driving licenses only)
     */
    'issue_state': string;
    /**
     * Line 1 of the address
     */
    'address_line_1'?: string;
    /**
     * Line 2 of the address
     */
    'address_line_2'?: string;
    /**
     * The city of the owner\'s address
     */
    'city'?: string;
    /**
     * Date of birth in yyyy-mm-dd format
     */
    'date_of_birth'?: string;
    /**
     * Document category.
     */
    'document_category'?: UsDrivingLicenceBuilderDocumentCategoryEnum;
    /**
     * Expiration date of the driving licence in yyyy-mm-dd format
     */
    'expiration_date'?: string;
    /**
     * Eye color code.
     */
    'eye_color_code'?: UsDrivingLicenceBuilderEyeColorCodeEnum;
    /**
     * The owner\'s first name
     */
    'first_name'?: string;
    'gender'?: UsDrivingLicenceBuilderGenderEnum;
    /**
     * Issue date in yyyy-mm-dd format
     */
    'issue_date'?: string;
    /**
     * The owner\'s surname
     */
    'last_name'?: string;
    /**
     * The owner\'s middle name
     */
    'middle_name'?: string;
    /**
     * The owner\'s name suffix
     */
    'name_suffix'?: string;
    /**
     * The postcode or ZIP of the owner\'s address
     */
    'postal_code'?: string;
    /**
     * 2-characters state code
     */
    'state'?: string;
    /**
     * Weight in pounds
     */
    'weight_measure'?: number;
}

export const UsDrivingLicenceBuilderDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceBuilderDocumentCategoryEnum = typeof UsDrivingLicenceBuilderDocumentCategoryEnum[keyof typeof UsDrivingLicenceBuilderDocumentCategoryEnum];
export const UsDrivingLicenceBuilderEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceBuilderEyeColorCodeEnum = typeof UsDrivingLicenceBuilderEyeColorCodeEnum[keyof typeof UsDrivingLicenceBuilderEyeColorCodeEnum];
export const UsDrivingLicenceBuilderGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceBuilderGenderEnum = typeof UsDrivingLicenceBuilderGenderEnum[keyof typeof UsDrivingLicenceBuilderGenderEnum];

export interface UsDrivingLicenceReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: UsDrivingLicenceBreakdown;
    'properties'?: DocumentProperties;
}


/**
 * An object that contains all accepted fields for the Driver\'s License Data Verification report.
 */
export interface UsDrivingLicenceShared {
    /**
     * Driving licence ID number
     */
    'id_number': string;
    /**
     * Two letter code of issuing state (state-issued driving licenses only)
     */
    'issue_state': string;
    /**
     * Line 1 of the address
     */
    'address_line_1'?: string;
    /**
     * Line 2 of the address
     */
    'address_line_2'?: string;
    /**
     * The city of the owner\'s address
     */
    'city'?: string;
    /**
     * Date of birth in yyyy-mm-dd format
     */
    'date_of_birth'?: string;
    /**
     * Document category.
     */
    'document_category'?: UsDrivingLicenceSharedDocumentCategoryEnum;
    /**
     * Expiration date of the driving licence in yyyy-mm-dd format
     */
    'expiration_date'?: string;
    /**
     * Eye color code.
     */
    'eye_color_code'?: UsDrivingLicenceSharedEyeColorCodeEnum;
    /**
     * The owner\'s first name
     */
    'first_name'?: string;
    'gender'?: UsDrivingLicenceSharedGenderEnum;
    /**
     * Issue date in yyyy-mm-dd format
     */
    'issue_date'?: string;
    /**
     * The owner\'s surname
     */
    'last_name'?: string;
    /**
     * The owner\'s middle name
     */
    'middle_name'?: string;
    /**
     * The owner\'s name suffix
     */
    'name_suffix'?: string;
    /**
     * The postcode or ZIP of the owner\'s address
     */
    'postal_code'?: string;
    /**
     * 2-characters state code
     */
    'state'?: string;
    /**
     * Weight in pounds
     */
    'weight_measure'?: number;
}

export const UsDrivingLicenceSharedDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceSharedDocumentCategoryEnum = typeof UsDrivingLicenceSharedDocumentCategoryEnum[keyof typeof UsDrivingLicenceSharedDocumentCategoryEnum];
export const UsDrivingLicenceSharedEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceSharedEyeColorCodeEnum = typeof UsDrivingLicenceSharedEyeColorCodeEnum[keyof typeof UsDrivingLicenceSharedEyeColorCodeEnum];
export const UsDrivingLicenceSharedGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceSharedGenderEnum = typeof UsDrivingLicenceSharedGenderEnum[keyof typeof UsDrivingLicenceSharedGenderEnum];

export interface VideoReasons {
    /**
     * Flags when evidence is found that a fake webcam was used.
     */
    'fake_webcam'?: string;
    /**
     * Flags when evidence is found that the video was uploaded in an attempt to circumvent the randomness of the speaking and head turn challenges
     */
    'challenge_reuse'?: string;
    /**
     * Flags when evidence is found that an Android emulator was used.
     */
    'emulator'?: string;
    /**
     * Additional comma separated details such as the name of the fake webcam.
     */
    'reasons'?: string;
}
export interface WatchlistAmlBreakdown {
    'sanction'?: WatchlistAmlBreakdownSanction;
    'politically_exposed_person'?: WatchlistAmlBreakdownPoliticallyExposedPerson;
    'legal_and_regulatory_warnings'?: WatchlistAmlBreakdownLegalAndRegulatoryWarnings;
    'adverse_media'?: WatchlistAmlBreakdownAdverseMedia;
}
/**
 * Asserts if there are any records found of negative events reported by publicly and generally available media sources.
 */
export interface WatchlistAmlBreakdownAdverseMedia {
    'result'?: string;
}
/**
 * Asserts if there are any records found in Law-Enforcement and Regulatory bodies Monitored Lists (including Terrorism, Money Laundering and Most Wanted lists).
 */
export interface WatchlistAmlBreakdownLegalAndRegulatoryWarnings {
    'result'?: string;
}
/**
 * Asserts if there are any records found in the proprietary database of Politically Exposed Persons sourced from government lists, websites and other media sources.
 */
export interface WatchlistAmlBreakdownPoliticallyExposedPerson {
    'result'?: string;
}
/**
 * Asserts if there are any records found in Government and International Organisations Sanctions Lists.
 */
export interface WatchlistAmlBreakdownSanction {
    'result'?: string;
}
export interface WatchlistAmlProperties {
    /**
     * Returns any matches including, but not limited to, name and date of birth of match, aliases and associates, and relevant events and sources.
     * @deprecated
     */
    'records'?: Array<object>;
}
export interface WatchlistAmlReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: WatchlistAmlBreakdown;
    'properties'?: WatchlistAmlProperties;
}


export interface WatchlistEnhancedBreakdown {
    'politically_exposed_person'?: WatchlistAmlBreakdownPoliticallyExposedPerson;
    'sanction'?: WatchlistAmlBreakdownSanction;
    'adverse_media'?: WatchlistAmlBreakdownAdverseMedia;
    'monitored_lists'?: WatchlistAmlBreakdownLegalAndRegulatoryWarnings;
}
export interface WatchlistEnhancedProperties {
    /**
     * Returns any matches including, but not limited to, name and date of birth of match, aliases and associates, and relevant events and sources.
     */
    'records'?: Array<WatchlistEnhancedPropertiesRecordsInner>;
}
export interface WatchlistEnhancedPropertiesRecordsInner {
    /**
     * All addresses on file.
     */
    'address'?: Array<WatchlistEnhancedPropertiesRecordsInnerAddressInner>;
    /**
     * Any names that the person is also known as.
     */
    'alias'?: Array<WatchlistEnhancedPropertiesRecordsInnerAliasInner>;
    /**
     * Any linked persons, for example family relatives or business partners.
     */
    'associate'?: Array<WatchlistEnhancedPropertiesRecordsInnerAssociateInner>;
    /**
     * Information about the person, for example hair color or nationality.
     */
    'attribute'?: Array<WatchlistEnhancedPropertiesRecordsInnerAttributeInner>;
    /**
     * All the date of births on file.
     */
    'date_of_birth'?: Array<string>;
    /**
     * Information about events that have occurred to the person, for example deportation or arrest.
     */
    'event'?: Array<WatchlistEnhancedPropertiesRecordsInnerEventInner>;
    /**
     * The name on file
     */
    'full_name'?: string;
    /**
     * The role, country and date of each position.
     */
    'position'?: Array<string>;
    /**
     * Details about where the information was obtained.
     */
    'source'?: Array<WatchlistEnhancedPropertiesRecordsInnerSourceInner>;
}
export interface WatchlistEnhancedPropertiesRecordsInnerAddressInner {
    'address_line1'?: string;
    'country'?: CountryCodes;
    'postal_code'?: string;
    'state_province'?: string;
    'town'?: string;
    'locator_type'?: string;
}


export interface WatchlistEnhancedPropertiesRecordsInnerAliasInner {
    'alias_name'?: string;
    'alias_type'?: string;
}
export interface WatchlistEnhancedPropertiesRecordsInnerAssociateInner {
    'entity_name'?: string;
    'relationship_direction'?: string;
    'relationship_type'?: string;
}
export interface WatchlistEnhancedPropertiesRecordsInnerAttributeInner {
    'attribute_type'?: string;
    'attribute_value'?: string;
}
export interface WatchlistEnhancedPropertiesRecordsInnerEventInner {
    'category'?: string;
    'event_date'?: string;
    'event_description'?: string;
    'source'?: WatchlistEnhancedPropertiesRecordsInnerEventInnerSource;
    'sub_category'?: string;
}
export interface WatchlistEnhancedPropertiesRecordsInnerEventInnerSource {
    'source_date'?: string;
    'source_format'?: string;
    'source_name'?: string;
    'source_url'?: string;
}
export interface WatchlistEnhancedPropertiesRecordsInnerSourceInner {
    'source_headline'?: string;
    'source_name'?: string;
    'source_url'?: string;
    'source_format'?: string;
}
export interface WatchlistEnhancedReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: WatchlistEnhancedBreakdown;
    'properties'?: WatchlistEnhancedProperties;
}


export interface WatchlistMonitor {
    /**
     * The ID for the applicant associated with the monitor.
     */
    'applicant_id': string;
    /**
     * The name of the report type the monitor creates.
     */
    'report_name': WatchlistMonitorReportNameEnum;
    /**
     * A list of tags associated with this monitor. These tags will be applied to each check this monitor creates.
     */
    'tags'?: Array<string>;
    /**
     * The unique identifier for the monitor.
     */
    'id': string;
    /**
     * The date and time at which the monitor was created.
     */
    'created_at'?: string;
    /**
     * The date and time at which the monitor was deleted. If the monitor is still active, this field will be null.
     */
    'deleted_at'?: string;
    /**
     * Indicates whether the object was created in the sandbox or not.
     */
    'is_sandbox'?: boolean;
}

export const WatchlistMonitorReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WatchlistMonitorReportNameEnum = typeof WatchlistMonitorReportNameEnum[keyof typeof WatchlistMonitorReportNameEnum];

export interface WatchlistMonitorBuilder {
    /**
     * The ID for the applicant associated with the monitor.
     */
    'applicant_id': string;
    /**
     * The name of the report type the monitor creates.
     */
    'report_name': WatchlistMonitorBuilderReportNameEnum;
    /**
     * A list of tags associated with this monitor. These tags will be applied to each check this monitor creates.
     */
    'tags'?: Array<string>;
}

export const WatchlistMonitorBuilderReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WatchlistMonitorBuilderReportNameEnum = typeof WatchlistMonitorBuilderReportNameEnum[keyof typeof WatchlistMonitorBuilderReportNameEnum];

export interface WatchlistMonitorMatch {
    /**
     * Monitor ID
     */
    'id'?: string;
    /**
     * Monitor status
     */
    'enabled'?: boolean;
}
export interface WatchlistMonitorMatchesList {
    'matches': Array<WatchlistMonitorMatch>;
}
export interface WatchlistMonitorMatchesUpdater {
    'enable'?: Array<string>;
    'disable'?: Array<string>;
}
export interface WatchlistMonitorResponse {
    /**
     * The unique identifier for the monitor.
     */
    'id': string;
    /**
     * The date and time at which the monitor was created.
     */
    'created_at'?: string;
    /**
     * The date and time at which the monitor was deleted. If the monitor is still active, this field will be null.
     */
    'deleted_at'?: string;
    /**
     * Indicates whether the object was created in the sandbox or not.
     */
    'is_sandbox'?: boolean;
}
export interface WatchlistMonitorShared {
    /**
     * The ID for the applicant associated with the monitor.
     */
    'applicant_id': string;
    /**
     * The name of the report type the monitor creates.
     */
    'report_name': WatchlistMonitorSharedReportNameEnum;
    /**
     * A list of tags associated with this monitor. These tags will be applied to each check this monitor creates.
     */
    'tags'?: Array<string>;
}

export const WatchlistMonitorSharedReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WatchlistMonitorSharedReportNameEnum = typeof WatchlistMonitorSharedReportNameEnum[keyof typeof WatchlistMonitorSharedReportNameEnum];

export interface WatchlistMonitorsList {
    'monitors': Array<WatchlistMonitor>;
}
export interface WatchlistPepsOnlyReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: WatchlistStandardBreakdown;
    'properties'?: WatchlistStandardProperties;
}


export interface WatchlistSanctionsOnlyReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: WatchlistStandardBreakdown;
    'properties'?: WatchlistStandardProperties;
}


export interface WatchlistStandardBreakdown {
    'sanction'?: WatchlistAmlBreakdownSanction;
    'politically_exposed_person'?: WatchlistAmlBreakdownPoliticallyExposedPerson;
    'legal_and_regulatory_warnings'?: WatchlistAmlBreakdownLegalAndRegulatoryWarnings;
}
export interface WatchlistStandardProperties {
    /**
     * Returns any matches including, but not limited to, name and date of birth of match, aliases and associates, and relevant events and sources.
     * @deprecated
     */
    'records'?: Array<object>;
}
export interface WatchlistStandardReport {
    /**
     * The unique identifier for the report. Read-only.
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     */
    'href'?: string;
    'status'?: ReportStatus;
    'result'?: ReportResult;
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     */
    'check_id'?: string;
    'name': ReportName;
    'breakdown'?: WatchlistStandardBreakdown;
    'properties'?: WatchlistStandardProperties;
}


export interface Webhook {
    /**
     * Determine if the webhook is active.
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are sandbox and live. If the environments parameter is omitted the webhook will receive events from both environments. 
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     */
    'payload_version'?: number;
    /**
     * Determines if the webhook will fetch OAuth access tokens to send in the Authorization header.
     */
    'oauth_enabled'?: boolean;
    /**
     * The url to fetch the OAuth access token using client credentials grant.
     */
    'oauth_server_url'?: string;
    /**
     * The client id to authenticate the client credentials grant.
     */
    'oauth_server_client_id'?: string;
    /**
     * The client secret to authenticate the client credentials grant.
     */
    'oauth_server_client_secret'?: string;
    /**
     * The scopes to be sent when requesting the access token.
     */
    'oauth_server_scope'?: string;
    /**
     * The unique identifier of the webhook.
     */
    'id': string;
    /**
     * The url that will listen to notifications (must be https).
     */
    'url'?: string;
    /**
     * Webhook secret token used to sign the webhook\'s payload.
     */
    'token'?: string;
    /**
     * The API endpoint to retrieve the webhook.
     */
    'href'?: string;
}
export interface WebhookBuilder {
    /**
     * Determine if the webhook is active.
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are sandbox and live. If the environments parameter is omitted the webhook will receive events from both environments. 
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     */
    'payload_version'?: number;
    /**
     * Determines if the webhook will fetch OAuth access tokens to send in the Authorization header.
     */
    'oauth_enabled'?: boolean;
    /**
     * The url to fetch the OAuth access token using client credentials grant.
     */
    'oauth_server_url'?: string;
    /**
     * The client id to authenticate the client credentials grant.
     */
    'oauth_server_client_id'?: string;
    /**
     * The client secret to authenticate the client credentials grant.
     */
    'oauth_server_client_secret'?: string;
    /**
     * The scopes to be sent when requesting the access token.
     */
    'oauth_server_scope'?: string;
    /**
     * The url that will listen to notifications (must be https).
     */
    'url': string;
}
export interface WebhookCreate {
    /**
     * The url that will listen to notifications (must be https).
     */
    'url': string;
}
export interface WebhookEvent {
    'payload'?: WebhookEventPayload;
}
/**
 * The current state of the object, if available.
 */

export const WebhookEventObjectStatus = {
    Processing: 'processing',
    AwaitingInput: 'awaiting_input',
    AwaitingClientInput: 'awaiting_client_input',
    Approved: 'approved',
    Declined: 'declined',
    Review: 'review',
    Abandoned: 'abandoned',
    Error: 'error',
    Started: 'started',
    Cancelled: 'cancelled',
    Completed: 'completed',
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WebhookEventObjectStatus = typeof WebhookEventObjectStatus[keyof typeof WebhookEventObjectStatus];


export interface WebhookEventPayload {
    /**
     * Indicates the resource affected by this event.
     */
    'resource_type': WebhookEventResourceType;
    /**
     * The event that triggered this webhook.
     */
    'action'?: WebhookEventType;
    'object'?: WebhookEventPayloadObject;
    'resource'?: WebhookEventPayloadResource;
}


/**
 * The object affected by this event.
 */
export interface WebhookEventPayloadObject {
    /**
     * The unique identifier of the resource.
     */
    'id': string;
    'status'?: WebhookEventObjectStatus;
    /**
     * The date and time when the operation was started, if available.
     */
    'started_at_iso8601'?: string;
    /**
     * The date and time when the operation was completed, if available.
     */
    'completed_at_iso8601'?: string;
    /**
     * The uri of the resource.
     */
    'href'?: string;
}


/**
 * The resource affected by this event.
 */
export interface WebhookEventPayloadResource {
    /**
     * The identifier of the resource.
     */
    'id'?: string;
    /**
     * The unique identifier for the Applicant.
     */
    'applicant_id'?: string;
    /**
     * The date and time when the resource was created.
     */
    'created_at'?: string;
    /**
     * The date and time when the resource was last updated.
     */
    'updated_at'?: string;
    /**
     * The URL for viewing the resource on Onfido Dashboard.
     */
    'dashboard_url'?: string;
    /**
     * The unique identifier for the Workflow.
     */
    'workflow_id'?: string;
    'workflow_run_id'?: string;
    /**
     * The identifier for the Workflow version.
     */
    'workflow_version_id'?: number;
    /**
     * The identifier for the Task Definition.
     */
    'task_def_id'?: string;
    /**
     * The task definition version.
     */
    'task_def_version'?: string | null;
    /**
     * Input object with the fields used by the Task execution.
     */
    'input'?: object;
    /**
     * Value field (it can be an Object, List, etc.) with the fields produced by the Task execution.
     */
    'output'?: object | null;
    /**
     * The reasons the Workflow Run outcome was reached. Configurable when creating the Workflow Version.
     */
    'reasons'?: Array<string>;
    /**
     * A list of tags associated with the Workflow Run.
     */
    'tags'?: Array<string>;
    /**
     * Object for the configuration of the Workflow Run link.
     */
    'link'?: WorkflowRunLink;
    /**
     * Error object that details why a Workflow Run is in Error status.
     */
    'error'?: WorkflowRunError;
    /**
     * Customer-provided user identifier.
     */
    'customer_user_id'?: string;
    /**
     * Pre-signed URL to download the timeline file for the Workflow Run.
     */
    'timeline_file_download_url'?: string;
}

export const WebhookEventResourceType = {
    Check: 'check',
    Report: 'report',
    AuditLog: 'audit_log',
    WorkflowRun: 'workflow_run',
    WorkflowTask: 'workflow_task',
    WatchlistMonitor: 'watchlist_monitor',
    WorkflowTimelineFile: 'workflow_timeline_file',
    WorkflowRunEvidenceFolder: 'workflow_run_evidence_folder',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WebhookEventResourceType = typeof WebhookEventResourceType[keyof typeof WebhookEventResourceType];



export const WebhookEventType = {
    AuditLogCreated: 'audit_log.created',
    WatchlistMonitorMatchesUpdated: 'watchlist_monitor.matches_updated',
    WorkflowRunCompleted: 'workflow_run.completed',
    WorkflowTaskStarted: 'workflow_task.started',
    WorkflowTaskCompleted: 'workflow_task.completed',
    CheckStarted: 'check.started',
    CheckReopened: 'check.reopened',
    CheckWithdrawn: 'check.withdrawn',
    CheckCompleted: 'check.completed',
    CheckFormCompleted: 'check.form_completed',
    ReportWithdrawn: 'report.withdrawn',
    ReportResumed: 'report.resumed',
    ReportCancelled: 'report.cancelled',
    ReportAwaitingApproval: 'report.awaiting_approval',
    ReportCompleted: 'report.completed',
    WorkflowTimelineFileCreated: 'workflow_timeline_file.created',
    WorkflowRunEvidenceFolderCreated: 'workflow_run_evidence_folder.created',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WebhookEventType = typeof WebhookEventType[keyof typeof WebhookEventType];


export interface WebhookResend {
    'data'?: Array<WebhooksResendItem>;
}
export interface WebhookResponse {
    /**
     * The unique identifier of the webhook.
     */
    'id': string;
    /**
     * The url that will listen to notifications (must be https).
     */
    'url'?: string;
    /**
     * Webhook secret token used to sign the webhook\'s payload.
     */
    'token'?: string;
    /**
     * The API endpoint to retrieve the webhook.
     */
    'href'?: string;
}
export interface WebhookShared {
    /**
     * Determine if the webhook is active.
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are sandbox and live. If the environments parameter is omitted the webhook will receive events from both environments. 
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     */
    'payload_version'?: number;
    /**
     * Determines if the webhook will fetch OAuth access tokens to send in the Authorization header.
     */
    'oauth_enabled'?: boolean;
    /**
     * The url to fetch the OAuth access token using client credentials grant.
     */
    'oauth_server_url'?: string;
    /**
     * The client id to authenticate the client credentials grant.
     */
    'oauth_server_client_id'?: string;
    /**
     * The client secret to authenticate the client credentials grant.
     */
    'oauth_server_client_secret'?: string;
    /**
     * The scopes to be sent when requesting the access token.
     */
    'oauth_server_scope'?: string;
}
export interface WebhookUpdate {
    /**
     * The url that will listen to notifications (must be https).
     */
    'url'?: string;
}
export interface WebhookUpdater {
    /**
     * Determine if the webhook is active.
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are sandbox and live. If the environments parameter is omitted the webhook will receive events from both environments. 
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     */
    'payload_version'?: number;
    /**
     * Determines if the webhook will fetch OAuth access tokens to send in the Authorization header.
     */
    'oauth_enabled'?: boolean;
    /**
     * The url to fetch the OAuth access token using client credentials grant.
     */
    'oauth_server_url'?: string;
    /**
     * The client id to authenticate the client credentials grant.
     */
    'oauth_server_client_id'?: string;
    /**
     * The client secret to authenticate the client credentials grant.
     */
    'oauth_server_client_secret'?: string;
    /**
     * The scopes to be sent when requesting the access token.
     */
    'oauth_server_scope'?: string;
    /**
     * The url that will listen to notifications (must be https).
     */
    'url'?: string;
}
export interface WebhooksList {
    'webhooks': Array<Webhook>;
}
export interface WebhooksResendItem {
    /**
     * ID of the resource whose webhooks are to be retriggered.
     */
    'resource_id': string;
    /**
     * The events that should retrigger webhooks. Accepts values check.completed.
     */
    'event': WebhookEventType;
}


export interface WorkflowRun {
    /**
     * The unique identifier for the Applicant.
     */
    'applicant_id': string;
    /**
     * The unique identifier for the Workflow.
     */
    'workflow_id': string;
    /**
     * Tags or labels assigned to the workflow run.
     */
    'tags'?: Array<string> | null;
    /**
     * Customer-provided user identifier.
     */
    'customer_user_id'?: string;
    /**
     * Object for the configuration of the Workflow Run link.
     */
    'link'?: WorkflowRunLink;
    /**
     * The date and time when the Workflow Run was created.
     */
    'created_at'?: string;
    /**
     * The date and time when the Workflow Run was last updated.
     */
    'updated_at'?: string;
    /**
     * The unique identifier for the Workflow Run.
     */
    'id': string;
    /**
     * The identifier for the Workflow version.
     */
    'workflow_version_id'?: number;
    /**
     * The URL for viewing the Workflow Run results on your Onfido Dashboard.
     */
    'dashboard_url'?: string;
    /**
     * The status of the Workflow Run.
     */
    'status'?: WorkflowRunStatus;
    /**
     * Output object contains all of the properties configured on the Workflow version.
     */
    'output'?: object;
    /**
     * The reasons the Workflow Run outcome was reached. Configurable when creating the Workflow version.
     */
    'reasons'?: Array<string>;
    /**
     * Error object. Only set when the Workflow Run status is \'error\'.
     */
    'error'?: WorkflowRunError;
    /**
     * Client token to use when loading this workflow run in the Onfido SDK.
     */
    'sdk_token'?: string | null;
}


export interface WorkflowRunBuilder {
    /**
     * The unique identifier for the Applicant.
     */
    'applicant_id': string;
    /**
     * The unique identifier for the Workflow.
     */
    'workflow_id': string;
    /**
     * Tags or labels assigned to the workflow run.
     */
    'tags'?: Array<string> | null;
    /**
     * Customer-provided user identifier.
     */
    'customer_user_id'?: string;
    /**
     * Object for the configuration of the Workflow Run link.
     */
    'link'?: WorkflowRunLink;
    /**
     * The date and time when the Workflow Run was created.
     */
    'created_at'?: string;
    /**
     * The date and time when the Workflow Run was last updated.
     */
    'updated_at'?: string;
    /**
     * Object with Custom Input Data to be used in the Workflow Run.
     */
    'custom_data'?: { [key: string]: any; };
}
export interface WorkflowRunError {
    /**
     * The type of error.
     */
    'type'?: string;
    /**
     * A textual description of the error.
     */
    'message'?: string;
}
export interface WorkflowRunLink {
    /**
     * Link to access the Workflow Run without the need to integrate with Onfido\'s SDKs.
     */
    'url'?: string;
    /**
     * When the interactive section of the Workflow Run has completed successfully, the user will be redirected to this URL instead of seeing the default Onfido \'thank you\' page.
     */
    'completed_redirect_url'?: string | null;
    /**
     * When the link has expired, the user will be immediately redirected to this URL instead of seeing the default Onfido error message.
     */
    'expired_redirect_url'?: string | null;
    /**
     * Date and time when the link will expire.
     */
    'expires_at'?: string | null;
    /**
     * The code for the language when the workflow run is acessed using the link.
     */
    'language'?: WorkflowRunLinkLanguageEnum | null;
}

export const WorkflowRunLinkLanguageEnum = {
    EnUs: 'en_US',
    DeDe: 'de_DE',
    EsEs: 'es_ES',
    FrFr: 'fr_FR',
    ItIt: 'it_IT',
    PtPt: 'pt_PT',
    NlNl: 'nl_NL',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WorkflowRunLinkLanguageEnum = typeof WorkflowRunLinkLanguageEnum[keyof typeof WorkflowRunLinkLanguageEnum];

export interface WorkflowRunRequest {
    /**
     * Object with Custom Input Data to be used in the Workflow Run.
     */
    'custom_data'?: { [key: string]: any; };
}
export interface WorkflowRunResponse {
    /**
     * The unique identifier for the Workflow Run.
     */
    'id': string;
    /**
     * The identifier for the Workflow version.
     */
    'workflow_version_id'?: number;
    /**
     * The URL for viewing the Workflow Run results on your Onfido Dashboard.
     */
    'dashboard_url'?: string;
    /**
     * The status of the Workflow Run.
     */
    'status'?: WorkflowRunStatus;
    /**
     * Output object contains all of the properties configured on the Workflow version.
     */
    'output'?: object;
    /**
     * The reasons the Workflow Run outcome was reached. Configurable when creating the Workflow version.
     */
    'reasons'?: Array<string>;
    /**
     * Error object. Only set when the Workflow Run status is \'error\'.
     */
    'error'?: WorkflowRunError;
    /**
     * Client token to use when loading this workflow run in the Onfido SDK.
     */
    'sdk_token'?: string | null;
}


export interface WorkflowRunShared {
    /**
     * The unique identifier for the Applicant.
     */
    'applicant_id': string;
    /**
     * The unique identifier for the Workflow.
     */
    'workflow_id': string;
    /**
     * Tags or labels assigned to the workflow run.
     */
    'tags'?: Array<string> | null;
    /**
     * Customer-provided user identifier.
     */
    'customer_user_id'?: string;
    /**
     * Object for the configuration of the Workflow Run link.
     */
    'link'?: WorkflowRunLink;
    /**
     * The date and time when the Workflow Run was created.
     */
    'created_at'?: string;
    /**
     * The date and time when the Workflow Run was last updated.
     */
    'updated_at'?: string;
}

export const WorkflowRunStatus = {
    Processing: 'processing',
    AwaitingInput: 'awaiting_input',
    AwaitingClientInput: 'awaiting_client_input',
    Approved: 'approved',
    Declined: 'declined',
    Review: 'review',
    Abandoned: 'abandoned',
    Error: 'error',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WorkflowRunStatus = typeof WorkflowRunStatus[keyof typeof WorkflowRunStatus];



/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels single paused reports. 
         * @summary Cancel report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('cancelReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/cancel`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a Send / Receive Data Task. 
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('completeTask', 'workflowRunId', workflowRunId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('completeTask', 'taskId', taskId)
            // verify required parameter 'completeTaskBuilder' is not null or undefined
            assertParamExists('completeTask', 'completeTaskBuilder', completeTaskBuilder)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}/complete`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a single applicant. Returns an applicant object. 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant: async (applicantBuilder: ApplicantBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantBuilder' is not null or undefined
            assertParamExists('createApplicant', 'applicantBuilder', applicantBuilder)
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicantBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: async (checkBuilder: CheckBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkBuilder' is not null or undefined
            assertParamExists('createCheck', 'checkBuilder', checkBuilder)
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run. 
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('createTimelineFile', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new monitor for the applicant 
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor: async (watchlistMonitorBuilder: WatchlistMonitorBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watchlistMonitorBuilder' is not null or undefined
            assertParamExists('createWatchlistMonitor', 'watchlistMonitorBuilder', watchlistMonitorBuilder)
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitorBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a webhook. Returns a webhook object. 
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (webhookBuilder: WebhookBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookBuilder' is not null or undefined
            assertParamExists('createWebhook', 'webhookBuilder', webhookBuilder)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object. 
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun: async (workflowRunBuilder: WorkflowRunBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunBuilder' is not null or undefined
            assertParamExists('createWorkflowRun', 'workflowRunBuilder', workflowRunBuilder)
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowRunBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single applicant. 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('deleteApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a passkey. 
         * @summary Delete passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasskey: async (username: string, passkeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deletePasskey', 'username', username)
            // verify required parameter 'passkeyId' is not null or undefined
            assertParamExists('deletePasskey', 'passkeyId', passkeyId)
            const localVarPath = `/passkeys/{username}/{passkey_id}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"passkey_id"}}`, encodeURIComponent(String(passkeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes every passkey for the username. 
         * @summary Delete passkeys
         * @param {string} username Username whose passkeys will be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasskeys: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deletePasskeys', 'username', username)
            const localVarPath = `/passkeys/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates the given monitor 
         * @summary Delete monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('deleteWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a webhook. 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the signed document or signing transaction receipt depending on the id provided. 
         * @summary Retrieves the signed document or signing transaction receipt
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} id The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAesDocument: async (workflowRunId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadAesDocument', 'workflowRunId', workflowRunId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadAesDocument', 'id', id)
            const localVarPath = `/advanced_electronic_signature/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workflowRunId !== undefined) {
                localVarQueryParameter['workflow_run_id'] = workflowRunId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
         * @summary Download check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('downloadCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}/download`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocument', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video. 
         * @summary Download document video
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentVideo', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/video/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadEvidenceFolder', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/evidence_folder`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto: async (idPhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('downloadIdPhoto', 'idPhotoId', idPhotoId)
            const localVarPath = `/id_photos/{id_photo_id}/download`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto: async (livePhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('downloadLivePhoto', 'livePhotoId', livePhotoId)
            const localVarPath = `/live_photos/{live_photo_id}/download`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideo', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}/download`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideoFrame', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}/frame`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCapture', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}/download`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCaptureFrame', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}/frame`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download NFC face
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadNfcFace', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/nfc_face`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided. 
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument: async (workflowRunId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadQesDocument', 'workflowRunId', workflowRunId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadQesDocument', 'fileId', fileId)
            const localVarPath = `/qualified_electronic_signature/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workflowRunId !== undefined) {
                localVarQueryParameter['workflow_run_id'] = workflowRunId;
            }

            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the signed document or signing transaction receipt depending on the id provided. 
         * @summary Retrieves the signed document or signing transaction receipt
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} id The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSesDocument: async (workflowRunId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadSesDocument', 'workflowRunId', workflowRunId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadSesDocument', 'id', id)
            const localVarPath = `/simple_electronic_signature/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workflowRunId !== undefined) {
                localVarQueryParameter['workflow_run_id'] = workflowRunId;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadSignedEvidenceFile', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/signed_evidence_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads specific signing documents belonging to an applicant. If successful, the response will be the binary data representing the pdf. 
         * @summary Download signing document
         * @param {string} signingDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSigningDocument: async (signingDocumentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signingDocumentId' is not null or undefined
            assertParamExists('downloadSigningDocument', 'signingDocumentId', signingDocumentId)
            const localVarPath = `/signing_documents/{signing_document_id}/download`
                .replace(`{${"signing_document_id"}}`, encodeURIComponent(String(signingDocumentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extract information from a document 
         * @summary Autofill
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract: async (extractRequest: ExtractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extractRequest' is not null or undefined
            assertParamExists('extract', 'extractRequest', extractRequest)
            const localVarPath = `/extractions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for addresses by postcode 
         * @summary Address Picker
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses: async (postcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postcode' is not null or undefined
            assertParamExists('findAddresses', 'postcode', postcode)
            const localVarPath = `/addresses/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (postcode !== undefined) {
                localVarQueryParameter['postcode'] = postcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single applicant. Returns an applicant object. 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('findApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves consents for single applicant. 
         * @summary Retrieve Applicant Consents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicantConsents: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('findApplicantConsents', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}/consents`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('findCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
         * @summary Retrieve document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('findDocument', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object. 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto: async (idPhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('findIdPhoto', 'idPhotoId', idPhotoId)
            const localVarPath = `/id_photos/{id_photo_id}`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single live photo. Returns a live photo object. 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto: async (livePhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('findLivePhoto', 'livePhotoId', livePhotoId)
            const localVarPath = `/live_photos/{live_photo_id}`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object. 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('findLiveVideo', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object. 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('findMotionCapture', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a passkey\'s details. 
         * @summary Retrieve passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPasskey: async (username: string, passkeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('findPasskey', 'username', username)
            // verify required parameter 'passkeyId' is not null or undefined
            assertParamExists('findPasskey', 'passkeyId', passkeyId)
            const localVarPath = `/passkeys/{username}/{passkey_id}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"passkey_id"}}`, encodeURIComponent(String(passkeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
         * @summary Retrieve report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('findReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single signing document can be retrieved by calling this endpoint with the signing document\'s unique identifier. 
         * @summary Retrieve signing document
         * @param {string} signingDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSigningDocument: async (signingDocumentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signingDocumentId' is not null or undefined
            assertParamExists('findSigningDocument', 'signingDocumentId', signingDocumentId)
            const localVarPath = `/signing_documents/{signing_document_id}`
                .replace(`{${"signing_document_id"}}`, encodeURIComponent(String(signingDocumentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask: async (workflowRunId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findTask', 'workflowRunId', workflowRunId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('findTask', 'taskId', taskId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run. 
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile: async (workflowRunId: string, timelineFileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findTimelineFile', 'workflowRunId', workflowRunId)
            // verify required parameter 'timelineFileId' is not null or undefined
            assertParamExists('findTimelineFile', 'timelineFileId', timelineFileId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file/{timeline_file_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"timeline_file_id"}}`, encodeURIComponent(String(timelineFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single monitor 
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('findWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single webhook. Returns a webhook object. 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('findWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findWorkflowRun', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('forceReportCreationFromWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}/new_report`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token. 
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken: async (sdkTokenBuilder: SdkTokenBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sdkTokenBuilder' is not null or undefined
            assertParamExists('generateSdkToken', 'sdkTokenBuilder', sdkTokenBuilder)
            const localVarPath = `/sdk_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sdkTokenBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order. 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants: async (page?: number, perPage?: number, includeDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listChecks', 'applicantId', applicantId)
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listDocuments', 'applicantId', applicantId)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the ID photos that belong to an applicant. 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listIdPhotos', 'applicantId', applicantId)
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the live photos that belong to an applicant. 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLivePhotos', 'applicantId', applicantId)
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the live videos that belong to an applicant. 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLiveVideos', 'applicantId', applicantId)
            const localVarPath = `/live_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the motion captures that belong to an applicant. 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listMotionCaptures', 'applicantId', applicantId)
            const localVarPath = `/motion_captures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns every passkey registered under the supplied username. 
         * @summary List passkeys
         * @param {string} username Username that owns the passkeys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPasskeys: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('listPasskeys', 'username', username)
            const localVarPath = `/passkeys/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all repeat attempts for a given Document report 
         * @summary Retrieve repeat attempts
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('listRepeatAttempts', 'reportId', reportId)
            const localVarPath = `/repeat_attempts/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint. 
         * @summary List reports
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('listReports', 'checkId', checkId)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checkId !== undefined) {
                localVarQueryParameter['check_id'] = checkId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All signing documents belonging to an applicant can be listed from this endpoint
         * @summary List signing documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSigningDocuments: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listSigningDocuments', 'applicantId', applicantId)
            const localVarPath = `/signing_documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('listTasks', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status 
         * @summary List matches (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('listWatchlistMonitorMatches', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available monitors for an applicant 
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors: async (applicantId: string, includeDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listWatchlistMonitors', 'applicantId', applicantId)
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all webhooks you\'ve created. 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {Array<string>} [tags] A list of tags to filter the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns: async (page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, applicantId?: string, tags?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString().substring(0,10) :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString().substring(0,10) :
                    createdAtLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a health check on the Onfido API 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Feedback on checks and reports 
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback: async (resultsFeedback: ResultsFeedback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultsFeedback' is not null or undefined
            assertParamExists('postResultsFeedback', 'resultsFeedback', resultsFeedback)
            const localVarPath = `/results_feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resultsFeedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account. 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks: async (webhookResend: WebhookResend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookResend' is not null or undefined
            assertParamExists('resendWebhooks', 'webhookResend', webhookResend)
            const localVarPath = `/webhooks/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookResend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores a single applicant scheduled for deletion. 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('restoreApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}/restore`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a paused check. 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('resumeCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}/resume`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a single paused report. 
         * @summary Resume report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('resumeReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/resume`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantUpdater} applicantUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant: async (applicantId: string, applicantUpdater: ApplicantUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('updateApplicant', 'applicantId', applicantId)
            // verify required parameter 'applicantUpdater' is not null or undefined
            assertParamExists('updateApplicant', 'applicantUpdater', applicantUpdater)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicantUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a passkey\'s state. 
         * @summary Update passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {PasskeyUpdater} passkeyUpdater Passkey update payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasskey: async (username: string, passkeyId: string, passkeyUpdater: PasskeyUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updatePasskey', 'username', username)
            // verify required parameter 'passkeyId' is not null or undefined
            assertParamExists('updatePasskey', 'passkeyId', passkeyId)
            // verify required parameter 'passkeyUpdater' is not null or undefined
            assertParamExists('updatePasskey', 'passkeyUpdater', passkeyUpdater)
            const localVarPath = `/passkeys/{username}/{passkey_id}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"passkey_id"}}`, encodeURIComponent(String(passkeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of the given matches 
         * @summary Set match status (BETA)
         * @param {string} monitorId 
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch: async (monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('updateWatchlistMonitorMatch', 'monitorId', monitorId)
            // verify required parameter 'watchlistMonitorMatchesUpdater' is not null or undefined
            assertParamExists('updateWatchlistMonitorMatch', 'watchlistMonitorMatchesUpdater', watchlistMonitorMatchesUpdater)
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitorMatchesUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a webhook. Returns the updated webhook object. 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, webhookUpdater: WebhookUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            // verify required parameter 'webhookUpdater' is not null or undefined
            assertParamExists('updateWebhook', 'webhookUpdater', webhookUpdater)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument: async (type: DocumentTypes, applicantId: string, file: FileTransfer, fileType?: string, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('uploadDocument', 'type', type)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadDocument', 'applicantId', applicantId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocument', 'file', file)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (fileType !== undefined) { 
                localVarFormParams.append('file_type', fileType as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.append('side', side as any);
            }
    
            if (issuingCountry !== undefined) { 
                localVarFormParams.append('issuing_country', issuingCountry as any);
            }
    
            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
            if (validateImageQuality !== undefined) { 
                localVarFormParams.append('validate_image_quality', String(validateImageQuality) as any);
            }
    
            if (location !== undefined) { 
                localVarFormParams.append('location', JSON.stringify(location));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto: async (applicantId?: string, file?: FileTransfer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto: async (applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
            if (advancedValidation !== undefined) { 
                localVarFormParams.append('advanced_validation', String(advancedValidation) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Signing documents are uploaded using this endpoint. Signing documents must be uploaded as a multipart form. The only valid file type is pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a signing document
         * @param {string} applicantId The ID of the applicant whose signing document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSigningDocument: async (applicantId: string, file: FileTransfer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadSigningDocument', 'applicantId', applicantId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadSigningDocument', 'file', file)
            const localVarPath = `/signing_documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels single paused reports. 
         * @summary Cancel report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes a Send / Receive Data Task. 
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(workflowRunId, taskId, completeTaskBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.completeTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a single applicant. Returns an applicant object. 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicant(applicantBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheck(checkBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run. 
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimelineFile(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimelineFileReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimelineFile(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createTimelineFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new monitor for the applicant 
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchlistMonitor(watchlistMonitorBuilder: WatchlistMonitorBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchlistMonitor(watchlistMonitorBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registers a webhook. Returns a webhook object. 
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(webhookBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object. 
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowRun(workflowRunBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWorkflowRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single applicant. 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a passkey. 
         * @summary Delete passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasskey(username: string, passkeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasskey(username, passkeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deletePasskey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes every passkey for the username. 
         * @summary Delete passkeys
         * @param {string} username Username whose passkeys will be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasskeys(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasskeys(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deletePasskeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates the given monitor 
         * @summary Delete monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a webhook. 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the signed document or signing transaction receipt depending on the id provided. 
         * @summary Retrieves the signed document or signing transaction receipt
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} id The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAesDocument(workflowRunId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAesDocument(workflowRunId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadAesDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
         * @summary Download check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video. 
         * @summary Download document video
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentVideo(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadDocumentVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadEvidenceFolder(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadEvidenceFolder(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadEvidenceFolder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadIdPhoto(idPhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLivePhoto(livePhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLiveVideo(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLiveVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLiveVideoFrame(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLiveVideoFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMotionCapture(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadMotionCapture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMotionCaptureFrame(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadMotionCaptureFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download NFC face
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadNfcFace(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadNfcFace(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadNfcFace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided. 
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQesDocument(workflowRunId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQesDocument(workflowRunId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadQesDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the signed document or signing transaction receipt depending on the id provided. 
         * @summary Retrieves the signed document or signing transaction receipt
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} id The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSesDocument(workflowRunId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSesDocument(workflowRunId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadSesDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSignedEvidenceFile(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadSignedEvidenceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads specific signing documents belonging to an applicant. If successful, the response will be the binary data representing the pdf. 
         * @summary Download signing document
         * @param {string} signingDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSigningDocument(signingDocumentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSigningDocument(signingDocumentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadSigningDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extract information from a document 
         * @summary Autofill
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extraction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extract(extractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.extract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for addresses by postcode 
         * @summary Address Picker
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAddresses(postcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAddresses(postcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single applicant. Returns an applicant object. 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves consents for single applicant. 
         * @summary Retrieve Applicant Consents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findApplicantConsents(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApplicantConsent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findApplicantConsents(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findApplicantConsents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
         * @summary Retrieve document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object. 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIdPhoto(idPhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single live photo. Returns a live photo object. 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLivePhoto(livePhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object. 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveVideo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLiveVideo(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findLiveVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object. 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotionCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMotionCapture(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findMotionCapture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a passkey\'s details. 
         * @summary Retrieve passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPasskey(username: string, passkeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Passkey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPasskey(username, passkeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findPasskey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
         * @summary Retrieve report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single signing document can be retrieved by calling this endpoint with the signing document\'s unique identifier. 
         * @summary Retrieve signing document
         * @param {string} signingDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSigningDocument(signingDocumentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSigningDocument(signingDocumentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findSigningDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTask(workflowRunId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run. 
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTimelineFile(workflowRunId: string, timelineFileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTimelineFile(workflowRunId, timelineFileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findTimelineFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single monitor 
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single webhook. Returns a webhook object. 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkflowRun(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWorkflowRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceReportCreationFromWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceReportCreationFromWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forceReportCreationFromWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token. 
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSdkToken(sdkTokenBuilder: SdkTokenBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdkToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSdkToken(sdkTokenBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.generateSdkToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order. 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicantsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicants(page, perPage, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listApplicants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChecks(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChecksList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChecks(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocuments(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocuments(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the ID photos that belong to an applicant. 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhotosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdPhotos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIdPhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the live photos that belong to an applicant. 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhotosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLivePhotos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listLivePhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all the live videos that belong to an applicant. 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveVideosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLiveVideos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listLiveVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all the motion captures that belong to an applicant. 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotionCapturesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMotionCaptures(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMotionCaptures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns every passkey registered under the supplied username. 
         * @summary List passkeys
         * @param {string} username Username that owns the passkeys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPasskeys(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeysList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPasskeys(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listPasskeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all repeat attempts for a given Document report 
         * @summary Retrieve repeat attempts
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepeatAttemptsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepeatAttempts(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listRepeatAttempts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint. 
         * @summary List reports
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReports(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReports(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All signing documents belonging to an applicant can be listed from this endpoint
         * @summary List signing documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSigningDocuments(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningDocumentsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSigningDocuments(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listSigningDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status 
         * @summary List matches (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitorMatchesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlistMonitorMatches(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWatchlistMonitorMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all available monitors for an applicant 
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitorsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlistMonitors(applicantId, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWatchlistMonitors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all webhooks you\'ve created. 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {Array<string>} [tags] A list of tags to filter the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, applicantId?: string, tags?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, tags, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWorkflowRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a health check on the Onfido API 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Feedback on checks and reports 
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultsFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postResultsFeedback(resultsFeedback, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postResultsFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account. 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhooks(webhookResend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resendWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores a single applicant scheduled for deletion. 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.restoreApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resumes a paused check. 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resumeCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resumes a single paused report. 
         * @summary Resume report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resumeReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantUpdater} applicantUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicant(applicantId: string, applicantUpdater: ApplicantUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicant(applicantId, applicantUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a passkey\'s state. 
         * @summary Update passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {PasskeyUpdater} passkeyUpdater Passkey update payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasskey(username: string, passkeyId: string, passkeyUpdater: PasskeyUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Passkey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasskey(username, passkeyId, passkeyUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updatePasskey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of the given matches 
         * @summary Set match status (BETA)
         * @param {string} monitorId 
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWatchlistMonitorMatch(monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitorMatchesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWatchlistMonitorMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edits a webhook. Returns the updated webhook object. 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, webhookUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocument(type: DocumentTypes, applicantId: string, file: FileTransfer, fileType?: string, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadIdPhoto(applicantId?: string, file?: FileTransfer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadIdPhoto(applicantId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadLivePhoto(applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadLivePhoto(applicantId, file, advancedValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Signing documents are uploaded using this endpoint. Signing documents must be uploaded as a multipart form. The only valid file type is pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a signing document
         * @param {string} applicantId The ID of the applicant whose signing document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadSigningDocument(applicantId: string, file: FileTransfer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SigningDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadSigningDocument(applicantId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadSigningDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Cancels single paused reports. 
         * @summary Cancel report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a Send / Receive Data Task. 
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a single applicant. Returns an applicant object. 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig): AxiosPromise<Applicant> {
            return localVarFp.createApplicant(applicantBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig): AxiosPromise<Check> {
            return localVarFp.createCheck(checkBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run. 
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile(workflowRunId: string, options?: RawAxiosRequestConfig): AxiosPromise<TimelineFileReference> {
            return localVarFp.createTimelineFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new monitor for the applicant 
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitorBuilder: WatchlistMonitorBuilder, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistMonitor> {
            return localVarFp.createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a webhook. Returns a webhook object. 
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(webhookBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object. 
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowRun> {
            return localVarFp.createWorkflowRun(workflowRunBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single applicant. 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a passkey. 
         * @summary Delete passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasskey(username: string, passkeyId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePasskey(username, passkeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes every passkey for the username. 
         * @summary Delete passkeys
         * @param {string} username Username whose passkeys will be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasskeys(username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePasskeys(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates the given monitor 
         * @summary Delete monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a webhook. 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed document or signing transaction receipt depending on the id provided. 
         * @summary Retrieves the signed document or signing transaction receipt
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} id The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAesDocument(workflowRunId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadAesDocument(workflowRunId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
         * @summary Download check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video. 
         * @summary Download document video
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadDocumentVideo(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the evidence folder for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Folder
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadEvidenceFolder(workflowRunId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadEvidenceFolder(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadLiveVideoFrame(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download NFC face
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadNfcFace(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadNfcFace(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided. 
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument(workflowRunId: string, fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadQesDocument(workflowRunId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed document or signing transaction receipt depending on the id provided. 
         * @summary Retrieves the signed document or signing transaction receipt
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} id The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSesDocument(workflowRunId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadSesDocument(workflowRunId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads specific signing documents belonging to an applicant. If successful, the response will be the binary data representing the pdf. 
         * @summary Download signing document
         * @param {string} signingDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSigningDocument(signingDocumentId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.downloadSigningDocument(signingDocumentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Extract information from a document 
         * @summary Autofill
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig): AxiosPromise<Extraction> {
            return localVarFp.extract(extractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for addresses by postcode 
         * @summary Address Picker
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode: string, options?: RawAxiosRequestConfig): AxiosPromise<AddressesList> {
            return localVarFp.findAddresses(postcode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single applicant. Returns an applicant object. 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<Applicant> {
            return localVarFp.findApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves consents for single applicant. 
         * @summary Retrieve Applicant Consents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicantConsents(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ApplicantConsent>> {
            return localVarFp.findApplicantConsents(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId: string, options?: RawAxiosRequestConfig): AxiosPromise<Check> {
            return localVarFp.findCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
         * @summary Retrieve document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId: string, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.findDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object. 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): AxiosPromise<IdPhoto> {
            return localVarFp.findIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live photo. Returns a live photo object. 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): AxiosPromise<LivePhoto> {
            return localVarFp.findLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object. 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): AxiosPromise<LiveVideo> {
            return localVarFp.findLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object. 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): AxiosPromise<MotionCapture> {
            return localVarFp.findMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a passkey\'s details. 
         * @summary Retrieve passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPasskey(username: string, passkeyId: string, options?: RawAxiosRequestConfig): AxiosPromise<Passkey> {
            return localVarFp.findPasskey(username, passkeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
         * @summary Retrieve report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<Report> {
            return localVarFp.findReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single signing document can be retrieved by calling this endpoint with the signing document\'s unique identifier. 
         * @summary Retrieve signing document
         * @param {string} signingDocumentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSigningDocument(signingDocumentId: string, options?: RawAxiosRequestConfig): AxiosPromise<SigningDocument> {
            return localVarFp.findSigningDocument(signingDocumentId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.findTask(workflowRunId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run. 
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile(workflowRunId: string, timelineFileId: string, options?: RawAxiosRequestConfig): AxiosPromise<FileTransfer> {
            return localVarFp.findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single monitor 
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistMonitor> {
            return localVarFp.findWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single webhook. Returns a webhook object. 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.findWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowRun> {
            return localVarFp.findWorkflowRun(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token. 
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(sdkTokenBuilder: SdkTokenBuilder, options?: RawAxiosRequestConfig): AxiosPromise<SdkToken> {
            return localVarFp.generateSdkToken(sdkTokenBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order. 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ApplicantsList> {
            return localVarFp.listApplicants(page, perPage, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<ChecksList> {
            return localVarFp.listChecks(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<DocumentsList> {
            return localVarFp.listDocuments(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the ID photos that belong to an applicant. 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<IdPhotosList> {
            return localVarFp.listIdPhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the live photos that belong to an applicant. 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<LivePhotosList> {
            return localVarFp.listLivePhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the live videos that belong to an applicant. 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<LiveVideosList> {
            return localVarFp.listLiveVideos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the motion captures that belong to an applicant. 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<MotionCapturesList> {
            return localVarFp.listMotionCaptures(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns every passkey registered under the supplied username. 
         * @summary List passkeys
         * @param {string} username Username that owns the passkeys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPasskeys(username: string, options?: RawAxiosRequestConfig): AxiosPromise<PasskeysList> {
            return localVarFp.listPasskeys(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all repeat attempts for a given Document report 
         * @summary Retrieve repeat attempts
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<RepeatAttemptsList> {
            return localVarFp.listRepeatAttempts(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint. 
         * @summary List reports
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId: string, options?: RawAxiosRequestConfig): AxiosPromise<ReportsList> {
            return localVarFp.listReports(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * All signing documents belonging to an applicant can be listed from this endpoint
         * @summary List signing documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSigningDocuments(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<SigningDocumentsList> {
            return localVarFp.listSigningDocuments(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskItem>> {
            return localVarFp.listTasks(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status 
         * @summary List matches (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistMonitorMatchesList> {
            return localVarFp.listWatchlistMonitorMatches(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available monitors for an applicant 
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistMonitorsList> {
            return localVarFp.listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all webhooks you\'ve created. 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options?: RawAxiosRequestConfig): AxiosPromise<WebhooksList> {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {string} [applicantId] the applicant\&#39;s id.
         * @param {Array<string>} [tags] A list of tags to filter the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, applicantId?: string, tags?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkflowRun>> {
            return localVarFp.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a health check on the Onfido API 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Create Feedback on checks and reports 
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig): AxiosPromise<ResultsFeedback> {
            return localVarFp.postResultsFeedback(resultsFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account. 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendWebhooks(webhookResend, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a single applicant scheduled for deletion. 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.restoreApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a paused check. 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resumeCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a single paused report. 
         * @summary Resume report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resumeReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantUpdater} applicantUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId: string, applicantUpdater: ApplicantUpdater, options?: RawAxiosRequestConfig): AxiosPromise<Applicant> {
            return localVarFp.updateApplicant(applicantId, applicantUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a passkey\'s state. 
         * @summary Update passkey
         * @param {string} username Username that owns the passkey.
         * @param {string} passkeyId Passkey ID.
         * @param {PasskeyUpdater} passkeyUpdater Passkey update payload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasskey(username: string, passkeyId: string, passkeyUpdater: PasskeyUpdater, options?: RawAxiosRequestConfig): AxiosPromise<Passkey> {
            return localVarFp.updatePasskey(username, passkeyId, passkeyUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of the given matches 
         * @summary Set match status (BETA)
         * @param {string} monitorId 
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch(monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options?: RawAxiosRequestConfig): AxiosPromise<WatchlistMonitorMatchesList> {
            return localVarFp.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a webhook. Returns the updated webhook object. 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(webhookId, webhookUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {DocumentTypes} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {string} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type: DocumentTypes, applicantId: string, file: FileTransfer, fileType?: string, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig): AxiosPromise<Document> {
            return localVarFp.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId?: string, file?: FileTransfer, options?: RawAxiosRequestConfig): AxiosPromise<IdPhoto> {
            return localVarFp.uploadIdPhoto(applicantId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<LivePhoto> {
            return localVarFp.uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Signing documents are uploaded using this endpoint. Signing documents must be uploaded as a multipart form. The only valid file type is pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a signing document
         * @param {string} applicantId The ID of the applicant whose signing document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadSigningDocument(applicantId: string, file: FileTransfer, options?: RawAxiosRequestConfig): AxiosPromise<SigningDocument> {
            return localVarFp.uploadSigningDocument(applicantId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * Cancels single paused reports. 
     * @summary Cancel report
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a Send / Receive Data Task. 
     * @summary Complete Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to complete.
     * @param {CompleteTaskBuilder} completeTaskBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public completeTask(workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a single applicant. Returns an applicant object. 
     * @summary Create Applicant
     * @param {ApplicantBuilder} applicantBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createApplicant(applicantBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
     * @summary Create a check
     * @param {CheckBuilder} checkBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCheck(checkBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers the generation of the Timeline File for the designated Workflow Run. 
     * @summary Create Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTimelineFile(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTimelineFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new monitor for the applicant 
     * @summary Create monitor
     * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWatchlistMonitor(watchlistMonitorBuilder: WatchlistMonitorBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a webhook. Returns a webhook object. 
     * @summary Register webhook
     * @param {WebhookBuilder} webhookBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWebhook(webhookBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and starts a Workflow Run. Returns a Workflow Run object. 
     * @summary Create a Workflow Run
     * @param {WorkflowRunBuilder} workflowRunBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWorkflowRun(workflowRunBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single applicant. 
     * @summary Delete Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a passkey. 
     * @summary Delete passkey
     * @param {string} username Username that owns the passkey.
     * @param {string} passkeyId Passkey ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePasskey(username: string, passkeyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePasskey(username, passkeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes every passkey for the username. 
     * @summary Delete passkeys
     * @param {string} username Username whose passkeys will be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePasskeys(username: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePasskeys(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates the given monitor 
     * @summary Delete monitor
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a webhook. 
     * @summary Delete a webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the signed document or signing transaction receipt depending on the id provided. 
     * @summary Retrieves the signed document or signing transaction receipt
     * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
     * @param {string} id The unique identifier of the file which you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadAesDocument(workflowRunId: string, id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadAesDocument(workflowRunId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
     * @summary Download check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
     * @summary Download document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a document video. If successful, the response will be the binary data representing the video. 
     * @summary Download document video
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadDocumentVideo(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the evidence folder for the designated Workflow Run 
     * @summary Retrieve Workflow Run Evidence Folder
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadEvidenceFolder(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadEvidenceFolder(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID photos are downloaded using this endpoint.
     * @summary Download ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Live photos are downloaded using this endpoint.
     * @summary Download live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Live videos are downloaded using this endpoint.
     * @summary Download live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the binary data representing a single frame from a live video.
     * @summary Download live video frame
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLiveVideoFrame(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Motion captures are downloaded using this endpoint.
     * @summary Download motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
     * @summary Download motion capture frame
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads digital photos extracted from specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
     * @summary Download NFC face
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadNfcFace(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadNfcFace(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the signed document or application form depending on the file_id provided. 
     * @summary Retrieves the signed document or application form
     * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
     * @param {string} fileId The unique identifier of the file which you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadQesDocument(workflowRunId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadQesDocument(workflowRunId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the signed document or signing transaction receipt depending on the id provided. 
     * @summary Retrieves the signed document or signing transaction receipt
     * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
     * @param {string} id The unique identifier of the file which you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadSesDocument(workflowRunId: string, id: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSesDocument(workflowRunId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the signed evidence file for the designated Workflow Run 
     * @summary Retrieve Workflow Run Evidence Summary File
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads specific signing documents belonging to an applicant. If successful, the response will be the binary data representing the pdf. 
     * @summary Download signing document
     * @param {string} signingDocumentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadSigningDocument(signingDocumentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSigningDocument(signingDocumentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extract information from a document 
     * @summary Autofill
     * @param {ExtractRequest} extractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extract(extractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for addresses by postcode 
     * @summary Address Picker
     * @param {string} postcode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findAddresses(postcode: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findAddresses(postcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single applicant. Returns an applicant object. 
     * @summary Retrieve Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves consents for single applicant. 
     * @summary Retrieve Applicant Consents
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findApplicantConsents(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findApplicantConsents(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single check. Returns a check object. 
     * @summary Retrieve a Check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
     * @summary Retrieve document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single ID photo. Returns a ID photo object. 
     * @summary Retrieve ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single live photo. Returns a live photo object. 
     * @summary Retrieve live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single live video. Returns the corresponding live video object. 
     * @summary Retrieve live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single motion capture. Returns the corresponding motion capture object. 
     * @summary Retrieve motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a passkey\'s details. 
     * @summary Retrieve passkey
     * @param {string} username Username that owns the passkey.
     * @param {string} passkeyId Passkey ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findPasskey(username: string, passkeyId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findPasskey(username, passkeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
     * @summary Retrieve report
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single signing document can be retrieved by calling this endpoint with the signing document\'s unique identifier. 
     * @summary Retrieve signing document
     * @param {string} signingDocumentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findSigningDocument(signingDocumentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findSigningDocument(signingDocumentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
     * @summary Retrieve Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findTask(workflowRunId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Timeline File for the designated Workflow Run. 
     * @summary Retrieve Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {string} timelineFileId The unique identifier for the Timefile File.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findTimelineFile(workflowRunId: string, timelineFileId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single monitor 
     * @summary Retrieve monitor
     * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single webhook. Returns a webhook object. 
     * @summary Retrieve a Webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
     * @summary Retrieve Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWorkflowRun(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
     * @summary Force new report creation (BETA)
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public forceReportCreationFromWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an SDK token. Returns a token object containing the SDK token. 
     * @summary Generate a SDK token
     * @param {SdkTokenBuilder} sdkTokenBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateSdkToken(sdkTokenBuilder: SdkTokenBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateSdkToken(sdkTokenBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all applicants you\'ve created, sorted by creation date in descending order. 
     * @summary List Applicants
     * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
     * @param {number} [perPage] The number of objects per page.
     * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listApplicants(page, perPage, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single check. Returns a check object. 
     * @summary Retrieve Checks
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listChecks(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listChecks(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All documents belonging to an applicant can be listed from this endpoint
     * @summary List documents
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDocuments(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDocuments(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the ID photos that belong to an applicant. 
     * @summary List ID photos
     * @param {string} applicantId The id of the applicant the ID photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIdPhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the live photos that belong to an applicant. 
     * @summary List live photos
     * @param {string} applicantId The id of the applicant the live photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listLivePhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the live videos that belong to an applicant. 
     * @summary List live videos
     * @param {string} applicantId The id of the applicant the live videos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listLiveVideos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the motion captures that belong to an applicant. 
     * @summary List motion captures
     * @param {string} applicantId The id of the applicant the motion captures belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMotionCaptures(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns every passkey registered under the supplied username. 
     * @summary List passkeys
     * @param {string} username Username that owns the passkeys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPasskeys(username: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPasskeys(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all repeat attempts for a given Document report 
     * @summary Retrieve repeat attempts
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listRepeatAttempts(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All the reports belonging to a particular check can be listed from this endpoint. 
     * @summary List reports
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listReports(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listReports(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All signing documents belonging to an applicant can be listed from this endpoint
     * @summary List signing documents
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSigningDocuments(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listSigningDocuments(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
     * @summary List Tasks
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTasks(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTasks(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List match IDs on this monitor, as well as their enabled/disabled status 
     * @summary List matches (BETA)
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWatchlistMonitorMatches(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available monitors for an applicant 
     * @summary List monitors
     * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
     * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all webhooks you\'ve created. 
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWebhooks(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
     * @summary List Workflow Runs
     * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
     * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
     * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
     * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
     * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
     * @param {string} [applicantId] the applicant\&#39;s id.
     * @param {Array<string>} [tags] A list of tags to filter the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, applicantId?: string, tags?: Array<string>, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, applicantId, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a health check on the Onfido API 
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ping(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Feedback on checks and reports 
     * @summary Fraud reporting (ALPHA)
     * @param {ResultsFeedback} resultsFeedback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postResultsFeedback(resultsFeedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends events to all webhooks registered with a matching environment in your account. 
     * @summary Resends webhooks
     * @param {WebhookResend} webhookResend 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resendWebhooks(webhookResend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores a single applicant scheduled for deletion. 
     * @summary Restore Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).restoreApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a paused check. 
     * @summary Resume a Check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resumeCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resumeCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a single paused report. 
     * @summary Resume report
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resumeReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resumeReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
     * @summary Update Applicant
     * @param {string} applicantId 
     * @param {ApplicantUpdater} applicantUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateApplicant(applicantId: string, applicantUpdater: ApplicantUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicant(applicantId, applicantUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a passkey\'s state. 
     * @summary Update passkey
     * @param {string} username Username that owns the passkey.
     * @param {string} passkeyId Passkey ID.
     * @param {PasskeyUpdater} passkeyUpdater Passkey update payload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePasskey(username: string, passkeyId: string, passkeyUpdater: PasskeyUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updatePasskey(username, passkeyId, passkeyUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of the given matches 
     * @summary Set match status (BETA)
     * @param {string} monitorId 
     * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWatchlistMonitorMatch(monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a webhook. Returns the updated webhook object. 
     * @summary Edit a webhook
     * @param {string} webhookId 
     * @param {WebhookUpdater} webhookUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWebhook(webhookId, webhookUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
     * @summary Upload a document
     * @param {DocumentTypes} type The type of document
     * @param {string} applicantId The ID of the applicant whose document is being uploaded.
     * @param {FileTransfer} file The file to be uploaded.
     * @param {string} [fileType] The file type of the uploaded file
     * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
     * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
     * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
     * @param {LocationBuilder} [location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadDocument(type: DocumentTypes, applicantId: string, file: FileTransfer, fileType?: string, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
     * @summary Upload ID photo
     * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadIdPhoto(applicantId?: string, file?: FileTransfer, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadIdPhoto(applicantId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
     * @summary Upload live photo
     * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadLivePhoto(applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Signing documents are uploaded using this endpoint. Signing documents must be uploaded as a multipart form. The only valid file type is pdf. The file size must be between 2KB and 3MB. 
     * @summary Upload a signing document
     * @param {string} applicantId The ID of the applicant whose signing document is being uploaded.
     * @param {FileTransfer} file The file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadSigningDocument(applicantId: string, file: FileTransfer, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadSigningDocument(applicantId, file, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListWorkflowRunsSortEnum = {
    Desc: 'desc',
    Asc: 'asc',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type ListWorkflowRunsSortEnum = typeof ListWorkflowRunsSortEnum[keyof typeof ListWorkflowRunsSortEnum];
export const UploadDocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type UploadDocumentSideEnum = typeof UploadDocumentSideEnum[keyof typeof UploadDocumentSideEnum];


