/* tslint:disable */
/* eslint-disable */
/**
 * Onfido API v3.6
 * The Onfido API (v3.6)
 *
 * The version of the OpenAPI document: v3.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

import { FileTransfer } from './file-transfer';
import { AxiosHeaders } from 'axios';

globalAxios.interceptors.response.use(async (response) => {
    if (response.headers instanceof AxiosHeaders && response.headers['content-type']) {
        if ( ! response.headers['content-type'].toString().includes('application/json') ) {
            const contentDisposition = response.headers['content-disposition'];
            var filename = "";

            if (contentDisposition && contentDisposition != "") {
                const matcher = contentDisposition.match(/filename=['\"]?([^'\"\s]+)['\"]?/);

                if (matcher != null) {
                  filename = matcher[1].replace(/.*[/\\\\]/g, "");
                }
            }

            response.data = new FileTransfer(response.data, filename);
        }
    }

    return response;
  });


/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * The flat number of this address
     * @type {string}
     * @memberof Address
     */
    'flat_number'?: string;
    /**
     * The building number of this address
     * @type {string}
     * @memberof Address
     */
    'building_number'?: string;
    /**
     * The building name of this address
     * @type {string}
     * @memberof Address
     */
    'building_name'?: string;
    /**
     * The street of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'street'?: string;
    /**
     * The sub-street of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'sub_street'?: string;
    /**
     * The town of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'town'?: string;
    /**
     * The postcode or ZIP of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'postcode': string;
    /**
     * The 3 character ISO country code of this address. For example, GBR is the country code for the United Kingdom
     * @type {CountryCodes}
     * @memberof Address
     */
    'country': CountryCodes;
    /**
     * The address state. US states must use the USPS abbreviation (see also ISO 3166-2:US), for example AK, CA, or TX.
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * Line 1 of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'line1'?: string | null;
    /**
     * Line 2 of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'line2'?: string | null;
    /**
     * Line 3 of the applicant\'s address
     * @type {string}
     * @memberof Address
     */
    'line3'?: string | null;
}


/**
 * 
 * @export
 * @interface AddressBuilder
 */
export interface AddressBuilder {
    /**
     * The flat number of this address
     * @type {string}
     * @memberof AddressBuilder
     */
    'flat_number'?: string;
    /**
     * The building number of this address
     * @type {string}
     * @memberof AddressBuilder
     */
    'building_number'?: string;
    /**
     * The building name of this address
     * @type {string}
     * @memberof AddressBuilder
     */
    'building_name'?: string;
    /**
     * The street of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'street'?: string;
    /**
     * The sub-street of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'sub_street'?: string;
    /**
     * The town of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'town'?: string;
    /**
     * The postcode or ZIP of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'postcode': string;
    /**
     * The 3 character ISO country code of this address. For example, GBR is the country code for the United Kingdom
     * @type {CountryCodes}
     * @memberof AddressBuilder
     */
    'country': CountryCodes;
    /**
     * The address state. US states must use the USPS abbreviation (see also ISO 3166-2:US), for example AK, CA, or TX.
     * @type {string}
     * @memberof AddressBuilder
     */
    'state'?: string;
    /**
     * Line 1 of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'line1'?: string | null;
    /**
     * Line 2 of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'line2'?: string | null;
    /**
     * Line 3 of the applicant\'s address
     * @type {string}
     * @memberof AddressBuilder
     */
    'line3'?: string | null;
}


/**
 * 
 * @export
 * @interface AddressShared
 */
export interface AddressShared {
    /**
     * The flat number of this address
     * @type {string}
     * @memberof AddressShared
     */
    'flat_number'?: string;
    /**
     * The building number of this address
     * @type {string}
     * @memberof AddressShared
     */
    'building_number'?: string;
    /**
     * The building name of this address
     * @type {string}
     * @memberof AddressShared
     */
    'building_name'?: string;
    /**
     * The street of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'street'?: string;
    /**
     * The sub-street of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'sub_street'?: string;
    /**
     * The town of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'town'?: string;
    /**
     * The postcode or ZIP of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'postcode': string;
    /**
     * The 3 character ISO country code of this address. For example, GBR is the country code for the United Kingdom
     * @type {CountryCodes}
     * @memberof AddressShared
     */
    'country': CountryCodes;
    /**
     * The address state. US states must use the USPS abbreviation (see also ISO 3166-2:US), for example AK, CA, or TX.
     * @type {string}
     * @memberof AddressShared
     */
    'state'?: string;
    /**
     * Line 1 of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'line1'?: string | null;
    /**
     * Line 2 of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'line2'?: string | null;
    /**
     * Line 3 of the applicant\'s address
     * @type {string}
     * @memberof AddressShared
     */
    'line3'?: string | null;
}


/**
 * 
 * @export
 * @interface AddressesList
 */
export interface AddressesList {
    /**
     * 
     * @type {Array<Address>}
     * @memberof AddressesList
     */
    'addresses'?: Array<Address>;
}
/**
 * 
 * @export
 * @interface Applicant
 */
export interface Applicant {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     * @type {string}
     * @memberof Applicant
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     * @type {string}
     * @memberof Applicant
     */
    'dob'?: string;
    /**
     * 
     * @type {Array<IdNumber>}
     * @memberof Applicant
     */
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     * @type {string}
     * @memberof Applicant
     */
    'phone_number'?: string;
    /**
     * The applicant\'s first name
     * @type {string}
     * @memberof Applicant
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     * @type {string}
     * @memberof Applicant
     */
    'last_name'?: string;
    /**
     * The unique identifier for the applicant.
     * @type {string}
     * @memberof Applicant
     */
    'id': string;
    /**
     * The date and time when this applicant was created.
     * @type {string}
     * @memberof Applicant
     */
    'created_at'?: string;
    /**
     * The date and time when this applicant is scheduled to be deleted.
     * @type {string}
     * @memberof Applicant
     */
    'delete_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof Applicant
     */
    'href'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Applicant
     */
    'sandbox'?: boolean;
    /**
     * 
     * @type {Address}
     * @memberof Applicant
     */
    'address'?: Address;
    /**
     * 
     * @type {Location}
     * @memberof Applicant
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ApplicantBuilder
 */
export interface ApplicantBuilder {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     * @type {string}
     * @memberof ApplicantBuilder
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     * @type {string}
     * @memberof ApplicantBuilder
     */
    'dob'?: string;
    /**
     * 
     * @type {Array<IdNumber>}
     * @memberof ApplicantBuilder
     */
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     * @type {string}
     * @memberof ApplicantBuilder
     */
    'phone_number'?: string;
    /**
     * 
     * @type {ConsentsBuilder}
     * @memberof ApplicantBuilder
     */
    'consents'?: ConsentsBuilder;
    /**
     * 
     * @type {AddressBuilder}
     * @memberof ApplicantBuilder
     */
    'address'?: AddressBuilder;
    /**
     * 
     * @type {LocationBuilder}
     * @memberof ApplicantBuilder
     */
    'location'?: LocationBuilder;
    /**
     * The applicant\'s first name
     * @type {string}
     * @memberof ApplicantBuilder
     */
    'first_name': string;
    /**
     * The applicant\'s surname
     * @type {string}
     * @memberof ApplicantBuilder
     */
    'last_name': string;
}
/**
 * 
 * @export
 * @interface ApplicantCreate
 */
export interface ApplicantCreate {
    /**
     * The applicant\'s first name
     * @type {string}
     * @memberof ApplicantCreate
     */
    'first_name': string;
    /**
     * The applicant\'s surname
     * @type {string}
     * @memberof ApplicantCreate
     */
    'last_name': string;
}
/**
 * 
 * @export
 * @interface ApplicantRequest
 */
export interface ApplicantRequest {
    /**
     * 
     * @type {ConsentsBuilder}
     * @memberof ApplicantRequest
     */
    'consents'?: ConsentsBuilder;
    /**
     * 
     * @type {AddressBuilder}
     * @memberof ApplicantRequest
     */
    'address'?: AddressBuilder;
    /**
     * 
     * @type {LocationBuilder}
     * @memberof ApplicantRequest
     */
    'location'?: LocationBuilder;
}
/**
 * 
 * @export
 * @interface ApplicantResponse
 */
export interface ApplicantResponse {
    /**
     * The applicant\'s first name
     * @type {string}
     * @memberof ApplicantResponse
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     * @type {string}
     * @memberof ApplicantResponse
     */
    'last_name'?: string;
    /**
     * The unique identifier for the applicant.
     * @type {string}
     * @memberof ApplicantResponse
     */
    'id': string;
    /**
     * The date and time when this applicant was created.
     * @type {string}
     * @memberof ApplicantResponse
     */
    'created_at'?: string;
    /**
     * The date and time when this applicant is scheduled to be deleted.
     * @type {string}
     * @memberof ApplicantResponse
     */
    'delete_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof ApplicantResponse
     */
    'href'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicantResponse
     */
    'sandbox'?: boolean;
    /**
     * 
     * @type {Address}
     * @memberof ApplicantResponse
     */
    'address'?: Address;
    /**
     * 
     * @type {Location}
     * @memberof ApplicantResponse
     */
    'location'?: Location;
}
/**
 * 
 * @export
 * @interface ApplicantShared
 */
export interface ApplicantShared {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     * @type {string}
     * @memberof ApplicantShared
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     * @type {string}
     * @memberof ApplicantShared
     */
    'dob'?: string;
    /**
     * 
     * @type {Array<IdNumber>}
     * @memberof ApplicantShared
     */
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     * @type {string}
     * @memberof ApplicantShared
     */
    'phone_number'?: string;
}
/**
 * 
 * @export
 * @interface ApplicantUpdate
 */
export interface ApplicantUpdate {
    /**
     * The applicant\'s first name
     * @type {string}
     * @memberof ApplicantUpdate
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     * @type {string}
     * @memberof ApplicantUpdate
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface ApplicantUpdater
 */
export interface ApplicantUpdater {
    /**
     * The applicant\'s email address. Required if doing a US check, or a UK check for which `applicant_provides_data` is `true`.
     * @type {string}
     * @memberof ApplicantUpdater
     */
    'email'?: string;
    /**
     * The applicant\'s date of birth
     * @type {string}
     * @memberof ApplicantUpdater
     */
    'dob'?: string;
    /**
     * 
     * @type {Array<IdNumber>}
     * @memberof ApplicantUpdater
     */
    'id_numbers'?: Array<IdNumber>;
    /**
     * The applicant\'s phone number
     * @type {string}
     * @memberof ApplicantUpdater
     */
    'phone_number'?: string;
    /**
     * 
     * @type {ConsentsBuilder}
     * @memberof ApplicantUpdater
     */
    'consents'?: ConsentsBuilder;
    /**
     * 
     * @type {AddressBuilder}
     * @memberof ApplicantUpdater
     */
    'address'?: AddressBuilder;
    /**
     * 
     * @type {LocationBuilder}
     * @memberof ApplicantUpdater
     */
    'location'?: LocationBuilder;
    /**
     * The applicant\'s first name
     * @type {string}
     * @memberof ApplicantUpdater
     */
    'first_name'?: string;
    /**
     * The applicant\'s surname
     * @type {string}
     * @memberof ApplicantUpdater
     */
    'last_name'?: string;
}
/**
 * 
 * @export
 * @interface ApplicantsList
 */
export interface ApplicantsList {
    /**
     * 
     * @type {Array<Applicant>}
     * @memberof ApplicantsList
     */
    'applicants': Array<Applicant>;
}
/**
 * 
 * @export
 * @interface Check
 */
export interface Check {
    /**
     * An array of webhook ids describing which webhooks to trigger for this check.
     * @type {Array<string>}
     * @memberof Check
     */
    'webhook_ids'?: Array<string>;
    /**
     * The ID of the applicant to do the check on.
     * @type {string}
     * @memberof Check
     */
    'applicant_id': string;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false. 
     * @type {boolean}
     * @memberof Check
     */
    'applicant_provides_data'?: boolean;
    /**
     * Array of tags being assigned to this check.
     * @type {Array<string>}
     * @memberof Check
     */
    'tags'?: Array<string>;
    /**
     * For checks where `applicant_provides_data` is `true`, redirect to this URI when the applicant has submitted their data.
     * @type {string}
     * @memberof Check
     */
    'redirect_uri'?: string;
    /**
     * The unique identifier for the check.
     * @type {string}
     * @memberof Check
     */
    'id': string;
    /**
     * The date and time when this check was created.
     * @type {string}
     * @memberof Check
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof Check
     */
    'href'?: string;
    /**
     * The current state of the check in the checking process.
     * @type {string}
     * @memberof Check
     */
    'status'?: CheckStatusEnum;
    /**
     * The overall result of the check, based on the results of the constituent reports.
     * @type {string}
     * @memberof Check
     */
    'result'?: CheckResultEnum;
    /**
     * A link to the applicant form, if `applicant_provides_data` is `true`.
     * @type {string}
     * @memberof Check
     */
    'form_uri'?: string;
    /**
     * A link to the corresponding results page on the Onfido dashboard.
     * @type {string}
     * @memberof Check
     */
    'results_uri'?: string;
    /**
     * An array of report ids.
     * @type {Array<string>}
     * @memberof Check
     */
    'report_ids'?: Array<string>;
    /**
     * Indicates whether the object was created in the sandbox or not.
     * @type {boolean}
     * @memberof Check
     */
    'sandbox'?: boolean;
}

export const CheckStatusEnum = {
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckStatusEnum = typeof CheckStatusEnum[keyof typeof CheckStatusEnum];
export const CheckResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckResultEnum = typeof CheckResultEnum[keyof typeof CheckResultEnum];

/**
 * 
 * @export
 * @interface CheckBuilder
 */
export interface CheckBuilder {
    /**
     * An array of webhook ids describing which webhooks to trigger for this check.
     * @type {Array<string>}
     * @memberof CheckBuilder
     */
    'webhook_ids'?: Array<string>;
    /**
     * The ID of the applicant to do the check on.
     * @type {string}
     * @memberof CheckBuilder
     */
    'applicant_id': string;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false.
     * @type {boolean}
     * @memberof CheckBuilder
     */
    'applicant_provides_data'?: boolean;
    /**
     * Array of tags being assigned to this check.
     * @type {Array<string>}
     * @memberof CheckBuilder
     */
    'tags'?: Array<string>;
    /**
     * For checks where `applicant_provides_data` is `true`, redirect to this URI when the applicant has submitted their data.
     * @type {string}
     * @memberof CheckBuilder
     */
    'redirect_uri'?: string;
    /**
     * An array of report names (strings).
     * @type {Array<ReportName>}
     * @memberof CheckBuilder
     */
    'report_names': Array<ReportName>;
    /**
     * Optional. An array of document ids, for use with Document reports only. If omitted, the Document report will use the most recently uploaded document by default.
     * @type {Array<string>}
     * @memberof CheckBuilder
     */
    'document_ids'?: Array<string>;
    /**
     * Defaults to `true`. If set to `false`, you will only receive a response when all reports in your check have completed. 
     * @type {boolean}
     * @memberof CheckBuilder
     */
    'asynchronous'?: boolean;
    /**
     * For checks where `applicant_provides_data` is `true`, applicant form will not be automatically sent if `suppress_form_emails` is set to `true`. You can manually send the form at any time after the check has been created, using the link found in the form_uri attribute of the check object. Write-only. Defaults to false. 
     * @type {boolean}
     * @memberof CheckBuilder
     */
    'suppress_form_emails'?: boolean;
    /**
     * Triggers responses for particular sub-results for sandbox Document reports.
     * @type {string}
     * @memberof CheckBuilder
     */
    'sub_result'?: string;
    /**
     * Array of names of particular reports to return consider as their results. This is a feature available in sandbox testing
     * @type {Array<ReportName>}
     * @memberof CheckBuilder
     */
    'consider'?: Array<ReportName>;
    /**
     * 
     * @type {UsDrivingLicenceBuilder}
     * @memberof CheckBuilder
     */
    'us_driving_licence'?: UsDrivingLicenceBuilder;
}
/**
 * 
 * @export
 * @interface CheckRequest
 */
export interface CheckRequest {
    /**
     * An array of report names (strings).
     * @type {Array<ReportName>}
     * @memberof CheckRequest
     */
    'report_names': Array<ReportName>;
    /**
     * Optional. An array of document ids, for use with Document reports only. If omitted, the Document report will use the most recently uploaded document by default.
     * @type {Array<string>}
     * @memberof CheckRequest
     */
    'document_ids'?: Array<string>;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false.
     * @type {boolean}
     * @memberof CheckRequest
     */
    'applicant_provides_data'?: boolean;
    /**
     * Defaults to `true`. If set to `false`, you will only receive a response when all reports in your check have completed. 
     * @type {boolean}
     * @memberof CheckRequest
     */
    'asynchronous'?: boolean;
    /**
     * For checks where `applicant_provides_data` is `true`, applicant form will not be automatically sent if `suppress_form_emails` is set to `true`. You can manually send the form at any time after the check has been created, using the link found in the form_uri attribute of the check object. Write-only. Defaults to false. 
     * @type {boolean}
     * @memberof CheckRequest
     */
    'suppress_form_emails'?: boolean;
    /**
     * Triggers responses for particular sub-results for sandbox Document reports.
     * @type {string}
     * @memberof CheckRequest
     */
    'sub_result'?: string;
    /**
     * Array of names of particular reports to return consider as their results. This is a feature available in sandbox testing
     * @type {Array<ReportName>}
     * @memberof CheckRequest
     */
    'consider'?: Array<ReportName>;
    /**
     * 
     * @type {UsDrivingLicenceBuilder}
     * @memberof CheckRequest
     */
    'us_driving_licence'?: UsDrivingLicenceBuilder;
}
/**
 * 
 * @export
 * @interface CheckResponse
 */
export interface CheckResponse {
    /**
     * The unique identifier for the check.
     * @type {string}
     * @memberof CheckResponse
     */
    'id': string;
    /**
     * The date and time when this check was created.
     * @type {string}
     * @memberof CheckResponse
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof CheckResponse
     */
    'href'?: string;
    /**
     * The current state of the check in the checking process.
     * @type {string}
     * @memberof CheckResponse
     */
    'status'?: CheckResponseStatusEnum;
    /**
     * The overall result of the check, based on the results of the constituent reports.
     * @type {string}
     * @memberof CheckResponse
     */
    'result'?: CheckResponseResultEnum;
    /**
     * A link to the applicant form, if `applicant_provides_data` is `true`.
     * @type {string}
     * @memberof CheckResponse
     */
    'form_uri'?: string;
    /**
     * A link to the corresponding results page on the Onfido dashboard.
     * @type {string}
     * @memberof CheckResponse
     */
    'results_uri'?: string;
    /**
     * An array of report ids.
     * @type {Array<string>}
     * @memberof CheckResponse
     */
    'report_ids'?: Array<string>;
    /**
     * Indicates whether the object was created in the sandbox or not.
     * @type {boolean}
     * @memberof CheckResponse
     */
    'sandbox'?: boolean;
}

export const CheckResponseStatusEnum = {
    InProgress: 'in_progress',
    AwaitingApplicant: 'awaiting_applicant',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    Paused: 'paused',
    Reopened: 'reopened',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckResponseStatusEnum = typeof CheckResponseStatusEnum[keyof typeof CheckResponseStatusEnum];
export const CheckResponseResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CheckResponseResultEnum = typeof CheckResponseResultEnum[keyof typeof CheckResponseResultEnum];

/**
 * 
 * @export
 * @interface CheckShared
 */
export interface CheckShared {
    /**
     * An array of webhook ids describing which webhooks to trigger for this check.
     * @type {Array<string>}
     * @memberof CheckShared
     */
    'webhook_ids'?: Array<string>;
    /**
     * The ID of the applicant to do the check on.
     * @type {string}
     * @memberof CheckShared
     */
    'applicant_id': string;
    /**
     * Send an applicant form to applicant to complete to proceed with check. Defaults to false. 
     * @type {boolean}
     * @memberof CheckShared
     */
    'applicant_provides_data'?: boolean;
    /**
     * Array of tags being assigned to this check.
     * @type {Array<string>}
     * @memberof CheckShared
     */
    'tags'?: Array<string>;
    /**
     * For checks where `applicant_provides_data` is `true`, redirect to this URI when the applicant has submitted their data.
     * @type {string}
     * @memberof CheckShared
     */
    'redirect_uri'?: string;
}
/**
 * 
 * @export
 * @interface ChecksList
 */
export interface ChecksList {
    /**
     * 
     * @type {Array<Check>}
     * @memberof ChecksList
     */
    'checks': Array<Check>;
}
/**
 * 
 * @export
 * @interface CompleteTaskBuilder
 */
export interface CompleteTaskBuilder {
    /**
     * 
     * @type {CompleteTaskDataBuilder}
     * @memberof CompleteTaskBuilder
     */
    'data': CompleteTaskDataBuilder;
}
/**
 * @type CompleteTaskDataBuilder
 * The Task completion payload.
 * @export
 */
export type CompleteTaskDataBuilder = Array<object> | object;

/**
 * The applicant\'s consents
 * @export
 * @interface ConsentItem
 */
export interface ConsentItem {
    /**
     * 
     * @type {string}
     * @memberof ConsentItem
     */
    'name': ConsentItemNameEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ConsentItem
     */
    'granted': boolean;
}

export const ConsentItemNameEnum = {
    PrivacyNoticesRead: 'privacy_notices_read',
    SsnVerification: 'ssn_verification',
    PhoneNumberVerification: 'phone_number_verification',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ConsentItemNameEnum = typeof ConsentItemNameEnum[keyof typeof ConsentItemNameEnum];

/**
 * 
 * @export
 * @interface ConsentsBuilder
 */
export interface ConsentsBuilder {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CountryCodes = {
    Abw: 'ABW',
    Afg: 'AFG',
    Ago: 'AGO',
    Aia: 'AIA',
    Ala: 'ALA',
    Alb: 'ALB',
    And: 'AND',
    Are: 'ARE',
    Arg: 'ARG',
    Arm: 'ARM',
    Asm: 'ASM',
    Ata: 'ATA',
    Atf: 'ATF',
    Atg: 'ATG',
    Aus: 'AUS',
    Aut: 'AUT',
    Aze: 'AZE',
    Bdi: 'BDI',
    Bel: 'BEL',
    Ben: 'BEN',
    Bes: 'BES',
    Bfa: 'BFA',
    Bgd: 'BGD',
    Bgr: 'BGR',
    Bhr: 'BHR',
    Bhs: 'BHS',
    Bih: 'BIH',
    Blm: 'BLM',
    Blr: 'BLR',
    Blz: 'BLZ',
    Bmu: 'BMU',
    Bol: 'BOL',
    Bra: 'BRA',
    Brb: 'BRB',
    Brn: 'BRN',
    Btn: 'BTN',
    Bvt: 'BVT',
    Bwa: 'BWA',
    Caf: 'CAF',
    Can: 'CAN',
    Cck: 'CCK',
    Che: 'CHE',
    Chl: 'CHL',
    Chn: 'CHN',
    Civ: 'CIV',
    Cmr: 'CMR',
    Cod: 'COD',
    Cog: 'COG',
    Cok: 'COK',
    Col: 'COL',
    Com: 'COM',
    Cpv: 'CPV',
    Cri: 'CRI',
    Cub: 'CUB',
    Cuw: 'CUW',
    Cxr: 'CXR',
    Cym: 'CYM',
    Cyp: 'CYP',
    Cze: 'CZE',
    Deu: 'DEU',
    Dji: 'DJI',
    Dma: 'DMA',
    Dnk: 'DNK',
    Dom: 'DOM',
    Dza: 'DZA',
    Ecu: 'ECU',
    Egy: 'EGY',
    Eri: 'ERI',
    Esh: 'ESH',
    Esp: 'ESP',
    Est: 'EST',
    Eth: 'ETH',
    Fin: 'FIN',
    Fji: 'FJI',
    Flk: 'FLK',
    Fra: 'FRA',
    Fro: 'FRO',
    Fsm: 'FSM',
    Gab: 'GAB',
    Gbr: 'GBR',
    Geo: 'GEO',
    Ggy: 'GGY',
    Gha: 'GHA',
    Gib: 'GIB',
    Gin: 'GIN',
    Glp: 'GLP',
    Gmb: 'GMB',
    Gnb: 'GNB',
    Gnq: 'GNQ',
    Grc: 'GRC',
    Grd: 'GRD',
    Grl: 'GRL',
    Gtm: 'GTM',
    Guf: 'GUF',
    Gum: 'GUM',
    Guy: 'GUY',
    Hkg: 'HKG',
    Hmd: 'HMD',
    Hnd: 'HND',
    Hrv: 'HRV',
    Hti: 'HTI',
    Hun: 'HUN',
    Idn: 'IDN',
    Imn: 'IMN',
    Ind: 'IND',
    Iot: 'IOT',
    Irl: 'IRL',
    Irn: 'IRN',
    Irq: 'IRQ',
    Isl: 'ISL',
    Isr: 'ISR',
    Ita: 'ITA',
    Jam: 'JAM',
    Jey: 'JEY',
    Jor: 'JOR',
    Jpn: 'JPN',
    Kaz: 'KAZ',
    Ken: 'KEN',
    Kgz: 'KGZ',
    Khm: 'KHM',
    Kir: 'KIR',
    Kna: 'KNA',
    Kor: 'KOR',
    Kwt: 'KWT',
    Lao: 'LAO',
    Lbn: 'LBN',
    Lbr: 'LBR',
    Lby: 'LBY',
    Lca: 'LCA',
    Lie: 'LIE',
    Lka: 'LKA',
    Lso: 'LSO',
    Ltu: 'LTU',
    Lux: 'LUX',
    Lva: 'LVA',
    Mac: 'MAC',
    Maf: 'MAF',
    Mar: 'MAR',
    Mco: 'MCO',
    Mda: 'MDA',
    Mdg: 'MDG',
    Mdv: 'MDV',
    Mex: 'MEX',
    Mhl: 'MHL',
    Mkd: 'MKD',
    Mli: 'MLI',
    Mlt: 'MLT',
    Mmr: 'MMR',
    Mne: 'MNE',
    Mng: 'MNG',
    Mnp: 'MNP',
    Moz: 'MOZ',
    Mrt: 'MRT',
    Msr: 'MSR',
    Mtq: 'MTQ',
    Mus: 'MUS',
    Mwi: 'MWI',
    Mys: 'MYS',
    Myt: 'MYT',
    Nam: 'NAM',
    Ncl: 'NCL',
    Ner: 'NER',
    Nfk: 'NFK',
    Nga: 'NGA',
    Nic: 'NIC',
    Niu: 'NIU',
    Nld: 'NLD',
    Nor: 'NOR',
    Npl: 'NPL',
    Nru: 'NRU',
    Nzl: 'NZL',
    Omn: 'OMN',
    Pak: 'PAK',
    Pan: 'PAN',
    Pcn: 'PCN',
    Per: 'PER',
    Phl: 'PHL',
    Plw: 'PLW',
    Png: 'PNG',
    Pol: 'POL',
    Pri: 'PRI',
    Prk: 'PRK',
    Prt: 'PRT',
    Pry: 'PRY',
    Pse: 'PSE',
    Pyf: 'PYF',
    Qat: 'QAT',
    Reu: 'REU',
    Rks: 'RKS',
    Rou: 'ROU',
    Rus: 'RUS',
    Rwa: 'RWA',
    Sau: 'SAU',
    Sdn: 'SDN',
    Sen: 'SEN',
    Sgp: 'SGP',
    Sgs: 'SGS',
    Shn: 'SHN',
    Sjm: 'SJM',
    Slb: 'SLB',
    Sle: 'SLE',
    Slv: 'SLV',
    Smr: 'SMR',
    Som: 'SOM',
    Spm: 'SPM',
    Srb: 'SRB',
    Ssd: 'SSD',
    Stp: 'STP',
    Sur: 'SUR',
    Svk: 'SVK',
    Svn: 'SVN',
    Swe: 'SWE',
    Swz: 'SWZ',
    Sxm: 'SXM',
    Syc: 'SYC',
    Syr: 'SYR',
    Tca: 'TCA',
    Tcd: 'TCD',
    Tgo: 'TGO',
    Tha: 'THA',
    Tjk: 'TJK',
    Tkl: 'TKL',
    Tkm: 'TKM',
    Tls: 'TLS',
    Ton: 'TON',
    Tto: 'TTO',
    Tun: 'TUN',
    Tur: 'TUR',
    Tuv: 'TUV',
    Twn: 'TWN',
    Tza: 'TZA',
    Uga: 'UGA',
    Ukr: 'UKR',
    Umi: 'UMI',
    Ury: 'URY',
    Usa: 'USA',
    Uzb: 'UZB',
    Vat: 'VAT',
    Vct: 'VCT',
    Ven: 'VEN',
    Vgb: 'VGB',
    Vir: 'VIR',
    Vnm: 'VNM',
    Vut: 'VUT',
    Wlf: 'WLF',
    Wsm: 'WSM',
    Yem: 'YEM',
    Zaf: 'ZAF',
    Zmb: 'ZMB',
    Zwe: 'ZWE',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type CountryCodes = typeof CountryCodes[keyof typeof CountryCodes];


/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdown
 */
export interface DeviceIntelligenceBreakdown {
    /**
     * 
     * @type {DeviceIntelligenceBreakdownBreakdown}
     * @memberof DeviceIntelligenceBreakdown
     */
    'breakdown'?: DeviceIntelligenceBreakdownBreakdown;
    /**
     * 
     * @type {DeviceIntelligenceBreakdownProperties}
     * @memberof DeviceIntelligenceBreakdown
     */
    'properties'?: DeviceIntelligenceBreakdownProperties;
}
/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdownBreakdown
 */
export interface DeviceIntelligenceBreakdownBreakdown {
    /**
     * 
     * @type {DeviceIntelligenceBreakdownBreakdownDevice}
     * @memberof DeviceIntelligenceBreakdownBreakdown
     */
    'device'?: DeviceIntelligenceBreakdownBreakdownDevice;
}
/**
 * Asserts whether the device used to upload the media is trustworthy, i.e. it is a real, physical device.
 * @export
 * @interface DeviceIntelligenceBreakdownBreakdownDevice
 */
export interface DeviceIntelligenceBreakdownBreakdownDevice {
    /**
     * 
     * @type {DeviceIntelligenceBreakdownBreakdownDeviceBreakdown}
     * @memberof DeviceIntelligenceBreakdownBreakdownDevice
     */
    'breakdown'?: DeviceIntelligenceBreakdownBreakdownDeviceBreakdown;
}
/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdownBreakdownDeviceBreakdown
 */
export interface DeviceIntelligenceBreakdownBreakdownDeviceBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DeviceIntelligenceBreakdownBreakdownDeviceBreakdown
     */
    'application_authenticity'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DeviceIntelligenceBreakdownBreakdownDeviceBreakdown
     */
    'device_integrity'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DeviceIntelligenceBreakdownBreakdownDeviceBreakdown
     */
    'device_reputation'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdownProperties
 */
export interface DeviceIntelligenceBreakdownProperties {
    /**
     * 
     * @type {DeviceIntelligenceBreakdownPropertiesDevice}
     * @memberof DeviceIntelligenceBreakdownProperties
     */
    'device'?: DeviceIntelligenceBreakdownPropertiesDevice;
    /**
     * 
     * @type {DeviceIntelligenceBreakdownPropertiesIp}
     * @memberof DeviceIntelligenceBreakdownProperties
     */
    'ip'?: DeviceIntelligenceBreakdownPropertiesIp;
    /**
     * 
     * @type {DeviceIntelligenceBreakdownPropertiesGeolocation}
     * @memberof DeviceIntelligenceBreakdownProperties
     */
    'geolocation'?: DeviceIntelligenceBreakdownPropertiesGeolocation;
}
/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdownPropertiesDevice
 */
export interface DeviceIntelligenceBreakdownPropertiesDevice {
    /**
     * The SDK version that was used.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'sdk_version'?: string;
    /**
     * The SDK used to upload the media.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'sdk_source'?: DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum;
    /**
     * The token used to authenticate the request.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'authentication_type'?: DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum;
    /**
     * The model as set by the phone manufacturer (for Android and iOS) or the browser manufacturer (for Web). The model can be presented in name or number form depending on each manufacturer implementation.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'raw_model'?: string;
    /**
     * The operating system of the device. The value came from manufacturer implementation (for Android and iOS) or browser\'s user agent (for Web).
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'os'?: string;
    /**
     * The browser name reported by the browser\'s user agent.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'browser'?: string;
    /**
     * Whether the device is an emulator.
     * @type {boolean}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'emulator'?: boolean;
    /**
     * Whether the device is providing false randomized device and network information.
     * @type {boolean}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'randomized_device'?: boolean;
    /**
     * Whether device is using stolen security tokens to send the network information.
     * @type {boolean}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'fake_network_request'?: boolean;
    /**
     * The true operating system of the device.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     * @deprecated
     */
    'true_os'?: string;
    /**
     * The likelihood of an operating system anomaly between the true OS and the OS sent by the device.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     * @deprecated
     */
    'os_anomaly'?: string;
    /**
     * Whether the device is rooted.
     * @type {boolean}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     * @deprecated
     */
    'rooted'?: boolean;
    /**
     * Whether the device is controlled via remote software.
     * @type {boolean}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     * @deprecated
     */
    'remote_software'?: boolean;
    /**
     * Whether there is highly suspicious traffic related to the IP address. The risk depends on the overall ratio of clear checks on a given IP.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'ip_reputation'?: DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum;
    /**
     * The number of times the device was used to create a report for a new applicant. A value greater than 1 indicates potential device reuse.
     * @type {number}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'device_fingerprint_reuse'?: number;
    /**
     * Whether the document or biometric media were uploaded from a single device.
     * @type {boolean}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'single_device_used'?: boolean | null;
    /**
     * Whether the document media were live captured from the device camera.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'document_capture'?: DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum;
    /**
     * Whether the biometric media were live captured from the device camera.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesDevice
     */
    'biometric_capture'?: DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum;
}

export const DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = {
    AndroidSdk: 'onfido-android-sdk',
    IosSdk: 'onfido-ios-sdk',
    WebSdk: 'onfido-web-sdk',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceSdkSourceEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = {
    SdkToken: 'sdk_token',
    MobileToken: 'mobile_token',
    ApiToken: 'api_token',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceAuthenticationTypeEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = {
    NotEnoughData: 'NOT_ENOUGH_DATA',
    HighRisk: 'HIGH_RISK',
    LowRisk: 'LOW_RISK',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceIpReputationEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceDocumentCaptureEnum];
export const DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = {
    Live: 'live',
    UnknownMethod: 'unknown_method',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum = typeof DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum[keyof typeof DeviceIntelligenceBreakdownPropertiesDeviceBiometricCaptureEnum];

/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdownPropertiesGeolocation
 */
export interface DeviceIntelligenceBreakdownPropertiesGeolocation {
    /**
     * City location of the IP address.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesGeolocation
     */
    'city'?: string;
    /**
     * Region location of the IP address.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesGeolocation
     */
    'region'?: string;
    /**
     * Country location of the IP address in a three letter format.
     * @type {CountryCodes}
     * @memberof DeviceIntelligenceBreakdownPropertiesGeolocation
     */
    'country'?: CountryCodes;
}


/**
 * 
 * @export
 * @interface DeviceIntelligenceBreakdownPropertiesIp
 */
export interface DeviceIntelligenceBreakdownPropertiesIp {
    /**
     * The IP address that uploaded the media.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesIp
     */
    'address'?: string;
    /**
     * The likelihood of the network connection being a VPN.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesIp
     * @deprecated
     */
    'vpn_detection'?: string;
    /**
     * The likelihood of the network connection being a Proxy.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesIp
     * @deprecated
     */
    'proxy_detection'?: string;
    /**
     * The type of organization that owns this IP address.
     * @type {string}
     * @memberof DeviceIntelligenceBreakdownPropertiesIp
     * @deprecated
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DeviceIntelligenceReport
 */
export interface DeviceIntelligenceReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DeviceIntelligenceReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DeviceIntelligenceReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DeviceIntelligenceReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DeviceIntelligenceReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DeviceIntelligenceReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DeviceIntelligenceReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DeviceIntelligenceReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DeviceIntelligenceReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DeviceIntelligenceReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DeviceIntelligenceBreakdown}
     * @memberof DeviceIntelligenceReport
     */
    'breakdown'?: DeviceIntelligenceBreakdown;
}


/**
 * 
 * @export
 * @interface Document
 */
export interface Document {
    /**
     * The file type of the uploaded file
     * @type {string}
     * @memberof Document
     */
    'file_type'?: DocumentFileTypeEnum;
    /**
     * The type of document
     * @type {string}
     * @memberof Document
     */
    'type'?: string;
    /**
     * The side of the document, if applicable. The possible values are front and back
     * @type {string}
     * @memberof Document
     */
    'side'?: DocumentSideEnum;
    /**
     * The issuing country of the document, a 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof Document
     */
    'issuing_country'?: CountryCodes;
    /**
     * The ID of the applicant whose document is being uploaded.
     * @type {string}
     * @memberof Document
     */
    'applicant_id'?: string;
    /**
     * The unique identifier for the document
     * @type {string}
     * @memberof Document
     */
    'id': string;
    /**
     * The date and time at which the document was uploaded
     * @type {string}
     * @memberof Document
     */
    'created_at'?: string;
    /**
     * The uri of this resource
     * @type {string}
     * @memberof Document
     */
    'href'?: string;
    /**
     * The uri that can be used to download the document
     * @type {string}
     * @memberof Document
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file
     * @type {string}
     * @memberof Document
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     * @type {number}
     * @memberof Document
     */
    'file_size'?: number;
}

export const DocumentFileTypeEnum = {
    Jpg: 'jpg',
    Jpeg: 'jpeg',
    Png: 'png',
    Pdf: 'pdf',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentFileTypeEnum = typeof DocumentFileTypeEnum[keyof typeof DocumentFileTypeEnum];
export const DocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentSideEnum = typeof DocumentSideEnum[keyof typeof DocumentSideEnum];

/**
 * 
 * @export
 * @interface DocumentBreakdown
 */
export interface DocumentBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparison}
     * @memberof DocumentBreakdown
     */
    'data_comparison'?: DocumentBreakdownDataComparison;
    /**
     * 
     * @type {DocumentBreakdownDataValidation}
     * @memberof DocumentBreakdown
     */
    'data_validation'?: DocumentBreakdownDataValidation;
    /**
     * 
     * @type {DocumentBreakdownImageIntegrity}
     * @memberof DocumentBreakdown
     */
    'image_integrity'?: DocumentBreakdownImageIntegrity;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticity}
     * @memberof DocumentBreakdown
     */
    'visual_authenticity'?: DocumentBreakdownVisualAuthenticity;
    /**
     * 
     * @type {DocumentBreakdownDataConsistency}
     * @memberof DocumentBreakdown
     */
    'data_consistency'?: DocumentBreakdownDataConsistency;
    /**
     * 
     * @type {DocumentBreakdownPoliceRecord}
     * @memberof DocumentBreakdown
     */
    'police_record'?: DocumentBreakdownPoliceRecord;
    /**
     * 
     * @type {DocumentBreakdownCompromisedDocument}
     * @memberof DocumentBreakdown
     */
    'compromised_document'?: DocumentBreakdownCompromisedDocument;
    /**
     * 
     * @type {DocumentBreakdownAgeValidation}
     * @memberof DocumentBreakdown
     */
    'age_validation'?: DocumentBreakdownAgeValidation;
    /**
     * 
     * @type {DocumentBreakdownIssuingAuthority}
     * @memberof DocumentBreakdown
     */
    'issuing_authority'?: DocumentBreakdownIssuingAuthority;
}
/**
 * Asserts whether the age calculated from the document\'s date of birth data point is greater than or equal to the minimum accepted age.
 * @export
 * @interface DocumentBreakdownAgeValidation
 */
export interface DocumentBreakdownAgeValidation {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownAgeValidation
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownAgeValidationBreakdown}
     * @memberof DocumentBreakdownAgeValidation
     */
    'breakdown'?: DocumentBreakdownAgeValidationBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownAgeValidationBreakdown
 */
export interface DocumentBreakdownAgeValidationBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownAgeValidationBreakdown
     */
    'minimum_accepted_age'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the image of the document has been found in our internal database or if it was used in a suspicious way.
 * @export
 * @interface DocumentBreakdownCompromisedDocument
 */
export interface DocumentBreakdownCompromisedDocument {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownCompromisedDocument
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownCompromisedDocumentBreakdown}
     * @memberof DocumentBreakdownCompromisedDocument
     */
    'breakdown'?: DocumentBreakdownCompromisedDocumentBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownCompromisedDocumentBreakdown
 */
export interface DocumentBreakdownCompromisedDocumentBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownCompromisedDocumentBreakdown
     */
    'document_database'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownCompromisedDocumentBreakdown
     */
    'repeat_attempts'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether data on the document is consistent with data provided when creating an applicant through the API.
 * @export
 * @interface DocumentBreakdownDataComparison
 */
export interface DocumentBreakdownDataComparison {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownDataComparison
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdown}
     * @memberof DocumentBreakdownDataComparison
     */
    'breakdown'?: DocumentBreakdownDataComparisonBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownDataComparisonBreakdown
 */
export interface DocumentBreakdownDataComparisonBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'issuing_country'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'gender'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'date_of_expiry'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'document_type'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'document_numbers'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataComparisonBreakdown
     */
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownDataComparisonBreakdownIssuingCountry
 */
export interface DocumentBreakdownDataComparisonBreakdownIssuingCountry {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownDataComparisonBreakdownIssuingCountry
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownDataComparisonBreakdownIssuingCountry
     */
    'properties'?: object;
}
/**
 * Asserts whether data represented in multiple places on the document is consistent.
 * @export
 * @interface DocumentBreakdownDataConsistency
 */
export interface DocumentBreakdownDataConsistency {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownDataConsistency
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownDataConsistencyBreakdown}
     * @memberof DocumentBreakdownDataConsistency
     */
    'breakdown'?: DocumentBreakdownDataConsistencyBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownDataConsistencyBreakdown
 */
export interface DocumentBreakdownDataConsistencyBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'date_of_expiry'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'document_numbers'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'issuing_country'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'document_type'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'gender'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'nationality'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataConsistencyBreakdown
     */
    'multiple_data_sources_present'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether algorithmically validatable elements are correct.
 * @export
 * @interface DocumentBreakdownDataValidation
 */
export interface DocumentBreakdownDataValidation {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownDataValidation
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownDataValidationBreakdown}
     * @memberof DocumentBreakdownDataValidation
     */
    'breakdown'?: DocumentBreakdownDataValidationBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownDataValidationBreakdown
 */
export interface DocumentBreakdownDataValidationBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'gender'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'document_numbers'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataValidationBreakdownDocumentExpiration}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'document_expiration'?: DocumentBreakdownDataValidationBreakdownDocumentExpiration;
    /**
     * 
     * @type {DocumentBreakdownDataValidationBreakdownExpiryDate}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'expiry_date'?: DocumentBreakdownDataValidationBreakdownExpiryDate;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'mrz'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof DocumentBreakdownDataValidationBreakdown
     */
    'barcode'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * If this is flagged, the document has expired.
 * @export
 * @interface DocumentBreakdownDataValidationBreakdownDocumentExpiration
 */
export interface DocumentBreakdownDataValidationBreakdownDocumentExpiration {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownDataValidationBreakdownDocumentExpiration
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownDataValidationBreakdownDocumentExpiration
     */
    'properties'?: object;
}
/**
 * If this is flagged, the expiration date has the incorrect format.
 * @export
 * @interface DocumentBreakdownDataValidationBreakdownExpiryDate
 */
export interface DocumentBreakdownDataValidationBreakdownExpiryDate {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownDataValidationBreakdownExpiryDate
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownDataValidationBreakdownExpiryDate
     */
    'properties'?: object;
}
/**
 * Asserts if the document is of sufficient quality to verify.
 * @export
 * @interface DocumentBreakdownImageIntegrity
 */
export interface DocumentBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownImageIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownImageIntegrityBreakdown}
     * @memberof DocumentBreakdownImageIntegrity
     */
    'breakdown'?: DocumentBreakdownImageIntegrityBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownImageIntegrityBreakdown
 */
export interface DocumentBreakdownImageIntegrityBreakdown {
    /**
     * 
     * @type {DocumentBreakdownImageIntegrityBreakdownImageQuality}
     * @memberof DocumentBreakdownImageIntegrityBreakdown
     */
    'image_quality'?: DocumentBreakdownImageIntegrityBreakdownImageQuality;
    /**
     * 
     * @type {DocumentBreakdownImageIntegrityBreakdownSupportedDocument}
     * @memberof DocumentBreakdownImageIntegrityBreakdown
     */
    'supported_document'?: DocumentBreakdownImageIntegrityBreakdownSupportedDocument;
    /**
     * 
     * @type {DocumentBreakdownImageIntegrityBreakdownColourPicture}
     * @memberof DocumentBreakdownImageIntegrityBreakdown
     */
    'colour_picture'?: DocumentBreakdownImageIntegrityBreakdownColourPicture;
    /**
     * 
     * @type {DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality}
     * @memberof DocumentBreakdownImageIntegrityBreakdown
     */
    'conclusive_document_quality'?: DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality;
}
/**
 * Asserts whether the image was a colour one.
 * @export
 * @interface DocumentBreakdownImageIntegrityBreakdownColourPicture
 */
export interface DocumentBreakdownImageIntegrityBreakdownColourPicture {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownImageIntegrityBreakdownColourPicture
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownImageIntegrityBreakdownColourPicture
     */
    'properties'?: object;
}
/**
 * Asserts if the document was of enough quality to be able to perform a fraud inspection.
 * @export
 * @interface DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality
 */
export interface DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentCDQReasons}
     * @memberof DocumentBreakdownImageIntegrityBreakdownConclusiveDocumentQuality
     */
    'properties'?: DocumentCDQReasons;
}
/**
 * Asserts whether the quality of the image was sufficient for processing.
 * @export
 * @interface DocumentBreakdownImageIntegrityBreakdownImageQuality
 */
export interface DocumentBreakdownImageIntegrityBreakdownImageQuality {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownImageIntegrityBreakdownImageQuality
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentIQReasons}
     * @memberof DocumentBreakdownImageIntegrityBreakdownImageQuality
     */
    'properties'?: DocumentIQReasons;
}
/**
 * Asserts whether the submitted document is supported.
 * @export
 * @interface DocumentBreakdownImageIntegrityBreakdownSupportedDocument
 */
export interface DocumentBreakdownImageIntegrityBreakdownSupportedDocument {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownImageIntegrityBreakdownSupportedDocument
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownImageIntegrityBreakdownSupportedDocument
     */
    'properties'?: object;
}
/**
 * Asserts whether data on the document matches the issuing authority data.
 * @export
 * @interface DocumentBreakdownIssuingAuthority
 */
export interface DocumentBreakdownIssuingAuthority {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownIssuingAuthority
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownIssuingAuthorityBreakdown}
     * @memberof DocumentBreakdownIssuingAuthority
     */
    'breakdown'?: DocumentBreakdownIssuingAuthorityBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownIssuingAuthorityBreakdown
 */
export interface DocumentBreakdownIssuingAuthorityBreakdown {
    /**
     * 
     * @type {DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication}
     * @memberof DocumentBreakdownIssuingAuthorityBreakdown
     */
    'nfc_active_authentication'?: DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication;
    /**
     * 
     * @type {DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication}
     * @memberof DocumentBreakdownIssuingAuthorityBreakdown
     */
    'nfc_passive_authentication'?: DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication;
}
/**
 * Asserts whether the document NFC chip is original or cloned.
 * @export
 * @interface DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication
 */
export interface DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownIssuingAuthorityBreakdownNfcActiveAuthentication
     */
    'properties'?: object;
}
/**
 * Asserts whether the document NFC chip data was tampered.
 * @export
 * @interface DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication
 */
export interface DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownIssuingAuthorityBreakdownNfcPassiveAuthentication
     */
    'properties'?: object;
}
/**
 * Asserts whether the document had been identified as lost, stolen or otherwise compromised.
 * @export
 * @interface DocumentBreakdownPoliceRecord
 */
export interface DocumentBreakdownPoliceRecord {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownPoliceRecord
     */
    'result'?: string;
}
/**
 * Asserts whether visual, non-textual, elements are correct given the type of document.
 * @export
 * @interface DocumentBreakdownVisualAuthenticity
 */
export interface DocumentBreakdownVisualAuthenticity {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticity
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdown}
     * @memberof DocumentBreakdownVisualAuthenticity
     */
    'breakdown'?: DocumentBreakdownVisualAuthenticityBreakdown;
}
/**
 * 
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdown
 */
export interface DocumentBreakdownVisualAuthenticityBreakdown {
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownFonts}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'fonts'?: DocumentBreakdownVisualAuthenticityBreakdownFonts;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'picture_face_integrity'?: DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownTemplate}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'template'?: DocumentBreakdownVisualAuthenticityBreakdownTemplate;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'security_features'?: DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'original_document_present'?: DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'digital_tampering'?: DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownOther}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'other'?: DocumentBreakdownVisualAuthenticityBreakdownOther;
    /**
     * 
     * @type {DocumentBreakdownVisualAuthenticityBreakdownFaceDetection}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdown
     */
    'face_detection'?: DocumentBreakdownVisualAuthenticityBreakdownFaceDetection;
}
/**
 * Indication of digital tampering in the image.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownDigitalTampering
     */
    'properties'?: object;
}
/**
 * No face was detected on the document.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownFaceDetection
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownFaceDetection {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownFaceDetection
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownFaceDetection
     */
    'properties'?: object;
}
/**
 * Fonts in the document don\'t match the expected ones.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownFonts
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownFonts {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownFonts
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownFonts
     */
    'properties'?: object;
}
/**
 * The document was not present when the photo was taken.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent
     */
    'result'?: string;
    /**
     * 
     * @type {DocumentODPReasons}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownOriginalDocumentPresent
     */
    'properties'?: DocumentODPReasons;
}
/**
 * This sub-breakdown is returned for backward compatibility reasons. Its value will be consider when at least one of the other breakdowns is consider, and clear when all the other breakdowns are clear.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownOther
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownOther {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownOther
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownOther
     */
    'properties'?: object;
}
/**
 * The pictures of the person identified on the document show signs of tampering or alteration.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownPictureFaceIntegrity
     */
    'properties'?: object;
}
/**
 * Security features expected on the document are missing or wrong.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownSecurityFeatures
     */
    'properties'?: object;
}
/**
 * The document doesn\'t match the expected template for the document type and country it is from.
 * @export
 * @interface DocumentBreakdownVisualAuthenticityBreakdownTemplate
 */
export interface DocumentBreakdownVisualAuthenticityBreakdownTemplate {
    /**
     * 
     * @type {string}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownTemplate
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof DocumentBreakdownVisualAuthenticityBreakdownTemplate
     */
    'properties'?: object;
}
/**
 * 
 * @export
 * @interface DocumentCDQReasons
 */
export interface DocumentCDQReasons {
    /**
     * When data points are obscured to the point that we cannot confirm if the fonts match the expected ones.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'obscured_data_points'?: string;
    /**
     * When a critical security feature is obscured. This can also refer to when the holder\'s wet signature, necessary for the document to be valid, is not present.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'obscured_security_features'?: string;
    /**
     * One of 3 reasons (1) OCR Assisted Scans (i.e. when you\'re able to move the mouse and highlight part of text), (2) Severely Washed out Background, (3) Overlapping Text.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'abnormal_document_features'?: string;
    /**
     * Any digital text or electronic watermarks on the document.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'watermarks_digital_text_overlay'?: string;
    /**
     * If the corner has been physically cut off. This can be found on some documents that are no longer valid.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'corner_removed'?: string;
    /**
     * A punched hole is present.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'punctured_document'?: string;
    /**
     * When the back of a document is needed for processing, but is not available.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'missing_back'?: string;
    /**
     * When a document has been published digitally, there aren\'t enough security features to review so we cannot perform a full fraud assessment.
     * @type {string}
     * @memberof DocumentCDQReasons
     */
    'digital_document'?: string;
}
/**
 * 
 * @export
 * @interface DocumentIQReasons
 */
export interface DocumentIQReasons {
    /**
     * When an image of the document is too dark to be able to see data points.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'dark_photo'?: string;
    /**
     * When there is light reflecting on the document causing glare to obstruct data points.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'glare_on_photo'?: string;
    /**
     * When data points are blurred and no reference can be made elsewhere in the document or if the data points are too blurry and \'they could be something else\'.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'blurred_photo'?: string;
    /**
     * When data points have been covered either by the applicant or by another object such as a sticker.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'covered_photo'?: string;
    /**
     * Any other reason not listed, such as when holograms are obscuring data points.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'other_photo_issue'?: string;
    /**
     * When a document is damaged and we are unable to make out data points.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'damaged_document'?: string;
    /**
     * When the incorrect side of a document has been uploaded, and we have not received the front.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'incorrect_side'?: string;
    /**
     * When data points are not included in the image due to the document being cut off.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'cut_off_document'?: string;
    /**
     * If no document has been uploaded or there is a blank image.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'no_document_in_image'?: string;
    /**
     * When 2 different documents are submitted in the same check.
     * @type {string}
     * @memberof DocumentIQReasons
     */
    'two_documents_uploaded'?: string;
}
/**
 * 
 * @export
 * @interface DocumentODPReasons
 */
export interface DocumentODPReasons {
    /**
     * When the applicant\'s document is on a physical screen or device.
     * @type {string}
     * @memberof DocumentODPReasons
     */
    'photo_of_screen'?: string;
    /**
     * When the applicant has used their mobile phone, tablet, or computer to take a photo within the device.
     * @type {string}
     * @memberof DocumentODPReasons
     */
    'screenshot'?: string;
    /**
     * When the applicant has previously captured an image of the document, printed it out, and has now taken a photo of this print out to upload.
     * @type {string}
     * @memberof DocumentODPReasons
     */
    'document_on_printed_paper'?: string;
    /**
     * When the document has clearly been captured using a scanner and there are visible indicators of this
     * @type {string}
     * @memberof DocumentODPReasons
     */
    'scan'?: string;
}
/**
 * 
 * @export
 * @interface DocumentProperties
 */
export interface DocumentProperties {
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'date_of_expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'personal_number'?: string;
    /**
     * 
     * @type {Array<DocumentPropertiesDocumentNumbersInner>}
     * @memberof DocumentProperties
     */
    'document_numbers'?: Array<DocumentPropertiesDocumentNumbersInner>;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'document_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'middle_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'issuing_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'issuing_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'issuing_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'categorisation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'mrz_line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'mrz_line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'mrz_line3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'place_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'spouse_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'widow_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'alias_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'issuing_authority'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'remarks'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'civil_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'expatriation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'father_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'mother_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'religion'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'type_of_permit'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'version_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'document_subtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'profession'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'security_document_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'tax_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'nist_identity_evidence_strength'?: DocumentPropertiesNistIdentityEvidenceStrengthEnum;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'has_issuance_confirmation'?: DocumentPropertiesHasIssuanceConfirmationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentProperties
     */
    'real_id_compliance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DocumentProperties
     */
    'security_tier'?: DocumentPropertiesSecurityTierEnum;
    /**
     * 
     * @type {DocumentPropertiesAddressLines}
     * @memberof DocumentProperties
     */
    'address_lines'?: DocumentPropertiesAddressLines;
    /**
     * 
     * @type {Array<DocumentPropertiesBarcodeInner>}
     * @memberof DocumentProperties
     */
    'barcode'?: Array<DocumentPropertiesBarcodeInner>;
    /**
     * 
     * @type {DocumentPropertiesNfc}
     * @memberof DocumentProperties
     */
    'nfc'?: DocumentPropertiesNfc;
    /**
     * 
     * @type {DocumentPropertiesDrivingLicenceInformation}
     * @memberof DocumentProperties
     */
    'driving_licence_information'?: DocumentPropertiesDrivingLicenceInformation;
    /**
     * 
     * @type {DocumentPropertiesDocumentClassification}
     * @memberof DocumentProperties
     */
    'document_classification'?: DocumentPropertiesDocumentClassification;
    /**
     * 
     * @type {DocumentPropertiesExtractedData}
     * @memberof DocumentProperties
     */
    'extracted_data'?: DocumentPropertiesExtractedData;
}

export const DocumentPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesNistIdentityEvidenceStrengthEnum = typeof DocumentPropertiesNistIdentityEvidenceStrengthEnum[keyof typeof DocumentPropertiesNistIdentityEvidenceStrengthEnum];
export const DocumentPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesHasIssuanceConfirmationEnum = typeof DocumentPropertiesHasIssuanceConfirmationEnum[keyof typeof DocumentPropertiesHasIssuanceConfirmationEnum];
export const DocumentPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentPropertiesSecurityTierEnum = typeof DocumentPropertiesSecurityTierEnum[keyof typeof DocumentPropertiesSecurityTierEnum];

/**
 * 
 * @export
 * @interface DocumentPropertiesAddressLines
 */
export interface DocumentPropertiesAddressLines {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesAddressLines
     */
    'street_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesAddressLines
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesAddressLines
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesAddressLines
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesAddressLines
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesAddressLines
     */
    'country_code'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPropertiesBarcodeInner
 */
export interface DocumentPropertiesBarcodeInner {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'middle_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'document_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'date_of_expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'issuing_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'address_line_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'address_line_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'address_line_3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'address_line_4'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'address_line_5'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'issuing_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'class'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'issuing_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'document_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesBarcodeInner
     */
    'real_id_classification'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPropertiesDocumentClassification
 */
export interface DocumentPropertiesDocumentClassification {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDocumentClassification
     */
    'issuing_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDocumentClassification
     */
    'document_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDocumentClassification
     */
    'issuing_state'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPropertiesDocumentNumbersInner
 */
export interface DocumentPropertiesDocumentNumbersInner {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDocumentNumbersInner
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDocumentNumbersInner
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPropertiesDrivingLicenceInformation
 */
export interface DocumentPropertiesDrivingLicenceInformation {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDrivingLicenceInformation
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDrivingLicenceInformation
     */
    'obtainment_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDrivingLicenceInformation
     */
    'expiry_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesDrivingLicenceInformation
     */
    'codes'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPropertiesExtractedData
 */
export interface DocumentPropertiesExtractedData {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'document_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'date_of_expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'middle_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'spouse_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'widow_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'alias_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'mrz_line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'mrz_line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'mrz_line3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'address_line_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'address_line_2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'address_line_3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'address_line_4'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'address_line_5'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesExtractedData
     */
    'issuing_authority'?: string;
}
/**
 * 
 * @export
 * @interface DocumentPropertiesNfc
 */
export interface DocumentPropertiesNfc {
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'document_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'issuing_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'full_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'document_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'date_of_expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'personal_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'place_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'issuing_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPropertiesNfc
     */
    'issuing_authority'?: string;
}
/**
 * 
 * @export
 * @interface DocumentReport
 */
export interface DocumentReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DocumentReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DocumentReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DocumentReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DocumentReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DocumentReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DocumentReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DocumentReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DocumentReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DocumentReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DocumentBreakdown}
     * @memberof DocumentReport
     */
    'breakdown'?: DocumentBreakdown;
    /**
     * 
     * @type {DocumentProperties}
     * @memberof DocumentReport
     */
    'properties'?: DocumentProperties;
}


/**
 * 
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * The unique identifier for the document
     * @type {string}
     * @memberof DocumentResponse
     */
    'id': string;
    /**
     * The date and time at which the document was uploaded
     * @type {string}
     * @memberof DocumentResponse
     */
    'created_at'?: string;
    /**
     * The uri of this resource
     * @type {string}
     * @memberof DocumentResponse
     */
    'href'?: string;
    /**
     * The uri that can be used to download the document
     * @type {string}
     * @memberof DocumentResponse
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file
     * @type {string}
     * @memberof DocumentResponse
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes
     * @type {number}
     * @memberof DocumentResponse
     */
    'file_size'?: number;
}
/**
 * 
 * @export
 * @interface DocumentShared
 */
export interface DocumentShared {
    /**
     * The file type of the uploaded file
     * @type {string}
     * @memberof DocumentShared
     */
    'file_type'?: DocumentSharedFileTypeEnum;
    /**
     * The type of document
     * @type {string}
     * @memberof DocumentShared
     */
    'type'?: string;
    /**
     * The side of the document, if applicable. The possible values are front and back
     * @type {string}
     * @memberof DocumentShared
     */
    'side'?: DocumentSharedSideEnum;
    /**
     * The issuing country of the document, a 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof DocumentShared
     */
    'issuing_country'?: CountryCodes;
    /**
     * The ID of the applicant whose document is being uploaded.
     * @type {string}
     * @memberof DocumentShared
     */
    'applicant_id'?: string;
}

export const DocumentSharedFileTypeEnum = {
    Jpg: 'jpg',
    Jpeg: 'jpeg',
    Png: 'png',
    Pdf: 'pdf',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentSharedFileTypeEnum = typeof DocumentSharedFileTypeEnum[keyof typeof DocumentSharedFileTypeEnum];
export const DocumentSharedSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentSharedSideEnum = typeof DocumentSharedSideEnum[keyof typeof DocumentSharedSideEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const DocumentTypes = {
    Passport: 'passport',
    DrivingLicence: 'driving_licence',
    NationalIdentityCard: 'national_identity_card',
    ResidencePermit: 'residence_permit',
    PassportCard: 'passport_card',
    TaxId: 'tax_id',
    Visa: 'visa',
    VoterId: 'voter_id',
    ResidenceStatusDocument: 'residence_status_document',
    PostalIdentityCard: 'postal_identity_card',
    SocialSecurityCard: 'social_security_card',
    WorkPermit: 'work_permit',
    AsylumRegistrationCard: 'asylum_registration_card',
    NationalHealthInsuranceCard: 'national_health_insurance_card',
    MunicipalityIdentityCard: 'municipality_identity_card',
    PrivateOperatorsCard: 'private_operators_card',
    ProofOfCitizenship: 'proof_of_citizenship',
    ServiceIdCard: 'service_id_card',
    ImmigrationStatusDocument: 'immigration_status_document',
    IndigenousCard: 'indigenous_card',
    VehicleRegistrationCard: 'vehicle_registration_card',
    CertificateOfNaturalisation: 'certificate_of_naturalisation',
    ProfessionalQualificationCard: 'professional_qualification_card',
    ConsularId: 'consular_id',
    InternationalDrivingLicence: 'international_driving_licence',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentTypes = typeof DocumentTypes[keyof typeof DocumentTypes];


/**
 * 
 * @export
 * @interface DocumentVideoReport
 */
export interface DocumentVideoReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DocumentVideoReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DocumentVideoReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DocumentVideoReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DocumentVideoReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DocumentVideoReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DocumentVideoReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DocumentVideoReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DocumentVideoReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DocumentVideoReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DocumentBreakdown}
     * @memberof DocumentVideoReport
     */
    'breakdown'?: DocumentBreakdown;
    /**
     * 
     * @type {DocumentProperties}
     * @memberof DocumentVideoReport
     */
    'properties'?: DocumentProperties;
}


/**
 * 
 * @export
 * @interface DocumentVideoWithAddressInformationReport
 */
export interface DocumentVideoWithAddressInformationReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DocumentBreakdown}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'breakdown'?: DocumentBreakdown;
    /**
     * 
     * @type {DocumentProperties}
     * @memberof DocumentVideoWithAddressInformationReport
     */
    'properties'?: DocumentProperties;
}


/**
 * 
 * @export
 * @interface DocumentWithAddressInformationReport
 */
export interface DocumentWithAddressInformationReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DocumentWithAddressInformationReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DocumentWithAddressInformationReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DocumentWithAddressInformationReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DocumentWithAddressInformationReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DocumentWithAddressInformationReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DocumentWithAddressInformationReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DocumentWithAddressInformationReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DocumentWithAddressInformationReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DocumentWithAddressInformationReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DocumentBreakdown}
     * @memberof DocumentWithAddressInformationReport
     */
    'breakdown'?: DocumentBreakdown;
    /**
     * 
     * @type {DocumentProperties}
     * @memberof DocumentWithAddressInformationReport
     */
    'properties'?: DocumentProperties;
}


/**
 * 
 * @export
 * @interface DocumentWithDriverVerificationReport
 */
export interface DocumentWithDriverVerificationReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DocumentWithDriverVerificationReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DocumentWithDriverVerificationReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DocumentWithDriverVerificationReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DocumentWithDriverVerificationReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DocumentWithDriverVerificationReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DocumentWithDriverVerificationReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DocumentWithDriverVerificationReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DocumentWithDriverVerificationReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DocumentWithDriverVerificationReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DocumentBreakdown}
     * @memberof DocumentWithDriverVerificationReport
     */
    'breakdown'?: DocumentBreakdown;
    /**
     * 
     * @type {DocumentWithDriverVerificationReportAllOfProperties}
     * @memberof DocumentWithDriverVerificationReport
     */
    'properties'?: DocumentWithDriverVerificationReportAllOfProperties;
}


/**
 * 
 * @export
 * @interface DocumentWithDriverVerificationReportAllOfProperties
 */
export interface DocumentWithDriverVerificationReportAllOfProperties {
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'date_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'date_of_expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'personal_number'?: string;
    /**
     * 
     * @type {Array<DocumentPropertiesDocumentNumbersInner>}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'document_numbers'?: Array<DocumentPropertiesDocumentNumbersInner>;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'document_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'middle_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'issuing_country'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'nationality'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'issuing_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'issuing_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'categorisation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'mrz_line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'mrz_line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'mrz_line3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'place_of_birth'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'spouse_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'widow_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'alias_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'issuing_authority'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'remarks'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'civil_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'expatriation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'father_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'mother_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'religion'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'type_of_permit'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'version_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'document_subtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'profession'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'security_document_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'tax_number'?: string;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'nist_identity_evidence_strength'?: DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'has_issuance_confirmation'?: DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'real_id_compliance'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'security_tier'?: DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum;
    /**
     * 
     * @type {DocumentPropertiesAddressLines}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'address_lines'?: DocumentPropertiesAddressLines;
    /**
     * 
     * @type {Array<DocumentPropertiesBarcodeInner>}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'barcode'?: Array<DocumentPropertiesBarcodeInner>;
    /**
     * 
     * @type {DocumentPropertiesNfc}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'nfc'?: DocumentPropertiesNfc;
    /**
     * 
     * @type {DocumentPropertiesDrivingLicenceInformation}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'driving_licence_information'?: DocumentPropertiesDrivingLicenceInformation;
    /**
     * 
     * @type {DocumentPropertiesDocumentClassification}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'document_classification'?: DocumentPropertiesDocumentClassification;
    /**
     * 
     * @type {DocumentPropertiesExtractedData}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'extracted_data'?: DocumentPropertiesExtractedData;
    /**
     * True for **non-restricted** driving licences
     * @type {boolean}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'drivers_licence'?: boolean;
    /**
     * True for **limited/restricted** driving license, including learner\'s permits
     * @type {boolean}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'restricted_licence'?: boolean;
    /**
     * Underlying, non-normalised, licence category (e.g. \"Junior operators license\")
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'raw_licence_category'?: string;
    /**
     * Comma-separated vehicle classes that the user is qualified for
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'raw_vehicle_classes'?: string;
    /**
     * Detailed classes/categories information
     * @type {Array<DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner>}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'vehicle_class_details'?: Array<DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner>;
    /**
     * 
     * @type {DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle}
     * @memberof DocumentWithDriverVerificationReportAllOfProperties
     */
    'passenger_vehicle'?: DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle;
}

export const DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = {
    Superior: 'superior',
    Strong: 'strong',
    Fair: 'fair',
    Weak: 'weak',
    Unacceptable: 'unacceptable',
    UnspecifiedIdentityEvidenceStrength: 'unspecified_identity_evidence_strength',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum = typeof DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum[keyof typeof DocumentWithDriverVerificationReportAllOfPropertiesNistIdentityEvidenceStrengthEnum];
export const DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = {
    True: 'true',
    False: 'false',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum = typeof DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum[keyof typeof DocumentWithDriverVerificationReportAllOfPropertiesHasIssuanceConfirmationEnum];
export const DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = {
    Tier1: 'tier_1',
    Tier2: 'tier_2',
    Tier3: 'tier_3',
    Tier4: 'tier_4',
    Tier5: 'tier_5',
    UnspecifiedSecurityTier: 'unspecified_security_tier',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum = typeof DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum[keyof typeof DocumentWithDriverVerificationReportAllOfPropertiesSecurityTierEnum];

/**
 * Normalised data for passenger cars
 * @export
 * @interface DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle
 */
export interface DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle {
    /**
     * Whether they are qualified for a passenger car, such as a “B” class in the UK
     * @type {boolean}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle
     */
    'is_qualified'?: boolean;
    /**
     * Date the class qualification was obtained
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle
     */
    'obtainment_date'?: string;
    /**
     * Date the class qualification expires, which may be different to doc expiry
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfPassengerVehicle
     */
    'expiry_date'?: string;
}
/**
 * 
 * @export
 * @interface DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner
 */
export interface DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner {
    /**
     * Vehicle class/category
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner
     */
    'category'?: string;
    /**
     * Special conditions driver must meet
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner
     */
    'codes'?: string;
    /**
     * Category obtainment date
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner
     */
    'obtainment_date'?: string;
    /**
     * Category expiry date
     * @type {string}
     * @memberof DocumentWithDriverVerificationReportAllOfPropertiesAllOfVehicleClassDetailsInner
     */
    'expiry_date'?: string;
}
/**
 * 
 * @export
 * @interface DocumentWithDrivingLicenceInformationReport
 */
export interface DocumentWithDrivingLicenceInformationReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'name': ReportName;
    /**
     * 
     * @type {DocumentBreakdown}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'breakdown'?: DocumentBreakdown;
    /**
     * 
     * @type {DocumentProperties}
     * @memberof DocumentWithDrivingLicenceInformationReport
     */
    'properties'?: DocumentProperties;
}


/**
 * 
 * @export
 * @interface DocumentsList
 */
export interface DocumentsList {
    /**
     * 
     * @type {Array<Document>}
     * @memberof DocumentsList
     */
    'documents': Array<Document>;
}
/**
 * 
 * @export
 * @interface Error1
 */
export interface Error1 {
    /**
     * The unique identifier of the uploaded document
     * @type {string}
     * @memberof Error1
     */
    'document_id'?: string;
    /**
     * 
     * @type {ErrorProperties1}
     * @memberof Error1
     */
    'error'?: ErrorProperties1;
}
/**
 * 
 * @export
 * @interface ErrorProperties
 */
export interface ErrorProperties {
    /**
     * 
     * @type {string}
     * @memberof ErrorProperties
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorProperties
     */
    'message'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ErrorProperties
     */
    'fields'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ErrorProperties1
 */
export interface ErrorProperties1 {
    /**
     * 
     * @type {string}
     * @memberof ErrorProperties1
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorProperties1
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ExtractRequest
 */
export interface ExtractRequest {
    /**
     * The unique identifier of the uploaded document to run extraction on
     * @type {string}
     * @memberof ExtractRequest
     */
    'document_id': string;
}
/**
 * 
 * @export
 * @interface Extraction
 */
export interface Extraction {
    /**
     * The unique identifier of the uploaded document.
     * @type {string}
     * @memberof Extraction
     */
    'document_id'?: string;
    /**
     * 
     * @type {ExtractionDocumentClassification}
     * @memberof Extraction
     */
    'document_classification'?: ExtractionDocumentClassification;
    /**
     * 
     * @type {ExtractionExtractedData}
     * @memberof Extraction
     */
    'extracted_data'?: ExtractionExtractedData;
}
/**
 * 
 * @export
 * @interface ExtractionDocumentClassification
 */
export interface ExtractionDocumentClassification {
    /**
     * Document country in 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof ExtractionDocumentClassification
     */
    'issuing_country'?: CountryCodes;
    /**
     * Type of document.
     * @type {DocumentTypes}
     * @memberof ExtractionDocumentClassification
     */
    'document_type'?: DocumentTypes;
    /**
     * The state that issued the document (if available).
     * @type {string}
     * @memberof ExtractionDocumentClassification
     */
    'issuing_state'?: string;
    /**
     * The document subtype (if available).
     * @type {string}
     * @memberof ExtractionDocumentClassification
     */
    'subtype'?: ExtractionDocumentClassificationSubtypeEnum;
    /**
     * The document issuing version (if available).
     * @type {string}
     * @memberof ExtractionDocumentClassification
     */
    'version'?: string;
}

export const ExtractionDocumentClassificationSubtypeEnum = {
    Full: 'full',
    NotFull: 'not_full',
    Provisional: 'provisional',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ExtractionDocumentClassificationSubtypeEnum = typeof ExtractionDocumentClassificationSubtypeEnum[keyof typeof ExtractionDocumentClassificationSubtypeEnum];

/**
 * 
 * @export
 * @interface ExtractionExtractedData
 */
export interface ExtractionExtractedData {
    /**
     * The official document number.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'document_number'?: string;
    /**
     * First name.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'first_name'?: string;
    /**
     * Last name.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'last_name'?: string;
    /**
     * Full name.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'full_name'?: string;
    /**
     * Spouse name (French documents only).
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'spouse_name'?: string;
    /**
     * Widow name (French documents only).
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'widow_name'?: string;
    /**
     * Alias name (French documents only).
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'alias_name'?: string;
    /**
     * Gender (Valid values are Male and Female).
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'gender'?: ExtractionExtractedDataGenderEnum;
    /**
     * Date of birth in YYYY-MM-DD format.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'date_of_birth'?: string;
    /**
     * Date of expiry in YYYY-MM-DD format.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'date_of_expiry'?: string;
    /**
     * Date of expiry in YYYY-MM-DD format.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'expiry_date'?: string;
    /**
     * Nationality in 3-letter ISO code.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'nationality'?: string;
    /**
     * Line 1 of the MRZ code.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'mrz_line_1'?: string;
    /**
     * Line 2 of the MRZ code.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'mrz_line_2'?: string;
    /**
     * Line 3 of the MRZ code.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'mrz_line_3'?: string;
    /**
     * Line 1 of the address.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'address_1'?: string;
    /**
     * Line 2 of the address.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'address_2'?: string;
    /**
     * Line 3 of the address.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'address_3'?: string;
    /**
     * Line 4 of the address.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'address_4'?: string;
    /**
     * Line 5 of the address.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'address_5'?: string;
    /**
     * Issuing authority.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'issuing_authority'?: string;
    /**
     * Document country in 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof ExtractionExtractedData
     */
    'issuing_country'?: CountryCodes;
    /**
     * Type of document.
     * @type {DocumentTypes}
     * @memberof ExtractionExtractedData
     */
    'document_type'?: DocumentTypes;
    /**
     * Place of birth.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'place_of_birth'?: string;
    /**
     * The state that issued the document.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'issuing_state'?: string;
    /**
     * Issuing date in YYYY-MM-DD format.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'issuing_date'?: string;
    /**
     * The owner\'s unique identification number.
     * @type {string}
     * @memberof ExtractionExtractedData
     */
    'personal_number'?: string;
}

export const ExtractionExtractedDataGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ExtractionExtractedDataGenderEnum = typeof ExtractionExtractedDataGenderEnum[keyof typeof ExtractionExtractedDataGenderEnum];

/**
 * 
 * @export
 * @interface FacialSimilarityMotionBreakdown
 */
export interface FacialSimilarityMotionBreakdown {
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownFaceComparison}
     * @memberof FacialSimilarityMotionBreakdown
     */
    'face_comparison'?: FacialSimilarityMotionBreakdownFaceComparison;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownImageIntegrity}
     * @memberof FacialSimilarityMotionBreakdown
     */
    'image_integrity'?: FacialSimilarityMotionBreakdownImageIntegrity;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownVisualAuthenticity}
     * @memberof FacialSimilarityMotionBreakdown
     */
    'visual_authenticity'?: FacialSimilarityMotionBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the face in the document matches the face in the motion capture.
 * @export
 * @interface FacialSimilarityMotionBreakdownFaceComparison
 */
export interface FacialSimilarityMotionBreakdownFaceComparison {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityMotionBreakdownFaceComparison
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparisonBreakdown}
     * @memberof FacialSimilarityMotionBreakdownFaceComparison
     */
    'breakdown'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdown;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 * @export
 * @interface FacialSimilarityMotionBreakdownImageIntegrity
 */
export interface FacialSimilarityMotionBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownImageIntegrityBreakdown}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrity
     */
    'breakdown'?: FacialSimilarityMotionBreakdownImageIntegrityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityMotionBreakdownImageIntegrityBreakdown
 */
export interface FacialSimilarityMotionBreakdownImageIntegrityBreakdown {
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrityBreakdown
     */
    'face_detected'?: FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrityBreakdown
     */
    'source_integrity'?: FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts a single face of good enough quality has been found in both the document image and in the motion capture.
 * @export
 * @interface FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected
 */
export interface FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrityBreakdownFaceDetected
     */
    'properties'?: object;
}
/**
 * Asserts whether the motion capture is trustworthy - e.g. not from a fake webcam.
 * @export
 * @interface FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity
 */
export interface FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {VideoReasons}
     * @memberof FacialSimilarityMotionBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'properties'?: VideoReasons;
}
/**
 * Asserts whether the person in the motion capture is real (not a spoof) and live.
 * @export
 * @interface FacialSimilarityMotionBreakdownVisualAuthenticity
 */
export interface FacialSimilarityMotionBreakdownVisualAuthenticity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityMotionBreakdownVisualAuthenticity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown}
     * @memberof FacialSimilarityMotionBreakdownVisualAuthenticity
     */
    'breakdown'?: FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown
 */
export interface FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown {
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected}
     * @memberof FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown
     */
    'liveness_detected'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection}
     * @memberof FacialSimilarityMotionBreakdownVisualAuthenticityBreakdown
     */
    'spoofing_detection'?: FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection;
}
/**
 * Asserts whether the motion capture is not a spoof (such as videos of digital screens).
 * @export
 * @interface FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection
 */
export interface FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties}
     * @memberof FacialSimilarityMotionBreakdownVisualAuthenticityBreakdownSpoofingDetection
     */
    'properties'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties;
}
/**
 * 
 * @export
 * @interface FacialSimilarityMotionProperties
 */
export interface FacialSimilarityMotionProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. videos of digital screens, masks or print-outs). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     * @type {number}
     * @memberof FacialSimilarityMotionProperties
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface FacialSimilarityMotionReport
 */
export interface FacialSimilarityMotionReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityMotionReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof FacialSimilarityMotionReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityMotionReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof FacialSimilarityMotionReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof FacialSimilarityMotionReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof FacialSimilarityMotionReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof FacialSimilarityMotionReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof FacialSimilarityMotionReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof FacialSimilarityMotionReport
     */
    'name': ReportName;
    /**
     * 
     * @type {FacialSimilarityMotionBreakdown}
     * @memberof FacialSimilarityMotionReport
     */
    'breakdown'?: FacialSimilarityMotionBreakdown;
    /**
     * 
     * @type {FacialSimilarityMotionProperties}
     * @memberof FacialSimilarityMotionReport
     */
    'properties'?: FacialSimilarityMotionProperties;
}


/**
 * 
 * @export
 * @interface FacialSimilarityPhotoBreakdown
 */
export interface FacialSimilarityPhotoBreakdown {
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparison}
     * @memberof FacialSimilarityPhotoBreakdown
     */
    'face_comparison'?: FacialSimilarityPhotoBreakdownFaceComparison;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownImageIntegrity}
     * @memberof FacialSimilarityPhotoBreakdown
     */
    'image_integrity'?: FacialSimilarityPhotoBreakdownImageIntegrity;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticity}
     * @memberof FacialSimilarityPhotoBreakdown
     */
    'visual_authenticity'?: FacialSimilarityPhotoBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the face in the document matches the face in the live photo.
 * @export
 * @interface FacialSimilarityPhotoBreakdownFaceComparison
 */
export interface FacialSimilarityPhotoBreakdownFaceComparison {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparison
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparisonBreakdown}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparison
     */
    'breakdown'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdown
 */
export interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdown {
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparisonBreakdown
     */
    'face_match'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch;
}
/**
 * Contains a score value under the properties bag.
 * @export
 * @interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch
 */
export interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatch
     */
    'properties'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties
 */
export interface FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties {
    /**
     * A floating point number between 0 and 1 that expresses how similar the two faces are, where 1 is a perfect match.
     * @type {number}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties
     */
    'score'?: number;
    /**
     * The UUID for the document containing the extracted face that was used for face matching.
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownFaceComparisonBreakdownFaceMatchProperties
     */
    'document_id'?: string;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 * @export
 * @interface FacialSimilarityPhotoBreakdownImageIntegrity
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownImageIntegrityBreakdown}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrity
     */
    'breakdown'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdown
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdown {
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrityBreakdown
     */
    'face_detected'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrityBreakdown
     */
    'source_integrity'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts a single face of good enough quality has been found in both the document image and the live photo.
 * @export
 * @interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected
     */
    'properties'?: object;
}
/**
 * Asserts whether the live photo is trustworthy - i.e. not digitally tampered, from a fake webcam, or from other dubious sources.
 * @export
 * @interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity
 */
export interface FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {PhotoReasons}
     * @memberof FacialSimilarityPhotoBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'properties'?: PhotoReasons;
}
/**
 * Asserts whether the person in the live photo is real and not a spoof.
 * @export
 * @interface FacialSimilarityPhotoBreakdownVisualAuthenticity
 */
export interface FacialSimilarityPhotoBreakdownVisualAuthenticity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownVisualAuthenticity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown}
     * @memberof FacialSimilarityPhotoBreakdownVisualAuthenticity
     */
    'breakdown'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown
 */
export interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown {
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection}
     * @memberof FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdown
     */
    'spoofing_detection'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection;
}
/**
 * Contains a score value under the properties bag.
 * @export
 * @interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection
 */
export interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties}
     * @memberof FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetection
     */
    'properties'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties
 */
export interface FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof.
     * @type {number}
     * @memberof FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoFullyAutoBreakdown
 */
export interface FacialSimilarityPhotoFullyAutoBreakdown {
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparison}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdown
     */
    'face_comparison'?: FacialSimilarityPhotoBreakdownFaceComparison;
    /**
     * 
     * @type {FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdown
     */
    'image_integrity'?: FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticity}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdown
     */
    'visual_authenticity'?: FacialSimilarityPhotoBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 * @export
 * @interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity
 */
export interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdownImageIntegrity
     */
    'breakdown'?: FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown
 */
export interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown {
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown
     */
    'face_detected'?: FacialSimilarityPhotoBreakdownImageIntegrityBreakdownFaceDetected;
    /**
     * 
     * @type {FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdown
     */
    'source_integrity'?: FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts whether the live photo is trustworthy - i.e. not digitally tampered, from a fake webcam, or from other dubious sources.
 * @export
 * @interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity
 */
export interface FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {PhotoAutoReasons}
     * @memberof FacialSimilarityPhotoFullyAutoBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'properties'?: PhotoAutoReasons;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoFullyAutoProperties
 */
export interface FacialSimilarityPhotoFullyAutoProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. photos of printed photos, or photos of digital screens). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     * @type {number}
     * @memberof FacialSimilarityPhotoFullyAutoProperties
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoFullyAutoReport
 */
export interface FacialSimilarityPhotoFullyAutoReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'name': ReportName;
    /**
     * 
     * @type {FacialSimilarityPhotoFullyAutoBreakdown}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'breakdown'?: FacialSimilarityPhotoFullyAutoBreakdown;
    /**
     * 
     * @type {FacialSimilarityPhotoFullyAutoProperties}
     * @memberof FacialSimilarityPhotoFullyAutoReport
     */
    'properties'?: FacialSimilarityPhotoFullyAutoProperties;
}


/**
 * 
 * @export
 * @interface FacialSimilarityPhotoProperties
 */
export interface FacialSimilarityPhotoProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. photos of printed photos, or photos of digital screens). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     * @type {number}
     * @memberof FacialSimilarityPhotoProperties
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface FacialSimilarityPhotoReport
 */
export interface FacialSimilarityPhotoReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof FacialSimilarityPhotoReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof FacialSimilarityPhotoReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof FacialSimilarityPhotoReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof FacialSimilarityPhotoReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof FacialSimilarityPhotoReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof FacialSimilarityPhotoReport
     */
    'name': ReportName;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdown}
     * @memberof FacialSimilarityPhotoReport
     */
    'breakdown'?: FacialSimilarityPhotoBreakdown;
    /**
     * 
     * @type {FacialSimilarityPhotoProperties}
     * @memberof FacialSimilarityPhotoReport
     */
    'properties'?: FacialSimilarityPhotoProperties;
}


/**
 * 
 * @export
 * @interface FacialSimilarityVideoBreakdown
 */
export interface FacialSimilarityVideoBreakdown {
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownFaceComparison}
     * @memberof FacialSimilarityVideoBreakdown
     */
    'face_comparison'?: FacialSimilarityVideoBreakdownFaceComparison;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownImageIntegrity}
     * @memberof FacialSimilarityVideoBreakdown
     */
    'image_integrity'?: FacialSimilarityVideoBreakdownImageIntegrity;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownVisualAuthenticity}
     * @memberof FacialSimilarityVideoBreakdown
     */
    'visual_authenticity'?: FacialSimilarityVideoBreakdownVisualAuthenticity;
}
/**
 * Asserts whether the face in the document matches the face in the live video.
 * @export
 * @interface FacialSimilarityVideoBreakdownFaceComparison
 */
export interface FacialSimilarityVideoBreakdownFaceComparison {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownFaceComparison
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownFaceComparisonBreakdown}
     * @memberof FacialSimilarityVideoBreakdownFaceComparison
     */
    'breakdown'?: FacialSimilarityPhotoBreakdownFaceComparisonBreakdown;
}
/**
 * Asserts whether the quality and integrity of the uploaded files were sufficient to perform a face comparison.
 * @export
 * @interface FacialSimilarityVideoBreakdownImageIntegrity
 */
export interface FacialSimilarityVideoBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownImageIntegrityBreakdown}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrity
     */
    'breakdown'?: FacialSimilarityVideoBreakdownImageIntegrityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityVideoBreakdownImageIntegrityBreakdown
 */
export interface FacialSimilarityVideoBreakdownImageIntegrityBreakdown {
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrityBreakdown
     */
    'face_detected'?: FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrityBreakdown
     */
    'source_integrity'?: FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity;
}
/**
 * Asserts a single face of good enough quality has been found in both the document image and the live video.
 * @export
 * @interface FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected
 */
export interface FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrityBreakdownFaceDetected
     */
    'properties'?: object;
}
/**
 * Asserts whether the live video is trustworthy - e.g. not from a fake webcam.
 * @export
 * @interface FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity
 */
export interface FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {VideoReasons}
     * @memberof FacialSimilarityVideoBreakdownImageIntegrityBreakdownSourceIntegrity
     */
    'properties'?: VideoReasons;
}
/**
 * Asserts whether the person in the live video is real (not a spoof) and live.
 * @export
 * @interface FacialSimilarityVideoBreakdownVisualAuthenticity
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticity {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticity
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticity
     */
    'breakdown'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown;
}
/**
 * 
 * @export
 * @interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown {
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown
     */
    'liveness_detected'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticityBreakdown
     */
    'spoofing_detection'?: FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection;
}
/**
 * Asserts whether the numbers and head movements were correctly executed.
 * @export
 * @interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownLivenessDetected
     */
    'properties'?: object;
}
/**
 * Asserts whether the live video is not a spoof (such as videos of digital screens).
 * @export
 * @interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection
 */
export interface FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection {
    /**
     * 
     * @type {string}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection
     */
    'result'?: string;
    /**
     * 
     * @type {FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties}
     * @memberof FacialSimilarityVideoBreakdownVisualAuthenticityBreakdownSpoofingDetection
     */
    'properties'?: FacialSimilarityPhotoBreakdownVisualAuthenticityBreakdownSpoofingDetectionProperties;
}
/**
 * 
 * @export
 * @interface FacialSimilarityVideoProperties
 */
export interface FacialSimilarityVideoProperties {
    /**
     * A floating point number between 0 and 1. The closer the score is to 0, the more likely it is to be a spoof (i.e. videos of digital screens, masks or print-outs). Conversely, the closer it is to 1, the less likely it is to be a spoof. 
     * @type {number}
     * @memberof FacialSimilarityVideoProperties
     */
    'score'?: number;
}
/**
 * 
 * @export
 * @interface FacialSimilarityVideoReport
 */
export interface FacialSimilarityVideoReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityVideoReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof FacialSimilarityVideoReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof FacialSimilarityVideoReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof FacialSimilarityVideoReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof FacialSimilarityVideoReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof FacialSimilarityVideoReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof FacialSimilarityVideoReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof FacialSimilarityVideoReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof FacialSimilarityVideoReport
     */
    'name': ReportName;
    /**
     * 
     * @type {FacialSimilarityVideoBreakdown}
     * @memberof FacialSimilarityVideoReport
     */
    'breakdown'?: FacialSimilarityVideoBreakdown;
    /**
     * 
     * @type {FacialSimilarityVideoProperties}
     * @memberof FacialSimilarityVideoReport
     */
    'properties'?: FacialSimilarityVideoProperties;
}


/**
 * 
 * @export
 * @interface IdNumber
 */
export interface IdNumber {
    /**
     * Type of ID number.
     * @type {string}
     * @memberof IdNumber
     */
    'type'?: IdNumberTypeEnum;
    /**
     * Value of ID number
     * @type {string}
     * @memberof IdNumber
     */
    'value'?: string;
    /**
     * Two letter code of issuing state (state-issued driving licenses only)
     * @type {string}
     * @memberof IdNumber
     */
    'state_code'?: string;
}

export const IdNumberTypeEnum = {
    Ssn: 'ssn',
    SocialInsurance: 'social_insurance',
    TaxId: 'tax_id',
    IdentityCard: 'identity_card',
    DrivingLicence: 'driving_licence',
    ShareCode: 'share_code',
    VoterId: 'voter_id',
    Passport: 'passport',
    Other: 'other',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type IdNumberTypeEnum = typeof IdNumberTypeEnum[keyof typeof IdNumberTypeEnum];

/**
 * 
 * @export
 * @interface IdPhoto
 */
export interface IdPhoto {
    /**
     * The unique identifier for the photo.
     * @type {string}
     * @memberof IdPhoto
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     * @type {string}
     * @memberof IdPhoto
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof IdPhoto
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     * @type {string}
     * @memberof IdPhoto
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     * @type {string}
     * @memberof IdPhoto
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     * @type {string}
     * @memberof IdPhoto
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof IdPhoto
     */
    'file_size'?: number;
}
/**
 * 
 * @export
 * @interface IdPhotoResponse
 */
export interface IdPhotoResponse {
    /**
     * The unique identifier for the photo.
     * @type {string}
     * @memberof IdPhotoResponse
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     * @type {string}
     * @memberof IdPhotoResponse
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof IdPhotoResponse
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     * @type {string}
     * @memberof IdPhotoResponse
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     * @type {string}
     * @memberof IdPhotoResponse
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     * @type {string}
     * @memberof IdPhotoResponse
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof IdPhotoResponse
     */
    'file_size'?: number;
}
/**
 * 
 * @export
 * @interface IdPhotosList
 */
export interface IdPhotosList {
    /**
     * 
     * @type {Array<IdPhoto>}
     * @memberof IdPhotosList
     */
    'id_photos': Array<IdPhoto>;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedBreakdown
 */
export interface IdentityEnhancedBreakdown {
    /**
     * 
     * @type {IdentityEnhancedBreakdownSources}
     * @memberof IdentityEnhancedBreakdown
     */
    'sources'?: IdentityEnhancedBreakdownSources;
    /**
     * 
     * @type {IdentityEnhancedBreakdownAddress}
     * @memberof IdentityEnhancedBreakdown
     */
    'address'?: IdentityEnhancedBreakdownAddress;
    /**
     * 
     * @type {IdentityEnhancedBreakdownDateOfBirth}
     * @memberof IdentityEnhancedBreakdown
     */
    'date_of_birth'?: IdentityEnhancedBreakdownDateOfBirth;
    /**
     * 
     * @type {IdentityEnhancedBreakdownMortality}
     * @memberof IdentityEnhancedBreakdown
     */
    'mortality'?: IdentityEnhancedBreakdownMortality;
}
/**
 * Asserts if the applicant\'s address matches any sources.
 * @export
 * @interface IdentityEnhancedBreakdownAddress
 */
export interface IdentityEnhancedBreakdownAddress {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownAddress
     */
    'result'?: string;
    /**
     * 
     * @type {IdentityEnhancedBreakdownAddressBreakdown}
     * @memberof IdentityEnhancedBreakdownAddress
     */
    'breakdown'?: IdentityEnhancedBreakdownAddressBreakdown;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedBreakdownAddressBreakdown
 */
export interface IdentityEnhancedBreakdownAddressBreakdown {
    /**
     * 
     * @type {IdentityEnhancedBreakdownAddressBreakdownCreditAgencies}
     * @memberof IdentityEnhancedBreakdownAddressBreakdown
     */
    'credit_agencies'?: IdentityEnhancedBreakdownAddressBreakdownCreditAgencies;
    /**
     * 
     * @type {IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase}
     * @memberof IdentityEnhancedBreakdownAddressBreakdown
     */
    'telephone_database'?: IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase;
    /**
     * 
     * @type {IdentityEnhancedBreakdownAddressBreakdownVotingRegister}
     * @memberof IdentityEnhancedBreakdownAddressBreakdown
     */
    'voting_register'?: IdentityEnhancedBreakdownAddressBreakdownVotingRegister;
}
/**
 * The number of address matches against credit agencies.
 * @export
 * @interface IdentityEnhancedBreakdownAddressBreakdownCreditAgencies
 */
export interface IdentityEnhancedBreakdownAddressBreakdownCreditAgencies {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownCreditAgencies
     */
    'result'?: string;
    /**
     * 
     * @type {IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownCreditAgencies
     */
    'properties'?: IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties
 */
export interface IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties {
    /**
     * 
     * @type {number}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownCreditAgenciesProperties
     */
    'number_of_matches'?: number;
}
/**
 * Address match against telephone database.
 * @export
 * @interface IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase
 */
export interface IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownTelephoneDatabase
     */
    'properties'?: object;
}
/**
 * Address match against voting register.
 * @export
 * @interface IdentityEnhancedBreakdownAddressBreakdownVotingRegister
 */
export interface IdentityEnhancedBreakdownAddressBreakdownVotingRegister {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownVotingRegister
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof IdentityEnhancedBreakdownAddressBreakdownVotingRegister
     */
    'properties'?: object;
}
/**
 * Asserts if the applicant\'s date of birth matches any sources.
 * @export
 * @interface IdentityEnhancedBreakdownDateOfBirth
 */
export interface IdentityEnhancedBreakdownDateOfBirth {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownDateOfBirth
     */
    'result'?: string;
    /**
     * 
     * @type {IdentityEnhancedBreakdownDateOfBirthBreakdown}
     * @memberof IdentityEnhancedBreakdownDateOfBirth
     */
    'breakdown'?: IdentityEnhancedBreakdownDateOfBirthBreakdown;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedBreakdownDateOfBirthBreakdown
 */
export interface IdentityEnhancedBreakdownDateOfBirthBreakdown {
    /**
     * 
     * @type {IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies}
     * @memberof IdentityEnhancedBreakdownDateOfBirthBreakdown
     */
    'credit_agencies'?: IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies;
    /**
     * 
     * @type {IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister}
     * @memberof IdentityEnhancedBreakdownDateOfBirthBreakdown
     */
    'voting_register'?: IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister;
}
/**
 * Date of birth match against credit agencies.
 * @export
 * @interface IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies
 */
export interface IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof IdentityEnhancedBreakdownDateOfBirthBreakdownCreditAgencies
     */
    'properties'?: object;
}
/**
 * Date of birth match against voting register.
 * @export
 * @interface IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister
 */
export interface IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister
     */
    'result'?: string;
    /**
     * 
     * @type {object}
     * @memberof IdentityEnhancedBreakdownDateOfBirthBreakdownVotingRegister
     */
    'properties'?: object;
}
/**
 * Asserts if the applicant\'s details match any death records.
 * @export
 * @interface IdentityEnhancedBreakdownMortality
 */
export interface IdentityEnhancedBreakdownMortality {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownMortality
     */
    'result'?: string;
}
/**
 * Asserts if any sources that an applicant\'s details have been verified against have produced a match.
 * @export
 * @interface IdentityEnhancedBreakdownSources
 */
export interface IdentityEnhancedBreakdownSources {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownSources
     */
    'result'?: string;
    /**
     * 
     * @type {IdentityEnhancedBreakdownSourcesBreakdown}
     * @memberof IdentityEnhancedBreakdownSources
     */
    'breakdown'?: IdentityEnhancedBreakdownSourcesBreakdown;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedBreakdownSourcesBreakdown
 */
export interface IdentityEnhancedBreakdownSourcesBreakdown {
    /**
     * 
     * @type {IdentityEnhancedBreakdownSourcesBreakdownTotalSources}
     * @memberof IdentityEnhancedBreakdownSourcesBreakdown
     */
    'total_sources'?: IdentityEnhancedBreakdownSourcesBreakdownTotalSources;
}
/**
 * The number of sources which produced a match to applicant details.
 * @export
 * @interface IdentityEnhancedBreakdownSourcesBreakdownTotalSources
 */
export interface IdentityEnhancedBreakdownSourcesBreakdownTotalSources {
    /**
     * 
     * @type {string}
     * @memberof IdentityEnhancedBreakdownSourcesBreakdownTotalSources
     */
    'result'?: string;
    /**
     * 
     * @type {IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties}
     * @memberof IdentityEnhancedBreakdownSourcesBreakdownTotalSources
     */
    'properties'?: IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties
 */
export interface IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties {
    /**
     * 
     * @type {number}
     * @memberof IdentityEnhancedBreakdownSourcesBreakdownTotalSourcesProperties
     */
    'total_number_of_sources'?: number;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedProperties
 */
export interface IdentityEnhancedProperties {
    /**
     * Returns address number which has been matched.
     * @type {number}
     * @memberof IdentityEnhancedProperties
     */
    'matched_address'?: number;
    /**
     * Returns array of sources which contain matched addresses for the corresponding address number.
     * @type {Array<IdentityEnhancedPropertiesMatchedAddressesInner>}
     * @memberof IdentityEnhancedProperties
     */
    'matched_addresses'?: Array<IdentityEnhancedPropertiesMatchedAddressesInner>;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedPropertiesMatchedAddressesInner
 */
export interface IdentityEnhancedPropertiesMatchedAddressesInner {
    /**
     * The address number.
     * @type {number}
     * @memberof IdentityEnhancedPropertiesMatchedAddressesInner
     */
    'id'?: number;
    /**
     * Sources which contain matched addresses.
     * @type {Array<string>}
     * @memberof IdentityEnhancedPropertiesMatchedAddressesInner
     */
    'match_types'?: Array<string>;
}
/**
 * 
 * @export
 * @interface IdentityEnhancedReport
 */
export interface IdentityEnhancedReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof IdentityEnhancedReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof IdentityEnhancedReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof IdentityEnhancedReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof IdentityEnhancedReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof IdentityEnhancedReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof IdentityEnhancedReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof IdentityEnhancedReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof IdentityEnhancedReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof IdentityEnhancedReport
     */
    'name': ReportName;
    /**
     * 
     * @type {IdentityEnhancedBreakdown}
     * @memberof IdentityEnhancedReport
     */
    'breakdown'?: IdentityEnhancedBreakdown;
    /**
     * 
     * @type {IdentityEnhancedProperties}
     * @memberof IdentityEnhancedReport
     */
    'properties'?: IdentityEnhancedProperties;
}


/**
 * 
 * @export
 * @interface IndiaPanReport
 */
export interface IndiaPanReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof IndiaPanReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof IndiaPanReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof IndiaPanReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof IndiaPanReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof IndiaPanReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof IndiaPanReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof IndiaPanReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof IndiaPanReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof IndiaPanReport
     */
    'name': ReportName;
    /**
     * 
     * @type {IndiaPanReportAllOfBreakdown}
     * @memberof IndiaPanReport
     */
    'breakdown'?: IndiaPanReportAllOfBreakdown;
    /**
     * 
     * @type {IndiaPanReportAllOfProperties}
     * @memberof IndiaPanReport
     */
    'properties'?: IndiaPanReportAllOfProperties;
}


/**
 * 
 * @export
 * @interface IndiaPanReportAllOfBreakdown
 */
export interface IndiaPanReportAllOfBreakdown {
    /**
     * 
     * @type {IndiaPanReportAllOfBreakdownDevice}
     * @memberof IndiaPanReportAllOfBreakdown
     */
    'device'?: IndiaPanReportAllOfBreakdownDevice;
}
/**
 * 
 * @export
 * @interface IndiaPanReportAllOfBreakdownDevice
 */
export interface IndiaPanReportAllOfBreakdownDevice {
    /**
     * 
     * @type {IndiaPanReportAllOfBreakdownDeviceBreakdown}
     * @memberof IndiaPanReportAllOfBreakdownDevice
     */
    'breakdown'?: IndiaPanReportAllOfBreakdownDeviceBreakdown;
}
/**
 * 
 * @export
 * @interface IndiaPanReportAllOfBreakdownDeviceBreakdown
 */
export interface IndiaPanReportAllOfBreakdownDeviceBreakdown {
    /**
     * 
     * @type {IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid}
     * @memberof IndiaPanReportAllOfBreakdownDeviceBreakdown
     */
    'pan_valid'?: IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid;
    /**
     * 
     * @type {IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid}
     * @memberof IndiaPanReportAllOfBreakdownDeviceBreakdown
     */
    'name_match'?: IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid;
}
/**
 * 
 * @export
 * @interface IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid
 */
export interface IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid {
    /**
     * 
     * @type {string}
     * @memberof IndiaPanReportAllOfBreakdownDeviceBreakdownPanValid
     */
    'result'?: string;
}
/**
 * 
 * @export
 * @interface IndiaPanReportAllOfProperties
 */
export interface IndiaPanReportAllOfProperties {
    /**
     * 
     * @type {IndiaPanReportAllOfPropertiesDevice}
     * @memberof IndiaPanReportAllOfProperties
     */
    'device'?: IndiaPanReportAllOfPropertiesDevice;
}
/**
 * 
 * @export
 * @interface IndiaPanReportAllOfPropertiesDevice
 */
export interface IndiaPanReportAllOfPropertiesDevice {
    /**
     * The applicant\'s PAN (10 digit alphanumeric number).
     * @type {string}
     * @memberof IndiaPanReportAllOfPropertiesDevice
     */
    'pan'?: string;
    /**
     * The applicant\'s full name.
     * @type {string}
     * @memberof IndiaPanReportAllOfPropertiesDevice
     */
    'full_name'?: string;
}
/**
 * 
 * @export
 * @interface KnownFacesBreakdown
 */
export interface KnownFacesBreakdown {
    /**
     * 
     * @type {KnownFacesBreakdownPreviouslySeenFaces}
     * @memberof KnownFacesBreakdown
     */
    'previously_seen_faces'?: KnownFacesBreakdownPreviouslySeenFaces;
    /**
     * 
     * @type {KnownFacesBreakdownImageIntegrity}
     * @memberof KnownFacesBreakdown
     */
    'image_integrity'?: KnownFacesBreakdownImageIntegrity;
}
/**
 * Asserts whether the uploaded live photo or live video and the content contained within it were of sufficient quality to perform a face comparison.
 * @export
 * @interface KnownFacesBreakdownImageIntegrity
 */
export interface KnownFacesBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof KnownFacesBreakdownImageIntegrity
     */
    'result'?: string;
}
/**
 * Asserts whether the applicant\'s most recent facial media (live photo or live video) matches any other live photos or live videos already in your Onfido account database.
 * @export
 * @interface KnownFacesBreakdownPreviouslySeenFaces
 */
export interface KnownFacesBreakdownPreviouslySeenFaces {
    /**
     * 
     * @type {string}
     * @memberof KnownFacesBreakdownPreviouslySeenFaces
     */
    'result'?: string;
}
/**
 * 
 * @export
 * @interface KnownFacesProperties
 */
export interface KnownFacesProperties {
    /**
     * Returns any matching applicant IDs as entries inside a matches array under a properties bag.
     * @type {Array<KnownFacesPropertiesMatchesInner>}
     * @memberof KnownFacesProperties
     */
    'matches'?: Array<KnownFacesPropertiesMatchesInner>;
}
/**
 * 
 * @export
 * @interface KnownFacesPropertiesMatchesInner
 */
export interface KnownFacesPropertiesMatchesInner {
    /**
     * The applicant ID of the matched applicant.
     * @type {string}
     * @memberof KnownFacesPropertiesMatchesInner
     */
    'applicant_id'?: string;
    /**
     * A floating point number between 0 and 1 that expresses how similar the two faces are, where 1 is a perfect match.
     * @type {number}
     * @memberof KnownFacesPropertiesMatchesInner
     */
    'score'?: number;
    /**
     * The corresponding UUID for the media type.
     * @type {string}
     * @memberof KnownFacesPropertiesMatchesInner
     */
    'media_id'?: string;
    /**
     * The media type (for example live_photos or live_videos).
     * @type {string}
     * @memberof KnownFacesPropertiesMatchesInner
     */
    'media_type'?: string;
    /**
     * Indicates if match is suspected based on fuzzy name matching feature. Dependent on feature being active for account, otherwise defaults to true.
     * @type {boolean}
     * @memberof KnownFacesPropertiesMatchesInner
     */
    'suspected'?: boolean;
}
/**
 * 
 * @export
 * @interface KnownFacesReport
 */
export interface KnownFacesReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof KnownFacesReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof KnownFacesReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof KnownFacesReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof KnownFacesReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof KnownFacesReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof KnownFacesReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof KnownFacesReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof KnownFacesReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof KnownFacesReport
     */
    'name': ReportName;
    /**
     * 
     * @type {KnownFacesBreakdown}
     * @memberof KnownFacesReport
     */
    'breakdown'?: KnownFacesBreakdown;
    /**
     * 
     * @type {KnownFacesProperties}
     * @memberof KnownFacesReport
     */
    'properties'?: KnownFacesProperties;
}


/**
 * 
 * @export
 * @interface LivePhoto
 */
export interface LivePhoto {
    /**
     * The unique identifier for the photo.
     * @type {string}
     * @memberof LivePhoto
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     * @type {string}
     * @memberof LivePhoto
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof LivePhoto
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     * @type {string}
     * @memberof LivePhoto
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     * @type {string}
     * @memberof LivePhoto
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     * @type {string}
     * @memberof LivePhoto
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof LivePhoto
     */
    'file_size'?: number;
}
/**
 * 
 * @export
 * @interface LivePhotoResponse
 */
export interface LivePhotoResponse {
    /**
     * The unique identifier for the photo.
     * @type {string}
     * @memberof LivePhotoResponse
     */
    'id': string;
    /**
     * The date and time at which the photo was uploaded.
     * @type {string}
     * @memberof LivePhotoResponse
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof LivePhotoResponse
     */
    'href'?: string;
    /**
     * The uri that can be used to download the photo.
     * @type {string}
     * @memberof LivePhotoResponse
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     * @type {string}
     * @memberof LivePhotoResponse
     */
    'file_name'?: string;
    /**
     * The file type of the uploaded file.
     * @type {string}
     * @memberof LivePhotoResponse
     */
    'file_type'?: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof LivePhotoResponse
     */
    'file_size'?: number;
}
/**
 * 
 * @export
 * @interface LivePhotosList
 */
export interface LivePhotosList {
    /**
     * 
     * @type {Array<LivePhoto>}
     * @memberof LivePhotosList
     */
    'live_photos': Array<LivePhoto>;
}
/**
 * 
 * @export
 * @interface LiveVideo
 */
export interface LiveVideo {
    /**
     * The unique identifier for the video.
     * @type {string}
     * @memberof LiveVideo
     */
    'id'?: string;
    /**
     * The date and time at which the video was uploaded.
     * @type {string}
     * @memberof LiveVideo
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof LiveVideo
     */
    'href'?: string;
    /**
     * The uri that can be used to download the video.
     * @type {string}
     * @memberof LiveVideo
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     * @type {string}
     * @memberof LiveVideo
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof LiveVideo
     */
    'file_size'?: number;
    /**
     * The file type of the uploaded file.
     * @type {string}
     * @memberof LiveVideo
     */
    'file_type'?: string;
    /**
     * Challenge the end user was asked to perform during the video recording.
     * @type {Array<{ [key: string]: any; }>}
     * @memberof LiveVideo
     */
    'challenge'?: Array<{ [key: string]: any; }>;
}
/**
 * 
 * @export
 * @interface LiveVideosList
 */
export interface LiveVideosList {
    /**
     * 
     * @type {Array<LiveVideo>}
     * @memberof LiveVideosList
     */
    'live_videos': Array<LiveVideo>;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * The applicant\'s ip address.
     * @type {string}
     * @memberof Location
     */
    'ip_address'?: string;
    /**
     * The applicant\'s country of residence in 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof Location
     */
    'country_of_residence'?: CountryCodes;
}


/**
 * 
 * @export
 * @interface LocationBuilder
 */
export interface LocationBuilder {
    /**
     * The applicant\'s ip address.
     * @type {string}
     * @memberof LocationBuilder
     */
    'ip_address'?: string;
    /**
     * The applicant\'s country of residence in 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof LocationBuilder
     */
    'country_of_residence'?: CountryCodes;
}


/**
 * 
 * @export
 * @interface LocationShared
 */
export interface LocationShared {
    /**
     * The applicant\'s ip address.
     * @type {string}
     * @memberof LocationShared
     */
    'ip_address'?: string;
    /**
     * The applicant\'s country of residence in 3-letter ISO code.
     * @type {CountryCodes}
     * @memberof LocationShared
     */
    'country_of_residence'?: CountryCodes;
}


/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {ErrorProperties}
     * @memberof ModelError
     */
    'error'?: ErrorProperties;
}
/**
 * 
 * @export
 * @interface MotionCapture
 */
export interface MotionCapture {
    /**
     * The unique identifier for the motion capture.
     * @type {string}
     * @memberof MotionCapture
     */
    'id'?: string;
    /**
     * The date and time at which the motion capture was uploaded.
     * @type {string}
     * @memberof MotionCapture
     */
    'created_at'?: string;
    /**
     * The uri of this resource.
     * @type {string}
     * @memberof MotionCapture
     */
    'href'?: string;
    /**
     * The uri that can be used to download the motion capture.
     * @type {string}
     * @memberof MotionCapture
     */
    'download_href'?: string;
    /**
     * The name of the uploaded file.
     * @type {string}
     * @memberof MotionCapture
     */
    'file_name'?: string;
    /**
     * The size of the file in bytes.
     * @type {number}
     * @memberof MotionCapture
     */
    'file_size'?: number;
    /**
     * The file type of the uploaded file.
     * @type {string}
     * @memberof MotionCapture
     */
    'file_type'?: string;
}
/**
 * 
 * @export
 * @interface MotionCapturesList
 */
export interface MotionCapturesList {
    /**
     * 
     * @type {Array<MotionCapture>}
     * @memberof MotionCapturesList
     */
    'motion_captures': Array<MotionCapture>;
}
/**
 * 
 * @export
 * @interface PhotoAutoReasons
 */
export interface PhotoAutoReasons {
    /**
     * Flags when evidence is found that the image was manipulated by Photoshop, or other software.
     * @type {string}
     * @memberof PhotoAutoReasons
     */
    'digital_tampering'?: string;
    /**
     * Flags when evidence is found that a fake webcam was used.
     * @type {string}
     * @memberof PhotoAutoReasons
     */
    'fake_webcam'?: string;
    /**
     * Flags when evidence is found that the live photo was taken more than 24 hours before live photo upload.
     * @type {string}
     * @memberof PhotoAutoReasons
     */
    'time_of_capture'?: string;
    /**
     * Flags when evidence is found that an Android emulator was used.
     * @type {string}
     * @memberof PhotoAutoReasons
     */
    'emulator'?: string;
    /**
     * Additional comma separated details such as the exact digital tampering software used, or the name of the fake webcam.
     * @type {string}
     * @memberof PhotoAutoReasons
     */
    'reasons'?: string;
}
/**
 * 
 * @export
 * @interface PhotoReasons
 */
export interface PhotoReasons {
    /**
     * Flags when evidence is found that the image was manipulated by Photoshop, or other software.
     * @type {string}
     * @memberof PhotoReasons
     */
    'digital_tampering'?: string;
    /**
     * Flags when evidence is found that a fake webcam was used.
     * @type {string}
     * @memberof PhotoReasons
     */
    'fake_webcam'?: string;
    /**
     * Flags when evidence is found that the live photo was taken more than 24 hours before live photo upload.
     * @type {string}
     * @memberof PhotoReasons
     */
    'time_of_capture'?: string;
    /**
     * Flags when evidence is found that an Android emulator was used.
     * @type {string}
     * @memberof PhotoReasons
     */
    'emulator'?: string;
    /**
     * Additional comma separated details such as the exact digital tampering software used, or the name of the fake webcam.
     * @type {string}
     * @memberof PhotoReasons
     */
    'reasons'?: string;
}
/**
 * 
 * @export
 * @interface ProofOfAddressBreakdown
 */
export interface ProofOfAddressBreakdown {
    /**
     * 
     * @type {ProofOfAddressBreakdownDataComparison}
     * @memberof ProofOfAddressBreakdown
     */
    'data_comparison'?: ProofOfAddressBreakdownDataComparison;
    /**
     * 
     * @type {ProofOfAddressBreakdownDocumentClassification}
     * @memberof ProofOfAddressBreakdown
     */
    'document_classification'?: ProofOfAddressBreakdownDocumentClassification;
    /**
     * 
     * @type {ProofOfAddressBreakdownImageIntegrity}
     * @memberof ProofOfAddressBreakdown
     */
    'image_integrity'?: ProofOfAddressBreakdownImageIntegrity;
}
/**
 * Asserts whether the first name, last name and address provided by the applicant match those on the PoA document.
 * @export
 * @interface ProofOfAddressBreakdownDataComparison
 */
export interface ProofOfAddressBreakdownDataComparison {
    /**
     * 
     * @type {string}
     * @memberof ProofOfAddressBreakdownDataComparison
     */
    'result'?: string;
    /**
     * 
     * @type {ProofOfAddressBreakdownDataComparisonBreakdown}
     * @memberof ProofOfAddressBreakdownDataComparison
     */
    'breakdown'?: ProofOfAddressBreakdownDataComparisonBreakdown;
}
/**
 * 
 * @export
 * @interface ProofOfAddressBreakdownDataComparisonBreakdown
 */
export interface ProofOfAddressBreakdownDataComparisonBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof ProofOfAddressBreakdownDataComparisonBreakdown
     */
    'address'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof ProofOfAddressBreakdownDataComparisonBreakdown
     */
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof ProofOfAddressBreakdownDataComparisonBreakdown
     */
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the document is of a valid type as PoA.
 * @export
 * @interface ProofOfAddressBreakdownDocumentClassification
 */
export interface ProofOfAddressBreakdownDocumentClassification {
    /**
     * 
     * @type {string}
     * @memberof ProofOfAddressBreakdownDocumentClassification
     */
    'result'?: string;
    /**
     * 
     * @type {ProofOfAddressBreakdownDocumentClassificationBreakdown}
     * @memberof ProofOfAddressBreakdownDocumentClassification
     */
    'breakdown'?: ProofOfAddressBreakdownDocumentClassificationBreakdown;
}
/**
 * 
 * @export
 * @interface ProofOfAddressBreakdownDocumentClassificationBreakdown
 */
export interface ProofOfAddressBreakdownDocumentClassificationBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof ProofOfAddressBreakdownDocumentClassificationBreakdown
     */
    'supported_document'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the quality of the uploaded document was sufficient to verify the address.
 * @export
 * @interface ProofOfAddressBreakdownImageIntegrity
 */
export interface ProofOfAddressBreakdownImageIntegrity {
    /**
     * 
     * @type {string}
     * @memberof ProofOfAddressBreakdownImageIntegrity
     */
    'result'?: string;
    /**
     * 
     * @type {ProofOfAddressBreakdownImageIntegrityBreakdown}
     * @memberof ProofOfAddressBreakdownImageIntegrity
     */
    'breakdown'?: ProofOfAddressBreakdownImageIntegrityBreakdown;
}
/**
 * 
 * @export
 * @interface ProofOfAddressBreakdownImageIntegrityBreakdown
 */
export interface ProofOfAddressBreakdownImageIntegrityBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof ProofOfAddressBreakdownImageIntegrityBreakdown
     */
    'image_quality'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * 
 * @export
 * @interface ProofOfAddressProperties
 */
export interface ProofOfAddressProperties {
    /**
     * This property provides the address on the document.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'address'?: string;
    /**
     * This property provides the document type according to the set of supported documents.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'document_type'?: ProofOfAddressPropertiesDocumentTypeEnum;
    /**
     * This property provides the first names on the document, including any initials and middle names.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'first_names'?: string;
    /**
     * This property provided the last names on the document.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'last_names'?: string;
    /**
     * This property provides the issue date of the document.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'issue_date'?: string;
    /**
     * This property provides the document issuer (e.g. HSBC, British Gas).
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'issuer'?: string;
    /**
     * This property provides the summary period start date.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'summary_period_start'?: string;
    /**
     * This property provides the summary period end date.
     * @type {string}
     * @memberof ProofOfAddressProperties
     */
    'summary_period_end'?: string;
}

export const ProofOfAddressPropertiesDocumentTypeEnum = {
    BankBuildingSocietyStatement: 'bank_building_society_statement',
    UtilityBill: 'utility_bill',
    CouncilTax: 'council_tax',
    BenefitLetters: 'benefit_letters',
    MortgageStatement: 'mortgage_statement',
    MobilePhoneBill: 'mobile_phone_bill',
    GeneralLetter: 'general_letter',
    InsuranceStatement: 'insurance_statement',
    PensionPropertyStatementLetter: 'pension_property_statement_letter',
    IdentityDocumentWithAddress: 'identity_document_with_address',
    ExchangeHouseStatement: 'exchange_house_statement',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ProofOfAddressPropertiesDocumentTypeEnum = typeof ProofOfAddressPropertiesDocumentTypeEnum[keyof typeof ProofOfAddressPropertiesDocumentTypeEnum];

/**
 * 
 * @export
 * @interface ProofOfAddressReport
 */
export interface ProofOfAddressReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof ProofOfAddressReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof ProofOfAddressReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof ProofOfAddressReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof ProofOfAddressReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof ProofOfAddressReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof ProofOfAddressReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof ProofOfAddressReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof ProofOfAddressReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof ProofOfAddressReport
     */
    'name': ReportName;
    /**
     * 
     * @type {ProofOfAddressBreakdown}
     * @memberof ProofOfAddressReport
     */
    'breakdown'?: ProofOfAddressBreakdown;
    /**
     * 
     * @type {ProofOfAddressProperties}
     * @memberof ProofOfAddressReport
     */
    'properties'?: ProofOfAddressProperties;
}


/**
 * 
 * @export
 * @interface RepeatAttemptsList
 */
export interface RepeatAttemptsList {
    /**
     * The unique identifier of the completed Document report.
     * @type {string}
     * @memberof RepeatAttemptsList
     */
    'report_id'?: string;
    /**
     * An array of repeat attempt objects. If no repeat attempts were found, the array will be empty. The number of objects returned can increase over time if more matches are received. 
     * @type {Array<RepeatAttemptsListRepeatAttemptsInner>}
     * @memberof RepeatAttemptsList
     */
    'repeat_attempts': Array<RepeatAttemptsListRepeatAttemptsInner>;
    /**
     * The total number of attempts using the same document, including the current report under assessment.
     * @type {number}
     * @memberof RepeatAttemptsList
     */
    'attempts_count'?: number;
    /**
     * A number between 0 and 1 which indicates the proportion of attempts that have been cleared, including the current report under assessment.
     * @type {number}
     * @memberof RepeatAttemptsList
     */
    'attempts_clear_rate'?: number;
    /**
     * The number of unique entries in the repeat_attempts field for which at least one of the fields is a mismatch.
     * @type {number}
     * @memberof RepeatAttemptsList
     */
    'unique_mismatches_count'?: number;
}
/**
 * 
 * @export
 * @interface RepeatAttemptsListRepeatAttemptsInner
 */
export interface RepeatAttemptsListRepeatAttemptsInner {
    /**
     * The unique identifier of the matching Document report.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'report_id'?: string;
    /**
     * The unique identifier of the applicant for the matching Document report.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'applicant_id'?: string;
    /**
     * Whether the dates of birth are exactly the same or are different.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'date_of_birth'?: RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum;
    /**
     * Whether the names are exactly the same or are different.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'names'?: RepeatAttemptsListRepeatAttemptsInnerNamesEnum;
    /**
     * The report result of this attempt.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'result'?: RepeatAttemptsListRepeatAttemptsInnerResultEnum;
    /**
     * When the matching report was created.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'created_at'?: string;
    /**
     * When the matching report was completed.
     * @type {string}
     * @memberof RepeatAttemptsListRepeatAttemptsInner
     */
    'completed_at'?: string;
}

export const RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum = typeof RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum[keyof typeof RepeatAttemptsListRepeatAttemptsInnerDateOfBirthEnum];
export const RepeatAttemptsListRepeatAttemptsInnerNamesEnum = {
    Match: 'match',
    Mismatch: 'mismatch',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RepeatAttemptsListRepeatAttemptsInnerNamesEnum = typeof RepeatAttemptsListRepeatAttemptsInnerNamesEnum[keyof typeof RepeatAttemptsListRepeatAttemptsInnerNamesEnum];
export const RepeatAttemptsListRepeatAttemptsInnerResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RepeatAttemptsListRepeatAttemptsInnerResultEnum = typeof RepeatAttemptsListRepeatAttemptsInnerResultEnum[keyof typeof RepeatAttemptsListRepeatAttemptsInnerResultEnum];

/**
 * @type Report
 * @export
 */
export type Report = { name: 'device_intelligence' } & DeviceIntelligenceReport | { name: 'document' } & DocumentReport | { name: 'document_video' } & DocumentVideoReport | { name: 'document_video_with_address_information' } & DocumentVideoWithAddressInformationReport | { name: 'document_with_address_information' } & DocumentWithAddressInformationReport | { name: 'document_with_driver_verification' } & DocumentWithDriverVerificationReport | { name: 'document_with_driving_licence_information' } & DocumentWithDrivingLicenceInformationReport | { name: 'facial_similarity_motion' } & FacialSimilarityMotionReport | { name: 'facial_similarity_photo' } & FacialSimilarityPhotoReport | { name: 'facial_similarity_photo_fully_auto' } & FacialSimilarityPhotoFullyAutoReport | { name: 'facial_similarity_video' } & FacialSimilarityVideoReport | { name: 'identity_enhanced' } & IdentityEnhancedReport | { name: 'india_pan' } & IndiaPanReport | { name: 'known_faces' } & KnownFacesReport | { name: 'proof_of_address' } & ProofOfAddressReport | { name: 'us_driving_licence' } & UsDrivingLicenceReport | { name: 'watchlist_aml' } & WatchlistAmlReport | { name: 'watchlist_enhanced' } & WatchlistEnhancedReport | { name: 'watchlist_peps_only' } & WatchlistPepsOnlyReport | { name: 'watchlist_sanctions_only' } & WatchlistSanctionsOnlyReport | { name: 'watchlist_standard' } & WatchlistStandardReport;

/**
 * 
 * @export
 * @interface ReportDocument
 */
export interface ReportDocument {
    /**
     * ID of uploaded document to use.
     * @type {string}
     * @memberof ReportDocument
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReportName = {
    Document: 'document',
    DocumentVideo: 'document_video',
    DocumentVideoWithAddressInformation: 'document_video_with_address_information',
    DocumentWithAddressInformation: 'document_with_address_information',
    DocumentWithDrivingLicenceInformation: 'document_with_driving_licence_information',
    DocumentWithDriverVerification: 'document_with_driver_verification',
    FacialSimilarityPhoto: 'facial_similarity_photo',
    FacialSimilarityPhotoFullyAuto: 'facial_similarity_photo_fully_auto',
    FacialSimilarityVideo: 'facial_similarity_video',
    FacialSimilarityMotion: 'facial_similarity_motion',
    KnownFaces: 'known_faces',
    IdentityEnhanced: 'identity_enhanced',
    WatchlistAml: 'watchlist_aml',
    WatchlistEnhanced: 'watchlist_enhanced',
    WatchlistStandard: 'watchlist_standard',
    WatchlistPepsOnly: 'watchlist_peps_only',
    WatchlistSanctionsOnly: 'watchlist_sanctions_only',
    ProofOfAddress: 'proof_of_address',
    UsDrivingLicence: 'us_driving_licence',
    DeviceIntelligence: 'device_intelligence',
    IndiaPan: 'india_pan',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportName = typeof ReportName[keyof typeof ReportName];


/**
 * The result of the report. Read-only.
 * @export
 * @enum {string}
 */

export const ReportResult = {
    Clear: 'clear',
    Consider: 'consider',
    Unidentified: 'unidentified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportResult = typeof ReportResult[keyof typeof ReportResult];


/**
 * 
 * @export
 * @interface ReportShared
 */
export interface ReportShared {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof ReportShared
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof ReportShared
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof ReportShared
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof ReportShared
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof ReportShared
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof ReportShared
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof ReportShared
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof ReportShared
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof ReportShared
     */
    'name': ReportName;
}


/**
 * The current state of the report in the checking process. Read-only.
 * @export
 * @enum {string}
 */

export const ReportStatus = {
    AwaitingData: 'awaiting_data',
    AwaitingApproval: 'awaiting_approval',
    Cancelled: 'cancelled',
    Complete: 'complete',
    Withdrawn: 'withdrawn',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportStatus = typeof ReportStatus[keyof typeof ReportStatus];


/**
 * The sub_result of the report. It gives a more detailed result for document reports only, and will be null otherwise. Read-only.
 * @export
 * @enum {string}
 */

export const ReportSubResult = {
    Clear: 'clear',
    Rejected: 'rejected',
    Suspected: 'suspected',
    Caution: 'caution',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ReportSubResult = typeof ReportSubResult[keyof typeof ReportSubResult];


/**
 * 
 * @export
 * @interface ReportsList
 */
export interface ReportsList {
    /**
     * 
     * @type {Array<Report>}
     * @memberof ReportsList
     */
    'reports': Array<Report>;
}
/**
 * 
 * @export
 * @interface ResultsFeedback
 */
export interface ResultsFeedback {
    /**
     * The expected result for the check or report.
     * @type {string}
     * @memberof ResultsFeedback
     */
    'expected_result'?: ResultsFeedbackExpectedResultEnum;
    /**
     * The ID of the check (only if report_id is not provided).
     * @type {string}
     * @memberof ResultsFeedback
     */
    'check_id'?: string;
    /**
     * The ID of the check (only if check_id is not provided).
     * @type {string}
     * @memberof ResultsFeedback
     */
    'report_id'?: string;
    /**
     * Any additional information or feedback.
     * @type {string}
     * @memberof ResultsFeedback
     */
    'feedback_notes'?: string;
}

export const ResultsFeedbackExpectedResultEnum = {
    Clear: 'clear',
    Consider: 'consider',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ResultsFeedbackExpectedResultEnum = typeof ResultsFeedbackExpectedResultEnum[keyof typeof ResultsFeedbackExpectedResultEnum];

/**
 * 
 * @export
 * @interface SdkToken
 */
export interface SdkToken {
    /**
     * The generated SDK token
     * @type {string}
     * @memberof SdkToken
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface SdkTokenBuilder
 */
export interface SdkTokenBuilder {
    /**
     * The unique identifier of the applicant
     * @type {string}
     * @memberof SdkTokenBuilder
     */
    'applicant_id': string;
    /**
     * The referrer URL pattern
     * @type {string}
     * @memberof SdkTokenBuilder
     */
    'referrer'?: string;
    /**
     * The application ID (iOS or Android)
     * @type {string}
     * @memberof SdkTokenBuilder
     */
    'application_id'?: string;
    /**
     * The URL to be used by the Web SDK for the cross device flow.
     * @type {string}
     * @memberof SdkTokenBuilder
     */
    'cross_device_url'?: string;
}
/**
 * 
 * @export
 * @interface SdkTokenRequest
 */
export interface SdkTokenRequest {
    /**
     * The unique identifier of the applicant
     * @type {string}
     * @memberof SdkTokenRequest
     */
    'applicant_id': string;
    /**
     * The referrer URL pattern
     * @type {string}
     * @memberof SdkTokenRequest
     */
    'referrer'?: string;
    /**
     * The application ID (iOS or Android)
     * @type {string}
     * @memberof SdkTokenRequest
     */
    'application_id'?: string;
    /**
     * The URL to be used by the Web SDK for the cross device flow.
     * @type {string}
     * @memberof SdkTokenRequest
     */
    'cross_device_url'?: string;
}
/**
 * 
 * @export
 * @interface SdkTokenResponse
 */
export interface SdkTokenResponse {
    /**
     * The generated SDK token
     * @type {string}
     * @memberof SdkTokenResponse
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * The identifier for the Task.
     * @type {string}
     * @memberof Task
     */
    'id'?: string;
    /**
     * The workflow run id the task belongs to.
     * @type {string}
     * @memberof Task
     */
    'workflow_run_id'?: string;
    /**
     * The identifier for the Task Definition.
     * @type {string}
     * @memberof Task
     */
    'task_def_id'?: string;
    /**
     * The task definition version.
     * @type {string}
     * @memberof Task
     */
    'task_def_version'?: string | null;
    /**
     * Input object with the fields used by the Task to execute.
     * @type {object}
     * @memberof Task
     */
    'input'?: object;
    /**
     * Output object with the fields produced by the Task execution.
     * @type {object}
     * @memberof Task
     */
    'output'?: object | null;
    /**
     * The date and time when the Task was created.
     * @type {string}
     * @memberof Task
     */
    'created_at'?: string;
    /**
     * The date and time when the Task was last updated.
     * @type {string}
     * @memberof Task
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TaskItem
 */
export interface TaskItem {
    /**
     * The identifier for the Task.
     * @type {string}
     * @memberof TaskItem
     */
    'id'?: string;
    /**
     * The identifier for the Task Definition.
     * @type {string}
     * @memberof TaskItem
     */
    'task_def_id'?: string;
    /**
     * The date and time when the Task was created.
     * @type {string}
     * @memberof TaskItem
     */
    'created_at'?: string;
    /**
     * The date and time when the Task was last updated.
     * @type {string}
     * @memberof TaskItem
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface TimelineFileReference
 */
export interface TimelineFileReference {
    /**
     * The unique identifier for the Timefile File that will be created.
     * @type {string}
     * @memberof TimelineFileReference
     */
    'workflow_timeline_file_id': string;
    /**
     * Link to access the Timefile File that will be created.
     * @type {string}
     * @memberof TimelineFileReference
     */
    'href': string;
}
/**
 * 
 * @export
 * @interface UsDrivingLicenceBreakdown
 */
export interface UsDrivingLicenceBreakdown {
    /**
     * 
     * @type {UsDrivingLicenceBreakdownDocument}
     * @memberof UsDrivingLicenceBreakdown
     */
    'document'?: UsDrivingLicenceBreakdownDocument;
    /**
     * 
     * @type {UsDrivingLicenceBreakdownAddress}
     * @memberof UsDrivingLicenceBreakdown
     */
    'address'?: UsDrivingLicenceBreakdownAddress;
    /**
     * 
     * @type {UsDrivingLicenceBreakdownPersonal}
     * @memberof UsDrivingLicenceBreakdown
     */
    'personal'?: UsDrivingLicenceBreakdownPersonal;
}
/**
 * Asserts whether the address data provided matches a real driving license in the DMV driver\'s license database.
 * @export
 * @interface UsDrivingLicenceBreakdownAddress
 */
export interface UsDrivingLicenceBreakdownAddress {
    /**
     * 
     * @type {string}
     * @memberof UsDrivingLicenceBreakdownAddress
     */
    'result'?: string;
    /**
     * 
     * @type {UsDrivingLicenceBreakdownAddressBreakdown}
     * @memberof UsDrivingLicenceBreakdownAddress
     */
    'breakdown'?: UsDrivingLicenceBreakdownAddressBreakdown;
}
/**
 * 
 * @export
 * @interface UsDrivingLicenceBreakdownAddressBreakdown
 */
export interface UsDrivingLicenceBreakdownAddressBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownAddressBreakdown
     */
    'city'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownAddressBreakdown
     */
    'line_1'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownAddressBreakdown
     */
    'line_2'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownAddressBreakdown
     */
    'state_code'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownAddressBreakdown
     */
    'zip4'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownAddressBreakdown
     */
    'zip5'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the document data provided matches a real driving license in the DMV driver\'s license database.
 * @export
 * @interface UsDrivingLicenceBreakdownDocument
 */
export interface UsDrivingLicenceBreakdownDocument {
    /**
     * 
     * @type {string}
     * @memberof UsDrivingLicenceBreakdownDocument
     */
    'result'?: string;
    /**
     * 
     * @type {UsDrivingLicenceBreakdownDocumentBreakdown}
     * @memberof UsDrivingLicenceBreakdownDocument
     */
    'breakdown'?: UsDrivingLicenceBreakdownDocumentBreakdown;
}
/**
 * 
 * @export
 * @interface UsDrivingLicenceBreakdownDocumentBreakdown
 */
export interface UsDrivingLicenceBreakdownDocumentBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownDocumentBreakdown
     */
    'category'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownDocumentBreakdown
     */
    'expiration_date'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownDocumentBreakdown
     */
    'issue_date'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownDocumentBreakdown
     */
    'document_number'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * Asserts whether the personal data provided matches a real driving license in the DMV driver\'s license database.
 * @export
 * @interface UsDrivingLicenceBreakdownPersonal
 */
export interface UsDrivingLicenceBreakdownPersonal {
    /**
     * 
     * @type {string}
     * @memberof UsDrivingLicenceBreakdownPersonal
     */
    'result'?: string;
    /**
     * 
     * @type {UsDrivingLicenceBreakdownPersonalBreakdown}
     * @memberof UsDrivingLicenceBreakdownPersonal
     */
    'breakdown'?: UsDrivingLicenceBreakdownPersonalBreakdown;
}
/**
 * 
 * @export
 * @interface UsDrivingLicenceBreakdownPersonalBreakdown
 */
export interface UsDrivingLicenceBreakdownPersonalBreakdown {
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'first_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'name_suffix'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'height'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'weight'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'sex_code'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'eye_color'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'date_of_birth'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'last_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'middle_name'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'first_name_fuzzy'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'middle_name_fuzzy'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'last_name_fuzzy'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
    /**
     * 
     * @type {DocumentBreakdownDataComparisonBreakdownIssuingCountry}
     * @memberof UsDrivingLicenceBreakdownPersonalBreakdown
     */
    'middle_initial'?: DocumentBreakdownDataComparisonBreakdownIssuingCountry;
}
/**
 * 
 * @export
 * @interface UsDrivingLicenceBuilder
 */
export interface UsDrivingLicenceBuilder {
    /**
     * Driving licence ID number
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'id_number': string;
    /**
     * Two letter code of issuing state (state-issued driving licenses only)
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'issue_state': string;
    /**
     * Line 1 of the address
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'address_line_1'?: string;
    /**
     * Line 2 of the address
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'address_line_2'?: string;
    /**
     * The city of the owner\'s address
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'city'?: string;
    /**
     * Date of birth in yyyy-mm-dd format
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'date_of_birth'?: string;
    /**
     * Document category.
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'document_category'?: UsDrivingLicenceBuilderDocumentCategoryEnum;
    /**
     * Expiration date of the driving licence in yyyy-mm-dd format
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'expiration_date'?: string;
    /**
     * Eye color code.
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'eye_color_code'?: UsDrivingLicenceBuilderEyeColorCodeEnum;
    /**
     * The owner\'s first name
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'gender'?: UsDrivingLicenceBuilderGenderEnum;
    /**
     * Issue date in yyyy-mm-dd format
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'issue_date'?: string;
    /**
     * The owner\'s surname
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'last_name'?: string;
    /**
     * The owner\'s middle name
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'middle_name'?: string;
    /**
     * The owner\'s name suffix
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'name_suffix'?: string;
    /**
     * The postcode or ZIP of the owner\'s address
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'postal_code'?: string;
    /**
     * 2-characters state code
     * @type {string}
     * @memberof UsDrivingLicenceBuilder
     */
    'state'?: string;
    /**
     * Weight in pounds
     * @type {number}
     * @memberof UsDrivingLicenceBuilder
     */
    'weight_measure'?: number;
}

export const UsDrivingLicenceBuilderDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceBuilderDocumentCategoryEnum = typeof UsDrivingLicenceBuilderDocumentCategoryEnum[keyof typeof UsDrivingLicenceBuilderDocumentCategoryEnum];
export const UsDrivingLicenceBuilderEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceBuilderEyeColorCodeEnum = typeof UsDrivingLicenceBuilderEyeColorCodeEnum[keyof typeof UsDrivingLicenceBuilderEyeColorCodeEnum];
export const UsDrivingLicenceBuilderGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceBuilderGenderEnum = typeof UsDrivingLicenceBuilderGenderEnum[keyof typeof UsDrivingLicenceBuilderGenderEnum];

/**
 * 
 * @export
 * @interface UsDrivingLicenceReport
 */
export interface UsDrivingLicenceReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof UsDrivingLicenceReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof UsDrivingLicenceReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof UsDrivingLicenceReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof UsDrivingLicenceReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof UsDrivingLicenceReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof UsDrivingLicenceReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof UsDrivingLicenceReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof UsDrivingLicenceReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof UsDrivingLicenceReport
     */
    'name': ReportName;
    /**
     * 
     * @type {UsDrivingLicenceBreakdown}
     * @memberof UsDrivingLicenceReport
     */
    'breakdown'?: UsDrivingLicenceBreakdown;
    /**
     * 
     * @type {DocumentProperties}
     * @memberof UsDrivingLicenceReport
     */
    'properties'?: DocumentProperties;
}


/**
 * An object that contains all accepted fields for the Driver\'s License Data Verification report.
 * @export
 * @interface UsDrivingLicenceShared
 */
export interface UsDrivingLicenceShared {
    /**
     * Driving licence ID number
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'id_number': string;
    /**
     * Two letter code of issuing state (state-issued driving licenses only)
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'issue_state': string;
    /**
     * Line 1 of the address
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'address_line_1'?: string;
    /**
     * Line 2 of the address
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'address_line_2'?: string;
    /**
     * The city of the owner\'s address
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'city'?: string;
    /**
     * Date of birth in yyyy-mm-dd format
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'date_of_birth'?: string;
    /**
     * Document category.
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'document_category'?: UsDrivingLicenceSharedDocumentCategoryEnum;
    /**
     * Expiration date of the driving licence in yyyy-mm-dd format
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'expiration_date'?: string;
    /**
     * Eye color code.
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'eye_color_code'?: UsDrivingLicenceSharedEyeColorCodeEnum;
    /**
     * The owner\'s first name
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'gender'?: UsDrivingLicenceSharedGenderEnum;
    /**
     * Issue date in yyyy-mm-dd format
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'issue_date'?: string;
    /**
     * The owner\'s surname
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'last_name'?: string;
    /**
     * The owner\'s middle name
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'middle_name'?: string;
    /**
     * The owner\'s name suffix
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'name_suffix'?: string;
    /**
     * The postcode or ZIP of the owner\'s address
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'postal_code'?: string;
    /**
     * 2-characters state code
     * @type {string}
     * @memberof UsDrivingLicenceShared
     */
    'state'?: string;
    /**
     * Weight in pounds
     * @type {number}
     * @memberof UsDrivingLicenceShared
     */
    'weight_measure'?: number;
}

export const UsDrivingLicenceSharedDocumentCategoryEnum = {
    DriverLicense: 'driver license',
    DriverPermit: 'driver permit',
    IdCard: 'id card',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceSharedDocumentCategoryEnum = typeof UsDrivingLicenceSharedDocumentCategoryEnum[keyof typeof UsDrivingLicenceSharedDocumentCategoryEnum];
export const UsDrivingLicenceSharedEyeColorCodeEnum = {
    Blk: 'BLK',
    Blu: 'BLU',
    Bro: 'BRO',
    Dic: 'DIC',
    Gry: 'GRY',
    Grn: 'GRN',
    Haz: 'HAZ',
    Mar: 'MAR',
    Pnk: 'PNK',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceSharedEyeColorCodeEnum = typeof UsDrivingLicenceSharedEyeColorCodeEnum[keyof typeof UsDrivingLicenceSharedEyeColorCodeEnum];
export const UsDrivingLicenceSharedGenderEnum = {
    Male: 'Male',
    Female: 'Female',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type UsDrivingLicenceSharedGenderEnum = typeof UsDrivingLicenceSharedGenderEnum[keyof typeof UsDrivingLicenceSharedGenderEnum];

/**
 * 
 * @export
 * @interface VideoReasons
 */
export interface VideoReasons {
    /**
     * Flags when evidence is found that a fake webcam was used.
     * @type {string}
     * @memberof VideoReasons
     */
    'fake_webcam'?: string;
    /**
     * Flags when evidence is found that the video was uploaded in an attempt to circumvent the randomness of the speaking and head turn challenges
     * @type {string}
     * @memberof VideoReasons
     */
    'challenge_reuse'?: string;
    /**
     * Flags when evidence is found that an Android emulator was used.
     * @type {string}
     * @memberof VideoReasons
     */
    'emulator'?: string;
    /**
     * Additional comma separated details such as the name of the fake webcam.
     * @type {string}
     * @memberof VideoReasons
     */
    'reasons'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistAmlBreakdown
 */
export interface WatchlistAmlBreakdown {
    /**
     * 
     * @type {WatchlistAmlBreakdownSanction}
     * @memberof WatchlistAmlBreakdown
     */
    'sanction'?: WatchlistAmlBreakdownSanction;
    /**
     * 
     * @type {WatchlistAmlBreakdownPoliticallyExposedPerson}
     * @memberof WatchlistAmlBreakdown
     */
    'politically_exposed_person'?: WatchlistAmlBreakdownPoliticallyExposedPerson;
    /**
     * 
     * @type {WatchlistAmlBreakdownLegalAndRegulatoryWarnings}
     * @memberof WatchlistAmlBreakdown
     */
    'legal_and_regulatory_warnings'?: WatchlistAmlBreakdownLegalAndRegulatoryWarnings;
    /**
     * 
     * @type {WatchlistAmlBreakdownAdverseMedia}
     * @memberof WatchlistAmlBreakdown
     */
    'adverse_media'?: WatchlistAmlBreakdownAdverseMedia;
}
/**
 * Asserts if there are any records found of negative events reported by publicly and generally available media sources.
 * @export
 * @interface WatchlistAmlBreakdownAdverseMedia
 */
export interface WatchlistAmlBreakdownAdverseMedia {
    /**
     * 
     * @type {string}
     * @memberof WatchlistAmlBreakdownAdverseMedia
     */
    'result'?: string;
}
/**
 * Asserts if there are any records found in Law-Enforcement and Regulatory bodies Monitored Lists (including Terrorism, Money Laundering and Most Wanted lists).
 * @export
 * @interface WatchlistAmlBreakdownLegalAndRegulatoryWarnings
 */
export interface WatchlistAmlBreakdownLegalAndRegulatoryWarnings {
    /**
     * 
     * @type {string}
     * @memberof WatchlistAmlBreakdownLegalAndRegulatoryWarnings
     */
    'result'?: string;
}
/**
 * Asserts if there are any records found in the proprietary database of Politically Exposed Persons sourced from government lists, websites and other media sources.
 * @export
 * @interface WatchlistAmlBreakdownPoliticallyExposedPerson
 */
export interface WatchlistAmlBreakdownPoliticallyExposedPerson {
    /**
     * 
     * @type {string}
     * @memberof WatchlistAmlBreakdownPoliticallyExposedPerson
     */
    'result'?: string;
}
/**
 * Asserts if there are any records found in Government and International Organisations Sanctions Lists.
 * @export
 * @interface WatchlistAmlBreakdownSanction
 */
export interface WatchlistAmlBreakdownSanction {
    /**
     * 
     * @type {string}
     * @memberof WatchlistAmlBreakdownSanction
     */
    'result'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistAmlProperties
 */
export interface WatchlistAmlProperties {
    /**
     * Returns any matches including, but not limited to, name and date of birth of match, aliases and associates, and relevant events and sources.
     * @type {Array<string>}
     * @memberof WatchlistAmlProperties
     */
    'records'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WatchlistAmlReport
 */
export interface WatchlistAmlReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof WatchlistAmlReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof WatchlistAmlReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof WatchlistAmlReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof WatchlistAmlReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof WatchlistAmlReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof WatchlistAmlReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof WatchlistAmlReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof WatchlistAmlReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof WatchlistAmlReport
     */
    'name': ReportName;
    /**
     * 
     * @type {WatchlistAmlBreakdown}
     * @memberof WatchlistAmlReport
     */
    'breakdown'?: WatchlistAmlBreakdown;
    /**
     * 
     * @type {WatchlistAmlProperties}
     * @memberof WatchlistAmlReport
     */
    'properties'?: WatchlistAmlProperties;
}


/**
 * 
 * @export
 * @interface WatchlistEnhancedBreakdown
 */
export interface WatchlistEnhancedBreakdown {
    /**
     * 
     * @type {WatchlistAmlBreakdownPoliticallyExposedPerson}
     * @memberof WatchlistEnhancedBreakdown
     */
    'politically_exposed_person'?: WatchlistAmlBreakdownPoliticallyExposedPerson;
    /**
     * 
     * @type {WatchlistAmlBreakdownSanction}
     * @memberof WatchlistEnhancedBreakdown
     */
    'sanction'?: WatchlistAmlBreakdownSanction;
    /**
     * 
     * @type {WatchlistAmlBreakdownAdverseMedia}
     * @memberof WatchlistEnhancedBreakdown
     */
    'adverse_media'?: WatchlistAmlBreakdownAdverseMedia;
    /**
     * 
     * @type {WatchlistAmlBreakdownLegalAndRegulatoryWarnings}
     * @memberof WatchlistEnhancedBreakdown
     */
    'monitored_lists'?: WatchlistAmlBreakdownLegalAndRegulatoryWarnings;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedProperties
 */
export interface WatchlistEnhancedProperties {
    /**
     * Returns any matches including, but not limited to, name and date of birth of match, aliases and associates, and relevant events and sources.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInner>}
     * @memberof WatchlistEnhancedProperties
     */
    'records'?: Array<WatchlistEnhancedPropertiesRecordsInner>;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInner
 */
export interface WatchlistEnhancedPropertiesRecordsInner {
    /**
     * All addresses on file.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInnerAddressInner>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'address'?: Array<WatchlistEnhancedPropertiesRecordsInnerAddressInner>;
    /**
     * Any names that the person is also known as.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInnerAliasInner>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'alias'?: Array<WatchlistEnhancedPropertiesRecordsInnerAliasInner>;
    /**
     * Any linked persons, for example family relatives or business partners.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInnerAssociateInner>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'associate'?: Array<WatchlistEnhancedPropertiesRecordsInnerAssociateInner>;
    /**
     * Information about the person, for example hair color or nationality.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInnerAttributeInner>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'attribute'?: Array<WatchlistEnhancedPropertiesRecordsInnerAttributeInner>;
    /**
     * All the date of births on file.
     * @type {Array<string>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'date_of_birth'?: Array<string>;
    /**
     * Information about events that have occurred to the person, for example deportation or arrest.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInnerEventInner>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'event'?: Array<WatchlistEnhancedPropertiesRecordsInnerEventInner>;
    /**
     * The name on file
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'full_name'?: string;
    /**
     * The role, country and date of each position.
     * @type {Array<string>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'position'?: Array<string>;
    /**
     * Details about where the information was obtained.
     * @type {Array<WatchlistEnhancedPropertiesRecordsInnerSourceInner>}
     * @memberof WatchlistEnhancedPropertiesRecordsInner
     */
    'source'?: Array<WatchlistEnhancedPropertiesRecordsInnerSourceInner>;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerAddressInner
 */
export interface WatchlistEnhancedPropertiesRecordsInnerAddressInner {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAddressInner
     */
    'address_line1'?: string;
    /**
     * 
     * @type {CountryCodes}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAddressInner
     */
    'country'?: CountryCodes;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAddressInner
     */
    'postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAddressInner
     */
    'state_province'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAddressInner
     */
    'town'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAddressInner
     */
    'locator_type'?: string;
}


/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerAliasInner
 */
export interface WatchlistEnhancedPropertiesRecordsInnerAliasInner {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAliasInner
     */
    'alias_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAliasInner
     */
    'alias_type'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerAssociateInner
 */
export interface WatchlistEnhancedPropertiesRecordsInnerAssociateInner {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAssociateInner
     */
    'entity_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAssociateInner
     */
    'relationship_direction'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAssociateInner
     */
    'relationship_type'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerAttributeInner
 */
export interface WatchlistEnhancedPropertiesRecordsInnerAttributeInner {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAttributeInner
     */
    'attribute_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerAttributeInner
     */
    'attribute_value'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerEventInner
 */
export interface WatchlistEnhancedPropertiesRecordsInnerEventInner {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInner
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInner
     */
    'event_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInner
     */
    'event_description'?: string;
    /**
     * 
     * @type {WatchlistEnhancedPropertiesRecordsInnerEventInnerSource}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInner
     */
    'source'?: WatchlistEnhancedPropertiesRecordsInnerEventInnerSource;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInner
     */
    'sub_category'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerEventInnerSource
 */
export interface WatchlistEnhancedPropertiesRecordsInnerEventInnerSource {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInnerSource
     */
    'source_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInnerSource
     */
    'source_format'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInnerSource
     */
    'source_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerEventInnerSource
     */
    'source_url'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedPropertiesRecordsInnerSourceInner
 */
export interface WatchlistEnhancedPropertiesRecordsInnerSourceInner {
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerSourceInner
     */
    'source_headline'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerSourceInner
     */
    'source_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerSourceInner
     */
    'source_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof WatchlistEnhancedPropertiesRecordsInnerSourceInner
     */
    'source_format'?: string;
}
/**
 * 
 * @export
 * @interface WatchlistEnhancedReport
 */
export interface WatchlistEnhancedReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof WatchlistEnhancedReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof WatchlistEnhancedReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof WatchlistEnhancedReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof WatchlistEnhancedReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof WatchlistEnhancedReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof WatchlistEnhancedReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof WatchlistEnhancedReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof WatchlistEnhancedReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof WatchlistEnhancedReport
     */
    'name': ReportName;
    /**
     * 
     * @type {WatchlistEnhancedBreakdown}
     * @memberof WatchlistEnhancedReport
     */
    'breakdown'?: WatchlistEnhancedBreakdown;
    /**
     * 
     * @type {WatchlistEnhancedProperties}
     * @memberof WatchlistEnhancedReport
     */
    'properties'?: WatchlistEnhancedProperties;
}


/**
 * 
 * @export
 * @interface WatchlistMonitor
 */
export interface WatchlistMonitor {
    /**
     * The ID for the applicant associated with the monitor.
     * @type {string}
     * @memberof WatchlistMonitor
     */
    'applicant_id': string;
    /**
     * The name of the report type the monitor creates.
     * @type {string}
     * @memberof WatchlistMonitor
     */
    'report_name': WatchlistMonitorReportNameEnum;
    /**
     * A list of tags associated with this monitor. These tags will be applied to each check this monitor creates.
     * @type {Array<string>}
     * @memberof WatchlistMonitor
     */
    'tags'?: Array<string>;
    /**
     * The unique identifier for the monitor.
     * @type {string}
     * @memberof WatchlistMonitor
     */
    'id': string;
    /**
     * The date and time at which the monitor was created.
     * @type {string}
     * @memberof WatchlistMonitor
     */
    'created_at'?: string;
    /**
     * The date and time at which the monitor was deleted. If the monitor is still active, this field will be null.
     * @type {string}
     * @memberof WatchlistMonitor
     */
    'deleted_at'?: string;
    /**
     * Indicates whether the object was created in the sandbox or not.
     * @type {boolean}
     * @memberof WatchlistMonitor
     */
    'is_sandbox'?: boolean;
}

export const WatchlistMonitorReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WatchlistMonitorReportNameEnum = typeof WatchlistMonitorReportNameEnum[keyof typeof WatchlistMonitorReportNameEnum];

/**
 * 
 * @export
 * @interface WatchlistMonitorBuilder
 */
export interface WatchlistMonitorBuilder {
    /**
     * The ID for the applicant associated with the monitor.
     * @type {string}
     * @memberof WatchlistMonitorBuilder
     */
    'applicant_id': string;
    /**
     * The name of the report type the monitor creates.
     * @type {string}
     * @memberof WatchlistMonitorBuilder
     */
    'report_name': WatchlistMonitorBuilderReportNameEnum;
    /**
     * A list of tags associated with this monitor. These tags will be applied to each check this monitor creates.
     * @type {Array<string>}
     * @memberof WatchlistMonitorBuilder
     */
    'tags'?: Array<string>;
}

export const WatchlistMonitorBuilderReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WatchlistMonitorBuilderReportNameEnum = typeof WatchlistMonitorBuilderReportNameEnum[keyof typeof WatchlistMonitorBuilderReportNameEnum];

/**
 * 
 * @export
 * @interface WatchlistMonitorMatch
 */
export interface WatchlistMonitorMatch {
    /**
     * Monitor ID
     * @type {string}
     * @memberof WatchlistMonitorMatch
     */
    'id'?: string;
    /**
     * Monitor status
     * @type {boolean}
     * @memberof WatchlistMonitorMatch
     */
    'enabled'?: boolean;
}
/**
 * 
 * @export
 * @interface WatchlistMonitorMatchesList
 */
export interface WatchlistMonitorMatchesList {
    /**
     * 
     * @type {Array<WatchlistMonitorMatch>}
     * @memberof WatchlistMonitorMatchesList
     */
    'matches': Array<WatchlistMonitorMatch>;
}
/**
 * 
 * @export
 * @interface WatchlistMonitorMatchesUpdater
 */
export interface WatchlistMonitorMatchesUpdater {
    /**
     * 
     * @type {Array<string>}
     * @memberof WatchlistMonitorMatchesUpdater
     */
    'enable'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WatchlistMonitorMatchesUpdater
     */
    'disable'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WatchlistMonitorResponse
 */
export interface WatchlistMonitorResponse {
    /**
     * The unique identifier for the monitor.
     * @type {string}
     * @memberof WatchlistMonitorResponse
     */
    'id': string;
    /**
     * The date and time at which the monitor was created.
     * @type {string}
     * @memberof WatchlistMonitorResponse
     */
    'created_at'?: string;
    /**
     * The date and time at which the monitor was deleted. If the monitor is still active, this field will be null.
     * @type {string}
     * @memberof WatchlistMonitorResponse
     */
    'deleted_at'?: string;
    /**
     * Indicates whether the object was created in the sandbox or not.
     * @type {boolean}
     * @memberof WatchlistMonitorResponse
     */
    'is_sandbox'?: boolean;
}
/**
 * 
 * @export
 * @interface WatchlistMonitorShared
 */
export interface WatchlistMonitorShared {
    /**
     * The ID for the applicant associated with the monitor.
     * @type {string}
     * @memberof WatchlistMonitorShared
     */
    'applicant_id': string;
    /**
     * The name of the report type the monitor creates.
     * @type {string}
     * @memberof WatchlistMonitorShared
     */
    'report_name': WatchlistMonitorSharedReportNameEnum;
    /**
     * A list of tags associated with this monitor. These tags will be applied to each check this monitor creates.
     * @type {Array<string>}
     * @memberof WatchlistMonitorShared
     */
    'tags'?: Array<string>;
}

export const WatchlistMonitorSharedReportNameEnum = {
    Standard: 'watchlist_standard',
    Aml: 'watchlist_aml',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WatchlistMonitorSharedReportNameEnum = typeof WatchlistMonitorSharedReportNameEnum[keyof typeof WatchlistMonitorSharedReportNameEnum];

/**
 * 
 * @export
 * @interface WatchlistMonitorsList
 */
export interface WatchlistMonitorsList {
    /**
     * 
     * @type {Array<WatchlistMonitor>}
     * @memberof WatchlistMonitorsList
     */
    'monitors': Array<WatchlistMonitor>;
}
/**
 * 
 * @export
 * @interface WatchlistPepsOnlyReport
 */
export interface WatchlistPepsOnlyReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof WatchlistPepsOnlyReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof WatchlistPepsOnlyReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof WatchlistPepsOnlyReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof WatchlistPepsOnlyReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof WatchlistPepsOnlyReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof WatchlistPepsOnlyReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof WatchlistPepsOnlyReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof WatchlistPepsOnlyReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof WatchlistPepsOnlyReport
     */
    'name': ReportName;
    /**
     * 
     * @type {WatchlistStandardBreakdown}
     * @memberof WatchlistPepsOnlyReport
     */
    'breakdown'?: WatchlistStandardBreakdown;
    /**
     * 
     * @type {WatchlistStandardProperties}
     * @memberof WatchlistPepsOnlyReport
     */
    'properties'?: WatchlistStandardProperties;
}


/**
 * 
 * @export
 * @interface WatchlistSanctionsOnlyReport
 */
export interface WatchlistSanctionsOnlyReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'name': ReportName;
    /**
     * 
     * @type {WatchlistStandardBreakdown}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'breakdown'?: WatchlistStandardBreakdown;
    /**
     * 
     * @type {WatchlistStandardProperties}
     * @memberof WatchlistSanctionsOnlyReport
     */
    'properties'?: WatchlistStandardProperties;
}


/**
 * 
 * @export
 * @interface WatchlistStandardBreakdown
 */
export interface WatchlistStandardBreakdown {
    /**
     * 
     * @type {WatchlistAmlBreakdownSanction}
     * @memberof WatchlistStandardBreakdown
     */
    'sanction'?: WatchlistAmlBreakdownSanction;
    /**
     * 
     * @type {WatchlistAmlBreakdownPoliticallyExposedPerson}
     * @memberof WatchlistStandardBreakdown
     */
    'politically_exposed_person'?: WatchlistAmlBreakdownPoliticallyExposedPerson;
    /**
     * 
     * @type {WatchlistAmlBreakdownLegalAndRegulatoryWarnings}
     * @memberof WatchlistStandardBreakdown
     */
    'legal_and_regulatory_warnings'?: WatchlistAmlBreakdownLegalAndRegulatoryWarnings;
}
/**
 * 
 * @export
 * @interface WatchlistStandardProperties
 */
export interface WatchlistStandardProperties {
    /**
     * Returns any matches including, but not limited to, name and date of birth of match, aliases and associates, and relevant events and sources.
     * @type {Array<string>}
     * @memberof WatchlistStandardProperties
     */
    'records'?: Array<string>;
}
/**
 * 
 * @export
 * @interface WatchlistStandardReport
 */
export interface WatchlistStandardReport {
    /**
     * The unique identifier for the report. Read-only.
     * @type {string}
     * @memberof WatchlistStandardReport
     */
    'id': string;
    /**
     * The date and time at which the report was first initiated. Read-only.
     * @type {string}
     * @memberof WatchlistStandardReport
     */
    'created_at'?: string;
    /**
     * The API endpoint to retrieve the report. Read-only.
     * @type {string}
     * @memberof WatchlistStandardReport
     */
    'href'?: string;
    /**
     * 
     * @type {ReportStatus}
     * @memberof WatchlistStandardReport
     */
    'status'?: ReportStatus;
    /**
     * 
     * @type {ReportResult}
     * @memberof WatchlistStandardReport
     */
    'result'?: ReportResult;
    /**
     * 
     * @type {ReportSubResult}
     * @memberof WatchlistStandardReport
     */
    'sub_result'?: ReportSubResult;
    /**
     * The ID of the check to which the report belongs. Read-only.
     * @type {string}
     * @memberof WatchlistStandardReport
     */
    'check_id'?: string;
    /**
     * Array of objects with document ids that were used in the Onfido engine. [ONLY POPULATED FOR DOCUMENT AND FACIAL SIMILARITY REPORTS]
     * @type {Array<ReportDocument>}
     * @memberof WatchlistStandardReport
     */
    'documents'?: Array<ReportDocument>;
    /**
     * 
     * @type {ReportName}
     * @memberof WatchlistStandardReport
     */
    'name': ReportName;
    /**
     * 
     * @type {WatchlistStandardBreakdown}
     * @memberof WatchlistStandardReport
     */
    'breakdown'?: WatchlistStandardBreakdown;
    /**
     * 
     * @type {WatchlistStandardProperties}
     * @memberof WatchlistStandardReport
     */
    'properties'?: WatchlistStandardProperties;
}


/**
 * 
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * Determine if the webhook is active.
     * @type {boolean}
     * @memberof Webhook
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     * @type {Array<WebhookEventType>}
     * @memberof Webhook
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are “sandbox” and “live”. If the environments parameter is omitted the webhook will receive events from both environments. 
     * @type {Array<string>}
     * @memberof Webhook
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     * @type {number}
     * @memberof Webhook
     */
    'payload_version'?: number;
    /**
     * The unique identifier of the webhook.
     * @type {string}
     * @memberof Webhook
     */
    'id': string;
    /**
     * The url that will listen to notifications (must be https).
     * @type {string}
     * @memberof Webhook
     */
    'url'?: string;
    /**
     * Webhook secret token used to sign the webhook\'s payload.
     * @type {string}
     * @memberof Webhook
     */
    'token'?: string;
    /**
     * The API endpoint to retrieve the webhook.
     * @type {string}
     * @memberof Webhook
     */
    'href'?: string;
}
/**
 * 
 * @export
 * @interface WebhookBuilder
 */
export interface WebhookBuilder {
    /**
     * Determine if the webhook is active.
     * @type {boolean}
     * @memberof WebhookBuilder
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     * @type {Array<WebhookEventType>}
     * @memberof WebhookBuilder
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are “sandbox” and “live”. If the environments parameter is omitted the webhook will receive events from both environments. 
     * @type {Array<string>}
     * @memberof WebhookBuilder
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     * @type {number}
     * @memberof WebhookBuilder
     */
    'payload_version'?: number;
    /**
     * The url that will listen to notifications (must be https).
     * @type {string}
     * @memberof WebhookBuilder
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebhookCreate
 */
export interface WebhookCreate {
    /**
     * The url that will listen to notifications (must be https).
     * @type {string}
     * @memberof WebhookCreate
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface WebhookEvent
 */
export interface WebhookEvent {
    /**
     * 
     * @type {WebhookEventPayload}
     * @memberof WebhookEvent
     */
    'payload'?: WebhookEventPayload;
}
/**
 * 
 * @export
 * @interface WebhookEventPayload
 */
export interface WebhookEventPayload {
    /**
     * Indicates the resource affected by this event.
     * @type {string}
     * @memberof WebhookEventPayload
     */
    'resource_type': string;
    /**
     * The event that triggered this webhook.
     * @type {WebhookEventType}
     * @memberof WebhookEventPayload
     */
    'action'?: WebhookEventType;
    /**
     * 
     * @type {WebhookEventPayloadObject}
     * @memberof WebhookEventPayload
     */
    'object'?: WebhookEventPayloadObject;
    /**
     * The resource affected by this event.
     * @type {object}
     * @memberof WebhookEventPayload
     */
    'resource'?: object;
}


/**
 * The object affected by this event.
 * @export
 * @interface WebhookEventPayloadObject
 */
export interface WebhookEventPayloadObject {
    /**
     * The unique identifier of the resource.
     * @type {string}
     * @memberof WebhookEventPayloadObject
     */
    'id': string;
    /**
     * The current state of the object, if available.
     * @type {string}
     * @memberof WebhookEventPayloadObject
     */
    'status'?: string;
    /**
     * The date and time when the operation was started, if available.
     * @type {string}
     * @memberof WebhookEventPayloadObject
     */
    'started_at_iso8601'?: string;
    /**
     * The date and time when the operation was completed, if available.
     * @type {string}
     * @memberof WebhookEventPayloadObject
     */
    'completed_at_iso8601'?: string;
    /**
     * The uri of the resource.
     * @type {string}
     * @memberof WebhookEventPayloadObject
     */
    'href': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WebhookEventType = {
    AuditLogCreated: 'audit_log.created',
    WatchlistMonitorMatchesUpdated: 'watchlist_monitor.matches_updated',
    WorkflowRunCompleted: 'workflow_run.completed',
    WorkflowTaskStarted: 'workflow_task.started',
    WorkflowTaskCompleted: 'workflow_task.completed',
    CheckStarted: 'check.started',
    CheckReopened: 'check.reopened',
    CheckWithdrawn: 'check.withdrawn',
    CheckCompleted: 'check.completed',
    CheckFormCompleted: 'check.form_completed',
    ReportWithdrawn: 'report.withdrawn',
    ReportResumed: 'report.resumed',
    ReportCancelled: 'report.cancelled',
    ReportAwaitingApproval: 'report.awaiting_approval',
    ReportCompleted: 'report.completed',
    WorkflowTimelineFileCreated: 'workflow_timeline_file.created',
    WorkflowSignedEvidenceFileCreated: 'workflow_signed_evidence_file.created',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WebhookEventType = typeof WebhookEventType[keyof typeof WebhookEventType];


/**
 * 
 * @export
 * @interface WebhookResend
 */
export interface WebhookResend {
    /**
     * 
     * @type {Array<WebhooksResendItem>}
     * @memberof WebhookResend
     */
    'data'?: Array<WebhooksResendItem>;
}
/**
 * 
 * @export
 * @interface WebhookResponse
 */
export interface WebhookResponse {
    /**
     * The unique identifier of the webhook.
     * @type {string}
     * @memberof WebhookResponse
     */
    'id': string;
    /**
     * The url that will listen to notifications (must be https).
     * @type {string}
     * @memberof WebhookResponse
     */
    'url'?: string;
    /**
     * Webhook secret token used to sign the webhook\'s payload.
     * @type {string}
     * @memberof WebhookResponse
     */
    'token'?: string;
    /**
     * The API endpoint to retrieve the webhook.
     * @type {string}
     * @memberof WebhookResponse
     */
    'href'?: string;
}
/**
 * 
 * @export
 * @interface WebhookShared
 */
export interface WebhookShared {
    /**
     * Determine if the webhook is active.
     * @type {boolean}
     * @memberof WebhookShared
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     * @type {Array<WebhookEventType>}
     * @memberof WebhookShared
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are “sandbox” and “live”. If the environments parameter is omitted the webhook will receive events from both environments. 
     * @type {Array<string>}
     * @memberof WebhookShared
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     * @type {number}
     * @memberof WebhookShared
     */
    'payload_version'?: number;
}
/**
 * 
 * @export
 * @interface WebhookUpdate
 */
export interface WebhookUpdate {
    /**
     * The url that will listen to notifications (must be https).
     * @type {string}
     * @memberof WebhookUpdate
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface WebhookUpdater
 */
export interface WebhookUpdater {
    /**
     * Determine if the webhook is active.
     * @type {boolean}
     * @memberof WebhookUpdater
     */
    'enabled'?: boolean;
    /**
     * The events that will be published to the webhook. If the events parameter is omitted all the events will be subscribed. 
     * @type {Array<WebhookEventType>}
     * @memberof WebhookUpdater
     */
    'events'?: Array<WebhookEventType>;
    /**
     * The environments from which the webhook will receive events. Allowed values are “sandbox” and “live”. If the environments parameter is omitted the webhook will receive events from both environments. 
     * @type {Array<string>}
     * @memberof WebhookUpdater
     */
    'environments'?: Array<string>;
    /**
     * Webhook version used to control the payload object when sending webhooks.
     * @type {number}
     * @memberof WebhookUpdater
     */
    'payload_version'?: number;
    /**
     * The url that will listen to notifications (must be https).
     * @type {string}
     * @memberof WebhookUpdater
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface WebhooksList
 */
export interface WebhooksList {
    /**
     * 
     * @type {Array<Webhook>}
     * @memberof WebhooksList
     */
    'webhooks': Array<Webhook>;
}
/**
 * 
 * @export
 * @interface WebhooksResendItem
 */
export interface WebhooksResendItem {
    /**
     * ID of the resource whose webhooks are to be retriggered.
     * @type {string}
     * @memberof WebhooksResendItem
     */
    'resource_id': string;
    /**
     * The events that should retrigger webhooks. Accepts values check.completed.
     * @type {WebhookEventType}
     * @memberof WebhooksResendItem
     */
    'event': WebhookEventType;
}


/**
 * 
 * @export
 * @interface WorkflowRun
 */
export interface WorkflowRun {
    /**
     * The unique identifier for the Applicant.
     * @type {string}
     * @memberof WorkflowRun
     */
    'applicant_id': string;
    /**
     * The unique identifier for the Workflow.
     * @type {string}
     * @memberof WorkflowRun
     */
    'workflow_id': string;
    /**
     * Tags or labels assigned to the workflow run.
     * @type {Array<string>}
     * @memberof WorkflowRun
     */
    'tags'?: Array<string> | null;
    /**
     * Customer-provided user identifier.
     * @type {string}
     * @memberof WorkflowRun
     */
    'customer_user_id'?: string;
    /**
     * 
     * @type {WorkflowRunSharedLink}
     * @memberof WorkflowRun
     */
    'link'?: WorkflowRunSharedLink;
    /**
     * The date and time when the Workflow Run was created.
     * @type {string}
     * @memberof WorkflowRun
     */
    'created_at'?: string;
    /**
     * The date and time when the Workflow Run was last updated.
     * @type {string}
     * @memberof WorkflowRun
     */
    'updated_at'?: string;
    /**
     * The unique identifier for the Workflow Run.
     * @type {string}
     * @memberof WorkflowRun
     */
    'id': string;
    /**
     * The identifier for the Workflow version.
     * @type {number}
     * @memberof WorkflowRun
     */
    'workflow_version_id'?: number;
    /**
     * The URL for viewing the Workflow Run results on your Onfido Dashboard.
     * @type {string}
     * @memberof WorkflowRun
     */
    'dashboard_url'?: string;
    /**
     * The status of the Workflow Run.
     * @type {string}
     * @memberof WorkflowRun
     */
    'status'?: WorkflowRunStatusEnum;
    /**
     * Output object contains all of the properties configured on the Workflow version.
     * @type {object}
     * @memberof WorkflowRun
     */
    'output'?: object;
    /**
     * The reasons the Workflow Run outcome was reached. Configurable when creating the Workflow version.
     * @type {Array<string>}
     * @memberof WorkflowRun
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {WorkflowRunResponseError}
     * @memberof WorkflowRun
     */
    'error'?: WorkflowRunResponseError;
    /**
     * Client token to use when loading this workflow run in the Onfido SDK.
     * @type {string}
     * @memberof WorkflowRun
     */
    'sdk_token'?: string | null;
}

export const WorkflowRunStatusEnum = {
    AwaitingInput: 'awaiting_input',
    Processing: 'processing',
    Abandoned: 'abandoned',
    Error: 'error',
    Approved: 'approved',
    Review: 'review',
    Declined: 'declined',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WorkflowRunStatusEnum = typeof WorkflowRunStatusEnum[keyof typeof WorkflowRunStatusEnum];

/**
 * 
 * @export
 * @interface WorkflowRunBuilder
 */
export interface WorkflowRunBuilder {
    /**
     * The unique identifier for the Applicant.
     * @type {string}
     * @memberof WorkflowRunBuilder
     */
    'applicant_id': string;
    /**
     * The unique identifier for the Workflow.
     * @type {string}
     * @memberof WorkflowRunBuilder
     */
    'workflow_id': string;
    /**
     * Tags or labels assigned to the workflow run.
     * @type {Array<string>}
     * @memberof WorkflowRunBuilder
     */
    'tags'?: Array<string> | null;
    /**
     * Customer-provided user identifier.
     * @type {string}
     * @memberof WorkflowRunBuilder
     */
    'customer_user_id'?: string;
    /**
     * 
     * @type {WorkflowRunSharedLink}
     * @memberof WorkflowRunBuilder
     */
    'link'?: WorkflowRunSharedLink;
    /**
     * The date and time when the Workflow Run was created.
     * @type {string}
     * @memberof WorkflowRunBuilder
     */
    'created_at'?: string;
    /**
     * The date and time when the Workflow Run was last updated.
     * @type {string}
     * @memberof WorkflowRunBuilder
     */
    'updated_at'?: string;
    /**
     * Object with Custom Input Data to be used in the Workflow Run.
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowRunBuilder
     */
    'custom_data'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WorkflowRunRequest
 */
export interface WorkflowRunRequest {
    /**
     * Object with Custom Input Data to be used in the Workflow Run.
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowRunRequest
     */
    'custom_data'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface WorkflowRunResponse
 */
export interface WorkflowRunResponse {
    /**
     * The unique identifier for the Workflow Run.
     * @type {string}
     * @memberof WorkflowRunResponse
     */
    'id': string;
    /**
     * The identifier for the Workflow version.
     * @type {number}
     * @memberof WorkflowRunResponse
     */
    'workflow_version_id'?: number;
    /**
     * The URL for viewing the Workflow Run results on your Onfido Dashboard.
     * @type {string}
     * @memberof WorkflowRunResponse
     */
    'dashboard_url'?: string;
    /**
     * The status of the Workflow Run.
     * @type {string}
     * @memberof WorkflowRunResponse
     */
    'status'?: WorkflowRunResponseStatusEnum;
    /**
     * Output object contains all of the properties configured on the Workflow version.
     * @type {object}
     * @memberof WorkflowRunResponse
     */
    'output'?: object;
    /**
     * The reasons the Workflow Run outcome was reached. Configurable when creating the Workflow version.
     * @type {Array<string>}
     * @memberof WorkflowRunResponse
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {WorkflowRunResponseError}
     * @memberof WorkflowRunResponse
     */
    'error'?: WorkflowRunResponseError;
    /**
     * Client token to use when loading this workflow run in the Onfido SDK.
     * @type {string}
     * @memberof WorkflowRunResponse
     */
    'sdk_token'?: string | null;
}

export const WorkflowRunResponseStatusEnum = {
    AwaitingInput: 'awaiting_input',
    Processing: 'processing',
    Abandoned: 'abandoned',
    Error: 'error',
    Approved: 'approved',
    Review: 'review',
    Declined: 'declined',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WorkflowRunResponseStatusEnum = typeof WorkflowRunResponseStatusEnum[keyof typeof WorkflowRunResponseStatusEnum];

/**
 * Error object. Only set when the Workflow Run status is \'error\'.
 * @export
 * @interface WorkflowRunResponseError
 */
export interface WorkflowRunResponseError {
    /**
     * The type of error.
     * @type {string}
     * @memberof WorkflowRunResponseError
     */
    'type'?: string;
    /**
     * A textual description of the error.
     * @type {string}
     * @memberof WorkflowRunResponseError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowRunShared
 */
export interface WorkflowRunShared {
    /**
     * The unique identifier for the Applicant.
     * @type {string}
     * @memberof WorkflowRunShared
     */
    'applicant_id': string;
    /**
     * The unique identifier for the Workflow.
     * @type {string}
     * @memberof WorkflowRunShared
     */
    'workflow_id': string;
    /**
     * Tags or labels assigned to the workflow run.
     * @type {Array<string>}
     * @memberof WorkflowRunShared
     */
    'tags'?: Array<string> | null;
    /**
     * Customer-provided user identifier.
     * @type {string}
     * @memberof WorkflowRunShared
     */
    'customer_user_id'?: string;
    /**
     * 
     * @type {WorkflowRunSharedLink}
     * @memberof WorkflowRunShared
     */
    'link'?: WorkflowRunSharedLink;
    /**
     * The date and time when the Workflow Run was created.
     * @type {string}
     * @memberof WorkflowRunShared
     */
    'created_at'?: string;
    /**
     * The date and time when the Workflow Run was last updated.
     * @type {string}
     * @memberof WorkflowRunShared
     */
    'updated_at'?: string;
}
/**
 * Object for the configuration of the Workflow Run link.
 * @export
 * @interface WorkflowRunSharedLink
 */
export interface WorkflowRunSharedLink {
    /**
     * Link to access the Workflow Run without the need to integrate with Onfido\'s SDKs.
     * @type {string}
     * @memberof WorkflowRunSharedLink
     */
    'url'?: string;
    /**
     * When the interactive section of the Workflow Run has completed successfully, the user will be redirected to this URL instead of seeing the default Onfido \'thank you\' page.
     * @type {string}
     * @memberof WorkflowRunSharedLink
     */
    'completed_redirect_url'?: string;
    /**
     * When the link has expired, the user will be immediately redirected to this URL instead of seeing the default Onfido error message.
     * @type {string}
     * @memberof WorkflowRunSharedLink
     */
    'expired_redirect_url'?: string;
    /**
     * Date and time when the link will expire.
     * @type {string}
     * @memberof WorkflowRunSharedLink
     */
    'expires_at'?: string;
    /**
     * The code for the language when the workflow run is acessed using the link.
     * @type {string}
     * @memberof WorkflowRunSharedLink
     */
    'language'?: WorkflowRunSharedLinkLanguageEnum;
}

export const WorkflowRunSharedLinkLanguageEnum = {
    EnUs: 'en_US',
    DeDe: 'de_DE',
    EsEs: 'es_ES',
    FrFr: 'fr_FR',
    ItIt: 'it_IT',
    PtPt: 'pt_PT',
    NlNl: 'nl_NL',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type WorkflowRunSharedLinkLanguageEnum = typeof WorkflowRunSharedLinkLanguageEnum[keyof typeof WorkflowRunSharedLinkLanguageEnum];


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels single paused reports. 
         * @summary Cancel report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('cancelReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/cancel`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a Send / Receive Data Task. 
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('completeTask', 'workflowRunId', workflowRunId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('completeTask', 'taskId', taskId)
            // verify required parameter 'completeTaskBuilder' is not null or undefined
            assertParamExists('completeTask', 'completeTaskBuilder', completeTaskBuilder)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}/complete`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTaskBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a single applicant. Returns an applicant object. 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant: async (applicantBuilder: ApplicantBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantBuilder' is not null or undefined
            assertParamExists('createApplicant', 'applicantBuilder', applicantBuilder)
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicantBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck: async (checkBuilder: CheckBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkBuilder' is not null or undefined
            assertParamExists('createCheck', 'checkBuilder', checkBuilder)
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run. 
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('createTimelineFile', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new monitor for the applicant 
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor: async (watchlistMonitorBuilder: WatchlistMonitorBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'watchlistMonitorBuilder' is not null or undefined
            assertParamExists('createWatchlistMonitor', 'watchlistMonitorBuilder', watchlistMonitorBuilder)
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitorBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a webhook. Returns a webhook object. 
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (webhookBuilder: WebhookBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookBuilder' is not null or undefined
            assertParamExists('createWebhook', 'webhookBuilder', webhookBuilder)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object. 
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun: async (workflowRunBuilder: WorkflowRunBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunBuilder' is not null or undefined
            assertParamExists('createWorkflowRun', 'workflowRunBuilder', workflowRunBuilder)
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workflowRunBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single applicant. 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('deleteApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates the given monitor 
         * @summary Delete monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('deleteWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a webhook. 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
         * @summary Download check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('downloadCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}/download`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocument', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video. 
         * @summary Download document video
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentVideo', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}/video/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto: async (idPhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('downloadIdPhoto', 'idPhotoId', idPhotoId)
            const localVarPath = `/id_photos/{id_photo_id}/download`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto: async (livePhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('downloadLivePhoto', 'livePhotoId', livePhotoId)
            const localVarPath = `/live_photos/{live_photo_id}/download`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideo', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}/download`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('downloadLiveVideoFrame', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}/frame`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCapture', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}/download`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('downloadMotionCaptureFrame', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}/frame`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided. 
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument: async (workflowRunId: string, fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadQesDocument', 'workflowRunId', workflowRunId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('downloadQesDocument', 'fileId', fileId)
            const localVarPath = `/qualified_electronic_signature/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (workflowRunId !== undefined) {
                localVarQueryParameter['workflow_run_id'] = workflowRunId;
            }

            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('downloadSignedEvidenceFile', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/signed_evidence_file`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extract information from a document 
         * @summary Autofill
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract: async (extractRequest: ExtractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extractRequest' is not null or undefined
            assertParamExists('extract', 'extractRequest', extractRequest)
            const localVarPath = `/extractions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(extractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for addresses by postcode 
         * @summary Address Picker
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses: async (postcode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postcode' is not null or undefined
            assertParamExists('findAddresses', 'postcode', postcode)
            const localVarPath = `/addresses/pick`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (postcode !== undefined) {
                localVarQueryParameter['postcode'] = postcode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single applicant. Returns an applicant object. 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('findApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('findCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
         * @summary Retrieve document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('findDocument', 'documentId', documentId)
            const localVarPath = `/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object. 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto: async (idPhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idPhotoId' is not null or undefined
            assertParamExists('findIdPhoto', 'idPhotoId', idPhotoId)
            const localVarPath = `/id_photos/{id_photo_id}`
                .replace(`{${"id_photo_id"}}`, encodeURIComponent(String(idPhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single live photo. Returns a live photo object. 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto: async (livePhotoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'livePhotoId' is not null or undefined
            assertParamExists('findLivePhoto', 'livePhotoId', livePhotoId)
            const localVarPath = `/live_photos/{live_photo_id}`
                .replace(`{${"live_photo_id"}}`, encodeURIComponent(String(livePhotoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object. 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo: async (liveVideoId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveVideoId' is not null or undefined
            assertParamExists('findLiveVideo', 'liveVideoId', liveVideoId)
            const localVarPath = `/live_videos/{live_video_id}`
                .replace(`{${"live_video_id"}}`, encodeURIComponent(String(liveVideoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object. 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture: async (motionCaptureId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'motionCaptureId' is not null or undefined
            assertParamExists('findMotionCapture', 'motionCaptureId', motionCaptureId)
            const localVarPath = `/motion_captures/{motion_capture_id}`
                .replace(`{${"motion_capture_id"}}`, encodeURIComponent(String(motionCaptureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
         * @summary Retrieve report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('findReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask: async (workflowRunId: string, taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findTask', 'workflowRunId', workflowRunId)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('findTask', 'taskId', taskId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks/{task_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"task_id"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run. 
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile: async (workflowRunId: string, timelineFileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findTimelineFile', 'workflowRunId', workflowRunId)
            // verify required parameter 'timelineFileId' is not null or undefined
            assertParamExists('findTimelineFile', 'timelineFileId', timelineFileId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/timeline_file/{timeline_file_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)))
                .replace(`{${"timeline_file_id"}}`, encodeURIComponent(String(timelineFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single monitor 
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('findWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single webhook. Returns a webhook object. 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('findWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('findWorkflowRun', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('forceReportCreationFromWatchlistMonitor', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}/new_report`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token. 
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken: async (sdkTokenBuilder: SdkTokenBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sdkTokenBuilder' is not null or undefined
            assertParamExists('generateSdkToken', 'sdkTokenBuilder', sdkTokenBuilder)
            const localVarPath = `/sdk_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sdkTokenBuilder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order. 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants: async (page?: number, perPage?: number, includeDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/applicants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listChecks', 'applicantId', applicantId)
            const localVarPath = `/checks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listDocuments', 'applicantId', applicantId)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the ID photos that belong to an applicant. 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listIdPhotos', 'applicantId', applicantId)
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the live photos that belong to an applicant. 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLivePhotos', 'applicantId', applicantId)
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the live videos that belong to an applicant. 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listLiveVideos', 'applicantId', applicantId)
            const localVarPath = `/live_videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all the motion captures that belong to an applicant. 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listMotionCaptures', 'applicantId', applicantId)
            const localVarPath = `/motion_captures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all repeat attempts for a given Document report 
         * @summary Retrieve repeat attempts
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('listRepeatAttempts', 'reportId', reportId)
            const localVarPath = `/repeat_attempts/{report_id}`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint. 
         * @summary List reports
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('listReports', 'checkId', checkId)
            const localVarPath = `/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checkId !== undefined) {
                localVarQueryParameter['check_id'] = checkId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (workflowRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workflowRunId' is not null or undefined
            assertParamExists('listTasks', 'workflowRunId', workflowRunId)
            const localVarPath = `/workflow_runs/{workflow_run_id}/tasks`
                .replace(`{${"workflow_run_id"}}`, encodeURIComponent(String(workflowRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status 
         * @summary List matches (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches: async (monitorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('listWatchlistMonitorMatches', 'monitorId', monitorId)
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all available monitors for an applicant 
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors: async (applicantId: string, includeDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('listWatchlistMonitors', 'applicantId', applicantId)
            const localVarPath = `/watchlist_monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (applicantId !== undefined) {
                localVarQueryParameter['applicant_id'] = applicantId;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all webhooks you\'ve created. 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns: async (page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workflow_runs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (createdAtGt !== undefined) {
                localVarQueryParameter['created_at_gt'] = (createdAtGt as any instanceof Date) ?
                    (createdAtGt as any).toISOString() :
                    createdAtGt;
            }

            if (createdAtLt !== undefined) {
                localVarQueryParameter['created_at_lt'] = (createdAtLt as any instanceof Date) ?
                    (createdAtLt as any).toISOString() :
                    createdAtLt;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a health check on the Onfido API 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create Feedback on checks and reports 
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback: async (resultsFeedback: ResultsFeedback, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultsFeedback' is not null or undefined
            assertParamExists('postResultsFeedback', 'resultsFeedback', resultsFeedback)
            const localVarPath = `/results_feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resultsFeedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account. 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks: async (webhookResend: WebhookResend, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookResend' is not null or undefined
            assertParamExists('resendWebhooks', 'webhookResend', webhookResend)
            const localVarPath = `/webhooks/resend`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookResend, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restores a single applicant scheduled for deletion. 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant: async (applicantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('restoreApplicant', 'applicantId', applicantId)
            const localVarPath = `/applicants/{applicant_id}/restore`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a paused check. 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck: async (checkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkId' is not null or undefined
            assertParamExists('resumeCheck', 'checkId', checkId)
            const localVarPath = `/checks/{check_id}/resume`
                .replace(`{${"check_id"}}`, encodeURIComponent(String(checkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resumes a single paused report. 
         * @summary Resume report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport: async (reportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('resumeReport', 'reportId', reportId)
            const localVarPath = `/reports/{report_id}/resume`
                .replace(`{${"report_id"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantUpdater} applicantUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant: async (applicantId: string, applicantUpdater: ApplicantUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('updateApplicant', 'applicantId', applicantId)
            // verify required parameter 'applicantUpdater' is not null or undefined
            assertParamExists('updateApplicant', 'applicantUpdater', applicantUpdater)
            const localVarPath = `/applicants/{applicant_id}`
                .replace(`{${"applicant_id"}}`, encodeURIComponent(String(applicantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applicantUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the status of the given matches 
         * @summary Set match status (BETA)
         * @param {string} monitorId 
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch: async (monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'monitorId' is not null or undefined
            assertParamExists('updateWatchlistMonitorMatch', 'monitorId', monitorId)
            // verify required parameter 'watchlistMonitorMatchesUpdater' is not null or undefined
            assertParamExists('updateWatchlistMonitorMatch', 'watchlistMonitorMatchesUpdater', watchlistMonitorMatchesUpdater)
            const localVarPath = `/watchlist_monitors/{monitor_id}/matches`
                .replace(`{${"monitor_id"}}`, encodeURIComponent(String(monitorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(watchlistMonitorMatchesUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edits a webhook. Returns the updated webhook object. 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, webhookUpdater: WebhookUpdater, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            // verify required parameter 'webhookUpdater' is not null or undefined
            assertParamExists('updateWebhook', 'webhookUpdater', webhookUpdater)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdater, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {string} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument: async (type: string, applicantId: string, file: FileTransfer, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('uploadDocument', 'type', type)
            // verify required parameter 'applicantId' is not null or undefined
            assertParamExists('uploadDocument', 'applicantId', applicantId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocument', 'file', file)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (fileType !== undefined) { 
                localVarFormParams.append('file_type', fileType as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.append('side', side as any);
            }
    
            if (issuingCountry !== undefined) { 
                localVarFormParams.append('issuing_country', issuingCountry as any);
            }
    
            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
            if (validateImageQuality !== undefined) { 
                localVarFormParams.append('validate_image_quality', String(validateImageQuality) as any);
            }
    
            if (location !== undefined) { 
                localVarFormParams.append('location', JSON.stringify(location));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto: async (applicantId?: string, file?: FileTransfer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/id_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto: async (applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/live_photos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (applicantId !== undefined) { 
                localVarFormParams.append('applicant_id', applicantId as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file.buffer as any, file.filename);
            }
    
            if (advancedValidation !== undefined) { 
                localVarFormParams.append('advanced_validation', String(advancedValidation) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels single paused reports. 
         * @summary Cancel report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.cancelReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes a Send / Receive Data Task. 
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(workflowRunId, taskId, completeTaskBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.completeTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a single applicant. Returns an applicant object. 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApplicant(applicantBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheck(checkBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run. 
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTimelineFile(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimelineFileReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTimelineFile(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createTimelineFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new monitor for the applicant 
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWatchlistMonitor(watchlistMonitorBuilder: WatchlistMonitorBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchlistMonitor(watchlistMonitorBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registers a webhook. Returns a webhook object. 
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(webhookBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object. 
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflowRun(workflowRunBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createWorkflowRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single applicant. 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates the given monitor 
         * @summary Delete monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a webhook. 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
         * @summary Download check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video. 
         * @summary Download document video
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentVideo(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadDocumentVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadIdPhoto(idPhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLivePhoto(livePhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLiveVideo(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLiveVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadLiveVideoFrame(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadLiveVideoFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMotionCapture(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadMotionCapture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMotionCaptureFrame(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadMotionCaptureFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided. 
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadQesDocument(workflowRunId: string, fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadQesDocument(workflowRunId, fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadQesDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSignedEvidenceFile(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.downloadSignedEvidenceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Extract information from a document 
         * @summary Autofill
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Extraction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extract(extractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.extract']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for addresses by postcode 
         * @summary Address Picker
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAddresses(postcode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAddresses(postcode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single applicant. Returns an applicant object. 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
         * @summary Retrieve document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDocument(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDocument(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object. 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIdPhoto(idPhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single live photo. Returns a live photo object. 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLivePhoto(livePhotoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object. 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveVideo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLiveVideo(liveVideoId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findLiveVideo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object. 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotionCapture>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMotionCapture(motionCaptureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findMotionCapture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
         * @summary Retrieve report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Report>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTask(workflowRunId, taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run. 
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTimelineFile(workflowRunId: string, timelineFileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileTransfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTimelineFile(workflowRunId, timelineFileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findTimelineFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single monitor 
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single webhook. Returns a webhook object. 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkflowRun(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.findWorkflowRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceReportCreationFromWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceReportCreationFromWatchlistMonitor(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.forceReportCreationFromWatchlistMonitor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token. 
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSdkToken(sdkTokenBuilder: SdkTokenBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SdkToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSdkToken(sdkTokenBuilder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.generateSdkToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order. 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplicantsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApplicants(page, perPage, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listApplicants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChecks(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChecksList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChecks(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listChecks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocuments(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocuments(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the ID photos that belong to an applicant. 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhotosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdPhotos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listIdPhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists the live photos that belong to an applicant. 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhotosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLivePhotos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listLivePhotos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all the live videos that belong to an applicant. 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveVideosList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLiveVideos(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listLiveVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all the motion captures that belong to an applicant. 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotionCapturesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMotionCaptures(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listMotionCaptures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all repeat attempts for a given Document report 
         * @summary Retrieve repeat attempts
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RepeatAttemptsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRepeatAttempts(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listRepeatAttempts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint. 
         * @summary List reports
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReports(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReports(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(workflowRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(workflowRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status 
         * @summary List matches (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitorMatchesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlistMonitorMatches(monitorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWatchlistMonitorMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all available monitors for an applicant 
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitorsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlistMonitors(applicantId, includeDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWatchlistMonitors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists all webhooks you\'ve created. 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhooksList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkflowRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.listWorkflowRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a health check on the Onfido API 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create Feedback on checks and reports 
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultsFeedback>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postResultsFeedback(resultsFeedback, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.postResultsFeedback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account. 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhooks(webhookResend, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resendWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restores a single applicant scheduled for deletion. 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreApplicant(applicantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.restoreApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resumes a paused check. 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeCheck(checkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeCheck(checkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resumeCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resumes a single paused report. 
         * @summary Resume report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeReport(reportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeReport(reportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.resumeReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantUpdater} applicantUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApplicant(applicantId: string, applicantUpdater: ApplicantUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Applicant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApplicant(applicantId, applicantUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateApplicant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the status of the given matches 
         * @summary Set match status (BETA)
         * @param {string} monitorId 
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWatchlistMonitorMatch(monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistMonitorMatchesList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWatchlistMonitorMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edits a webhook. Returns the updated webhook object. 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, webhookUpdater, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {string} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocument(type: string, applicantId: string, file: FileTransfer, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadDocument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadIdPhoto(applicantId?: string, file?: FileTransfer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdPhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadIdPhoto(applicantId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadIdPhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadLivePhoto(applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LivePhoto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadLivePhoto(applicantId, file, advancedValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.uploadLivePhoto']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Cancels single paused reports. 
         * @summary Cancel report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelReport(reportId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a Send / Receive Data Task. 
         * @summary Complete Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to complete.
         * @param {CompleteTaskBuilder} completeTaskBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options?: any): AxiosPromise<void> {
            return localVarFp.completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a single applicant. Returns an applicant object. 
         * @summary Create Applicant
         * @param {ApplicantBuilder} applicantBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicant(applicantBuilder: ApplicantBuilder, options?: any): AxiosPromise<Applicant> {
            return localVarFp.createApplicant(applicantBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
         * @summary Create a check
         * @param {CheckBuilder} checkBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheck(checkBuilder: CheckBuilder, options?: any): AxiosPromise<Check> {
            return localVarFp.createCheck(checkBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the generation of the Timeline File for the designated Workflow Run. 
         * @summary Create Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTimelineFile(workflowRunId: string, options?: any): AxiosPromise<TimelineFileReference> {
            return localVarFp.createTimelineFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new monitor for the applicant 
         * @summary Create monitor
         * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWatchlistMonitor(watchlistMonitorBuilder: WatchlistMonitorBuilder, options?: any): AxiosPromise<WatchlistMonitor> {
            return localVarFp.createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a webhook. Returns a webhook object. 
         * @summary Register webhook
         * @param {WebhookBuilder} webhookBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(webhookBuilder: WebhookBuilder, options?: any): AxiosPromise<Webhook> {
            return localVarFp.createWebhook(webhookBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and starts a Workflow Run. Returns a Workflow Run object. 
         * @summary Create a Workflow Run
         * @param {WorkflowRunBuilder} workflowRunBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: any): AxiosPromise<WorkflowRun> {
            return localVarFp.createWorkflowRun(workflowRunBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single applicant. 
         * @summary Delete Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplicant(applicantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates the given monitor 
         * @summary Delete monitor
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWatchlistMonitor(monitorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a webhook. 
         * @summary Delete a webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
         * @summary Download check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadCheck(checkId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
         * @summary Download document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(documentId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a document video. If successful, the response will be the binary data representing the video. 
         * @summary Download document video
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentVideo(documentId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadDocumentVideo(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * ID photos are downloaded using this endpoint.
         * @summary Download ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadIdPhoto(idPhotoId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live photos are downloaded using this endpoint.
         * @summary Download live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLivePhoto(livePhotoId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Live videos are downloaded using this endpoint.
         * @summary Download live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideo(liveVideoId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the binary data representing a single frame from a live video.
         * @summary Download live video frame
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadLiveVideoFrame(liveVideoId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadLiveVideoFrame(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Motion captures are downloaded using this endpoint.
         * @summary Download motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCapture(motionCaptureId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
         * @summary Download motion capture frame
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadMotionCaptureFrame(motionCaptureId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed document or application form depending on the file_id provided. 
         * @summary Retrieves the signed document or application form
         * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
         * @param {string} fileId The unique identifier of the file which you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadQesDocument(workflowRunId: string, fileId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadQesDocument(workflowRunId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the signed evidence file for the designated Workflow Run 
         * @summary Retrieve Workflow Run Evidence Summary File
         * @param {string} workflowRunId Workflow Run ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSignedEvidenceFile(workflowRunId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Extract information from a document 
         * @summary Autofill
         * @param {ExtractRequest} extractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extract(extractRequest: ExtractRequest, options?: any): AxiosPromise<Extraction> {
            return localVarFp.extract(extractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for addresses by postcode 
         * @summary Address Picker
         * @param {string} postcode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAddresses(postcode: string, options?: any): AxiosPromise<AddressesList> {
            return localVarFp.findAddresses(postcode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single applicant. Returns an applicant object. 
         * @summary Retrieve Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicant(applicantId: string, options?: any): AxiosPromise<Applicant> {
            return localVarFp.findApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCheck(checkId: string, options?: any): AxiosPromise<Check> {
            return localVarFp.findCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
         * @summary Retrieve document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDocument(documentId: string, options?: any): AxiosPromise<Document> {
            return localVarFp.findDocument(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single ID photo. Returns a ID photo object. 
         * @summary Retrieve ID photo
         * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIdPhoto(idPhotoId: string, options?: any): AxiosPromise<IdPhoto> {
            return localVarFp.findIdPhoto(idPhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live photo. Returns a live photo object. 
         * @summary Retrieve live photo
         * @param {string} livePhotoId The live photo\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLivePhoto(livePhotoId: string, options?: any): AxiosPromise<LivePhoto> {
            return localVarFp.findLivePhoto(livePhotoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single live video. Returns the corresponding live video object. 
         * @summary Retrieve live video
         * @param {string} liveVideoId The live video\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLiveVideo(liveVideoId: string, options?: any): AxiosPromise<LiveVideo> {
            return localVarFp.findLiveVideo(liveVideoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single motion capture. Returns the corresponding motion capture object. 
         * @summary Retrieve motion capture
         * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMotionCapture(motionCaptureId: string, options?: any): AxiosPromise<MotionCapture> {
            return localVarFp.findMotionCapture(motionCaptureId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
         * @summary Retrieve report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReport(reportId: string, options?: any): AxiosPromise<Report> {
            return localVarFp.findReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
         * @summary Retrieve Task
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
         * @param {string} taskId The identifier of the Task you want to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTask(workflowRunId: string, taskId: string, options?: any): AxiosPromise<Task> {
            return localVarFp.findTask(workflowRunId, taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Timeline File for the designated Workflow Run. 
         * @summary Retrieve Timeline File for Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {string} timelineFileId The unique identifier for the Timefile File.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTimelineFile(workflowRunId: string, timelineFileId: string, options?: any): AxiosPromise<FileTransfer> {
            return localVarFp.findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single monitor 
         * @summary Retrieve monitor
         * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWatchlistMonitor(monitorId: string, options?: any): AxiosPromise<WatchlistMonitor> {
            return localVarFp.findWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single webhook. Returns a webhook object. 
         * @summary Retrieve a Webhook
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWebhook(webhookId: string, options?: any): AxiosPromise<Webhook> {
            return localVarFp.findWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary Retrieve Workflow Run
         * @param {string} workflowRunId The unique identifier of the Workflow Run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkflowRun(workflowRunId: string, options?: any): AxiosPromise<WorkflowRun> {
            return localVarFp.findWorkflowRun(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
         * @summary Force new report creation (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceReportCreationFromWatchlistMonitor(monitorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an SDK token. Returns a token object containing the SDK token. 
         * @summary Generate a SDK token
         * @param {SdkTokenBuilder} sdkTokenBuilder 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSdkToken(sdkTokenBuilder: SdkTokenBuilder, options?: any): AxiosPromise<SdkToken> {
            return localVarFp.generateSdkToken(sdkTokenBuilder, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all applicants you\'ve created, sorted by creation date in descending order. 
         * @summary List Applicants
         * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
         * @param {number} [perPage] The number of objects per page.
         * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: any): AxiosPromise<ApplicantsList> {
            return localVarFp.listApplicants(page, perPage, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single check. Returns a check object. 
         * @summary Retrieve Checks
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChecks(applicantId: string, options?: any): AxiosPromise<ChecksList> {
            return localVarFp.listChecks(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * All documents belonging to an applicant can be listed from this endpoint
         * @summary List documents
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocuments(applicantId: string, options?: any): AxiosPromise<DocumentsList> {
            return localVarFp.listDocuments(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the ID photos that belong to an applicant. 
         * @summary List ID photos
         * @param {string} applicantId The id of the applicant the ID photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdPhotos(applicantId: string, options?: any): AxiosPromise<IdPhotosList> {
            return localVarFp.listIdPhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the live photos that belong to an applicant. 
         * @summary List live photos
         * @param {string} applicantId The id of the applicant the live photos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLivePhotos(applicantId: string, options?: any): AxiosPromise<LivePhotosList> {
            return localVarFp.listLivePhotos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the live videos that belong to an applicant. 
         * @summary List live videos
         * @param {string} applicantId The id of the applicant the live videos belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLiveVideos(applicantId: string, options?: any): AxiosPromise<LiveVideosList> {
            return localVarFp.listLiveVideos(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all the motion captures that belong to an applicant. 
         * @summary List motion captures
         * @param {string} applicantId The id of the applicant the motion captures belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMotionCaptures(applicantId: string, options?: any): AxiosPromise<MotionCapturesList> {
            return localVarFp.listMotionCaptures(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all repeat attempts for a given Document report 
         * @summary Retrieve repeat attempts
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRepeatAttempts(reportId: string, options?: any): AxiosPromise<RepeatAttemptsList> {
            return localVarFp.listRepeatAttempts(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * All the reports belonging to a particular check can be listed from this endpoint. 
         * @summary List reports
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReports(checkId: string, options?: any): AxiosPromise<ReportsList> {
            return localVarFp.listReports(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
         * @summary List Tasks
         * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(workflowRunId: string, options?: any): AxiosPromise<Array<TaskItem>> {
            return localVarFp.listTasks(workflowRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * List match IDs on this monitor, as well as their enabled/disabled status 
         * @summary List matches (BETA)
         * @param {string} monitorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitorMatches(monitorId: string, options?: any): AxiosPromise<WatchlistMonitorMatchesList> {
            return localVarFp.listWatchlistMonitorMatches(monitorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all available monitors for an applicant 
         * @summary List monitors
         * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
         * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: any): AxiosPromise<WatchlistMonitorsList> {
            return localVarFp.listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all webhooks you\'ve created. 
         * @summary List webhooks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(options?: any): AxiosPromise<WebhooksList> {
            return localVarFp.listWebhooks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
         * @summary List Workflow Runs
         * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
         * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
         * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
         * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
         * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options?: any): AxiosPromise<Array<WorkflowRun>> {
            return localVarFp.listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a health check on the Onfido API 
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Create Feedback on checks and reports 
         * @summary Fraud reporting (ALPHA)
         * @param {ResultsFeedback} resultsFeedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postResultsFeedback(resultsFeedback: ResultsFeedback, options?: any): AxiosPromise<ResultsFeedback> {
            return localVarFp.postResultsFeedback(resultsFeedback, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends events to all webhooks registered with a matching environment in your account. 
         * @summary Resends webhooks
         * @param {WebhookResend} webhookResend 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhooks(webhookResend: WebhookResend, options?: any): AxiosPromise<void> {
            return localVarFp.resendWebhooks(webhookResend, options).then((request) => request(axios, basePath));
        },
        /**
         * Restores a single applicant scheduled for deletion. 
         * @summary Restore Applicant
         * @param {string} applicantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreApplicant(applicantId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreApplicant(applicantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a paused check. 
         * @summary Resume a Check
         * @param {string} checkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeCheck(checkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resumeCheck(checkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Resumes a single paused report. 
         * @summary Resume report
         * @param {string} reportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeReport(reportId: string, options?: any): AxiosPromise<void> {
            return localVarFp.resumeReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
         * @summary Update Applicant
         * @param {string} applicantId 
         * @param {ApplicantUpdater} applicantUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicant(applicantId: string, applicantUpdater: ApplicantUpdater, options?: any): AxiosPromise<Applicant> {
            return localVarFp.updateApplicant(applicantId, applicantUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the status of the given matches 
         * @summary Set match status (BETA)
         * @param {string} monitorId 
         * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWatchlistMonitorMatch(monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options?: any): AxiosPromise<WatchlistMonitorMatchesList> {
            return localVarFp.updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Edits a webhook. Returns the updated webhook object. 
         * @summary Edit a webhook
         * @param {string} webhookId 
         * @param {WebhookUpdater} webhookUpdater 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: any): AxiosPromise<Webhook> {
            return localVarFp.updateWebhook(webhookId, webhookUpdater, options).then((request) => request(axios, basePath));
        },
        /**
         * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
         * @summary Upload a document
         * @param {string} type The type of document
         * @param {string} applicantId The ID of the applicant whose document is being uploaded.
         * @param {FileTransfer} file The file to be uploaded.
         * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
         * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
         * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
         * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
         * @param {LocationBuilder} [location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocument(type: string, applicantId: string, file: FileTransfer, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: any): AxiosPromise<Document> {
            return localVarFp.uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
         * @summary Upload ID photo
         * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadIdPhoto(applicantId?: string, file?: FileTransfer, options?: any): AxiosPromise<IdPhoto> {
            return localVarFp.uploadIdPhoto(applicantId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
         * @summary Upload live photo
         * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
         * @param {FileTransfer} [file] The file to be uploaded.
         * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadLivePhoto(applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options?: any): AxiosPromise<LivePhoto> {
            return localVarFp.uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Cancels single paused reports. 
     * @summary Cancel report
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a Send / Receive Data Task. 
     * @summary Complete Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to complete.
     * @param {CompleteTaskBuilder} completeTaskBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public completeTask(workflowRunId: string, taskId: string, completeTaskBuilder: CompleteTaskBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).completeTask(workflowRunId, taskId, completeTaskBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a single applicant. Returns an applicant object. 
     * @summary Create Applicant
     * @param {ApplicantBuilder} applicantBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createApplicant(applicantBuilder: ApplicantBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createApplicant(applicantBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a check for an applicant, which can contain one or more reports. Returns a check object. 
     * @summary Create a check
     * @param {CheckBuilder} checkBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createCheck(checkBuilder: CheckBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createCheck(checkBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers the generation of the Timeline File for the designated Workflow Run. 
     * @summary Create Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createTimelineFile(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createTimelineFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new monitor for the applicant 
     * @summary Create monitor
     * @param {WatchlistMonitorBuilder} watchlistMonitorBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWatchlistMonitor(watchlistMonitorBuilder: WatchlistMonitorBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWatchlistMonitor(watchlistMonitorBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a webhook. Returns a webhook object. 
     * @summary Register webhook
     * @param {WebhookBuilder} webhookBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWebhook(webhookBuilder: WebhookBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWebhook(webhookBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and starts a Workflow Run. Returns a Workflow Run object. 
     * @summary Create a Workflow Run
     * @param {WorkflowRunBuilder} workflowRunBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createWorkflowRun(workflowRunBuilder: WorkflowRunBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createWorkflowRun(workflowRunBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single applicant. 
     * @summary Delete Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates the given monitor 
     * @summary Delete monitor
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a webhook. 
     * @summary Delete a webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a PDF of a check with a given check ID. Returns the binary data representing the PDF. 
     * @summary Download check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads specific documents belonging to an applicant. If successful, the response will be the binary data representing the image. 
     * @summary Download document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Downloads a document video. If successful, the response will be the binary data representing the video. 
     * @summary Download document video
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadDocumentVideo(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadDocumentVideo(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ID photos are downloaded using this endpoint.
     * @summary Download ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Live photos are downloaded using this endpoint.
     * @summary Download live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Live videos are downloaded using this endpoint.
     * @summary Download live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the binary data representing a single frame from a live video.
     * @summary Download live video frame
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadLiveVideoFrame(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadLiveVideoFrame(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Motion captures are downloaded using this endpoint.
     * @summary Download motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Instead of the whole capture binary, a single frame can be downloaded using this endpoint. Returns the binary data representing the frame.
     * @summary Download motion capture frame
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadMotionCaptureFrame(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadMotionCaptureFrame(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the signed document or application form depending on the file_id provided. 
     * @summary Retrieves the signed document or application form
     * @param {string} workflowRunId The unique identifier of the Workflow Run for which you want to retrieve the signed document.
     * @param {string} fileId The unique identifier of the file which you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadQesDocument(workflowRunId: string, fileId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadQesDocument(workflowRunId, fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the signed evidence file for the designated Workflow Run 
     * @summary Retrieve Workflow Run Evidence Summary File
     * @param {string} workflowRunId Workflow Run ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public downloadSignedEvidenceFile(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).downloadSignedEvidenceFile(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Extract information from a document 
     * @summary Autofill
     * @param {ExtractRequest} extractRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extract(extractRequest: ExtractRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extract(extractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for addresses by postcode 
     * @summary Address Picker
     * @param {string} postcode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findAddresses(postcode: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findAddresses(postcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single applicant. Returns an applicant object. 
     * @summary Retrieve Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single check. Returns a check object. 
     * @summary Retrieve a Check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single document can be retrieved by calling this endpoint with the document\'s unique identifier. 
     * @summary Retrieve document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findDocument(documentId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findDocument(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single ID photo. Returns a ID photo object. 
     * @summary Retrieve ID photo
     * @param {string} idPhotoId The ID photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findIdPhoto(idPhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findIdPhoto(idPhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single live photo. Returns a live photo object. 
     * @summary Retrieve live photo
     * @param {string} livePhotoId The live photo\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findLivePhoto(livePhotoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findLivePhoto(livePhotoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single live video. Returns the corresponding live video object. 
     * @summary Retrieve live video
     * @param {string} liveVideoId The live video\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findLiveVideo(liveVideoId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findLiveVideo(liveVideoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single motion capture. Returns the corresponding motion capture object. 
     * @summary Retrieve motion capture
     * @param {string} motionCaptureId The motion capture\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findMotionCapture(motionCaptureId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findMotionCapture(motionCaptureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single report can be retrieved using this endpoint with the corresponding unique identifier. 
     * @summary Retrieve report
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single task can be retrieved by calling this endpoint with the unique identifier of the Task and Workflow Run. 
     * @summary Retrieve Task
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Task belongs.
     * @param {string} taskId The identifier of the Task you want to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findTask(workflowRunId: string, taskId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findTask(workflowRunId, taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Timeline File for the designated Workflow Run. 
     * @summary Retrieve Timeline File for Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {string} timelineFileId The unique identifier for the Timefile File.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findTimelineFile(workflowRunId: string, timelineFileId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findTimelineFile(workflowRunId, timelineFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single monitor 
     * @summary Retrieve monitor
     * @param {string} monitorId The watchlist monitor\&#39;s unique identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single webhook. Returns a webhook object. 
     * @summary Retrieve a Webhook
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A single workflow run can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
     * @summary Retrieve Workflow Run
     * @param {string} workflowRunId The unique identifier of the Workflow Run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public findWorkflowRun(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).findWorkflowRun(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a new check with an updated report to be generated by the monitor, as if the monitor had received an update. 
     * @summary Force new report creation (BETA)
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public forceReportCreationFromWatchlistMonitor(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).forceReportCreationFromWatchlistMonitor(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an SDK token. Returns a token object containing the SDK token. 
     * @summary Generate a SDK token
     * @param {SdkTokenBuilder} sdkTokenBuilder 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public generateSdkToken(sdkTokenBuilder: SdkTokenBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).generateSdkToken(sdkTokenBuilder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all applicants you\'ve created, sorted by creation date in descending order. 
     * @summary List Applicants
     * @param {number} [page] The page to return. The first page is &#x60;page&#x3D;1&#x60;
     * @param {number} [perPage] The number of objects per page.
     * @param {boolean} [includeDeleted] Whether to also include applicants scheduled for deletion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listApplicants(page?: number, perPage?: number, includeDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listApplicants(page, perPage, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single check. Returns a check object. 
     * @summary Retrieve Checks
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listChecks(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listChecks(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All documents belonging to an applicant can be listed from this endpoint
     * @summary List documents
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listDocuments(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listDocuments(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the ID photos that belong to an applicant. 
     * @summary List ID photos
     * @param {string} applicantId The id of the applicant the ID photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listIdPhotos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listIdPhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the live photos that belong to an applicant. 
     * @summary List live photos
     * @param {string} applicantId The id of the applicant the live photos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listLivePhotos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listLivePhotos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the live videos that belong to an applicant. 
     * @summary List live videos
     * @param {string} applicantId The id of the applicant the live videos belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listLiveVideos(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listLiveVideos(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all the motion captures that belong to an applicant. 
     * @summary List motion captures
     * @param {string} applicantId The id of the applicant the motion captures belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listMotionCaptures(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listMotionCaptures(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all repeat attempts for a given Document report 
     * @summary Retrieve repeat attempts
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listRepeatAttempts(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listRepeatAttempts(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All the reports belonging to a particular check can be listed from this endpoint. 
     * @summary List reports
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listReports(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listReports(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The tasks of a Workflow can be retrieved by calling this endpoint with the unique identifier of the Workflow Run. 
     * @summary List Tasks
     * @param {string} workflowRunId The unique identifier of the Workflow Run to which the Tasks belong.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listTasks(workflowRunId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listTasks(workflowRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List match IDs on this monitor, as well as their enabled/disabled status 
     * @summary List matches (BETA)
     * @param {string} monitorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWatchlistMonitorMatches(monitorId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWatchlistMonitorMatches(monitorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all available monitors for an applicant 
     * @summary List monitors
     * @param {string} applicantId The id of the applicant the watchlist monitors belong to. If omitted, all monitors for the account will be listed.
     * @param {boolean} [includeDeleted] Whether to also include deleted (inactive) monitors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWatchlistMonitors(applicantId: string, includeDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWatchlistMonitors(applicantId, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists all webhooks you\'ve created. 
     * @summary List webhooks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWebhooks(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWebhooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Workflow Runs of the client. Returns a list of Workflow Run objects. 
     * @summary List Workflow Runs
     * @param {number} [page] The number of the page to be retrieved. If not specified, defaults to 1.
     * @param {string} [status] A list of comma separated status values to filter the results. Possible values are \&#39;processing\&#39;, \&#39;awaiting_input\&#39;, \&#39;approved\&#39;, \&#39;declined\&#39;, \&#39;review\&#39;, \&#39;abandoned\&#39; and \&#39;error\&#39;.
     * @param {string} [createdAtGt] A ISO-8601 date to filter results with a created date greater than (after) the one provided.
     * @param {string} [createdAtLt] A ISO-8601 date to filter results with a created date less than (before) the one provided.
     * @param {ListWorkflowRunsSortEnum} [sort] A string with the value \&#39;desc\&#39; or \&#39;asc\&#39; that allows to sort the returned list by the completed datetime either descending or ascending, respectively. If not specified, defaults to \&#39;desc\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listWorkflowRuns(page?: number, status?: string, createdAtGt?: string, createdAtLt?: string, sort?: ListWorkflowRunsSortEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listWorkflowRuns(page, status, createdAtGt, createdAtLt, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a health check on the Onfido API 
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create Feedback on checks and reports 
     * @summary Fraud reporting (ALPHA)
     * @param {ResultsFeedback} resultsFeedback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public postResultsFeedback(resultsFeedback: ResultsFeedback, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).postResultsFeedback(resultsFeedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends events to all webhooks registered with a matching environment in your account. 
     * @summary Resends webhooks
     * @param {WebhookResend} webhookResend 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resendWebhooks(webhookResend: WebhookResend, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resendWebhooks(webhookResend, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restores a single applicant scheduled for deletion. 
     * @summary Restore Applicant
     * @param {string} applicantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public restoreApplicant(applicantId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).restoreApplicant(applicantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a paused check. 
     * @summary Resume a Check
     * @param {string} checkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resumeCheck(checkId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resumeCheck(checkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resumes a single paused report. 
     * @summary Resume report
     * @param {string} reportId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public resumeReport(reportId: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).resumeReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows updating applicant\'s information before any checks is created. - Partial updates - Addresses and ID numbers present will replace existing ones - Same applicant validations to create applicant 
     * @summary Update Applicant
     * @param {string} applicantId 
     * @param {ApplicantUpdater} applicantUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateApplicant(applicantId: string, applicantUpdater: ApplicantUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateApplicant(applicantId, applicantUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the status of the given matches 
     * @summary Set match status (BETA)
     * @param {string} monitorId 
     * @param {WatchlistMonitorMatchesUpdater} watchlistMonitorMatchesUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateWatchlistMonitorMatch(monitorId: string, watchlistMonitorMatchesUpdater: WatchlistMonitorMatchesUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWatchlistMonitorMatch(monitorId, watchlistMonitorMatchesUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edits a webhook. Returns the updated webhook object. 
     * @summary Edit a webhook
     * @param {string} webhookId 
     * @param {WebhookUpdater} webhookUpdater 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateWebhook(webhookId: string, webhookUpdater: WebhookUpdater, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateWebhook(webhookId, webhookUpdater, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Documents are uploaded using this endpoint. Along with the file upload the relevant document type must be specified. Documents must be uploaded as a multipart form. The valid file types are: jpg, png and pdf. The file size must be between 2KB and 3MB. 
     * @summary Upload a document
     * @param {string} type The type of document
     * @param {string} applicantId The ID of the applicant whose document is being uploaded.
     * @param {FileTransfer} file The file to be uploaded.
     * @param {UploadDocumentFileTypeEnum} [fileType] The file type of the uploaded file
     * @param {UploadDocumentSideEnum} [side] The side of the document, if applicable. The possible values are front and back
     * @param {CountryCodes} [issuingCountry] The issuing country of the document, a 3-letter ISO code.
     * @param {boolean} [validateImageQuality] Defaults to false. When true the submitted image will undergo an image quality validation which may take up to 5 seconds.
     * @param {LocationBuilder} [location] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadDocument(type: string, applicantId: string, file: FileTransfer, fileType?: UploadDocumentFileTypeEnum, side?: UploadDocumentSideEnum, issuingCountry?: CountryCodes, validateImageQuality?: boolean, location?: LocationBuilder, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadDocument(type, applicantId, file, fileType, side, issuingCountry, validateImageQuality, location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can upload ID photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. 
     * @summary Upload ID photo
     * @param {string} [applicantId] The ID of the applicant whose ID photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadIdPhoto(applicantId?: string, file?: FileTransfer, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadIdPhoto(applicantId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can upload live photos to this endpoint. Like document upload, files must be uploaded as a multipart form. Valid file types are jpg, png and pdf. The file size must be between 32KB and 10MB. Live photos are validated at the point of upload to check that they contain exactly one face. This validation can be disabled by setting the advanced_validation argument to false. 
     * @summary Upload live photo
     * @param {string} [applicantId] The ID of the applicant whose live photo is being uploaded.
     * @param {FileTransfer} [file] The file to be uploaded.
     * @param {boolean} [advancedValidation] Validates that the live photo contains exactly one face.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadLivePhoto(applicantId?: string, file?: FileTransfer, advancedValidation?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).uploadLivePhoto(applicantId, file, advancedValidation, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListWorkflowRunsSortEnum = {
    Desc: 'desc',
    Asc: 'asc',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type ListWorkflowRunsSortEnum = typeof ListWorkflowRunsSortEnum[keyof typeof ListWorkflowRunsSortEnum];
/**
 * @export
 */
export const UploadDocumentFileTypeEnum = {
    Jpg: 'jpg',
    Jpeg: 'jpeg',
    Png: 'png',
    Pdf: 'pdf',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type UploadDocumentFileTypeEnum = typeof UploadDocumentFileTypeEnum[keyof typeof UploadDocumentFileTypeEnum];
/**
 * @export
 */
export const UploadDocumentSideEnum = {
    Front: 'front',
    Back: 'back',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type UploadDocumentSideEnum = typeof UploadDocumentSideEnum[keyof typeof UploadDocumentSideEnum];


